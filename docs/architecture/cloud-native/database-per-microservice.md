---
title: Base de datos por microservicio
description: Contraste el almacenamiento de datos en aplicaciones monolíticas y nativas de la nube.
author: robvet
ms.date: 01/22/2020
ms.openlocfilehash: c0c5611fa866d70f155e4bdad2eee1181b13c065
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/12/2020
ms.locfileid: "79141450"
---
# <a name="database-per-microservice"></a><span data-ttu-id="abea9-103">Base de datos por microservicio</span><span class="sxs-lookup"><span data-stu-id="abea9-103">Database-per-microservice</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="abea9-104">Como hemos visto a lo largo de este libro, un enfoque nativo de la nube cambia la forma en que diseña, implementa y administra las aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="abea9-104">As we've seen throughout this book, a cloud-native approach changes the way you design, deploy, and manage applications.</span></span> <span data-ttu-id="abea9-105">También cambia la forma de administrar y almacenar datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-105">It also changes the way you manage and store data.</span></span>

<span data-ttu-id="abea9-106">La Figura 5-1 contrasta las diferencias.</span><span class="sxs-lookup"><span data-stu-id="abea9-106">Figure 5-1 contrasts the differences.</span></span>

![Almacenamiento de datos en aplicaciones nativas de la nube](./media/distributed-data.png)

<span data-ttu-id="abea9-108">**Figura 5-1**.</span><span class="sxs-lookup"><span data-stu-id="abea9-108">**Figure 5-1**.</span></span> <span data-ttu-id="abea9-109">Gestión de datos en aplicaciones nativas de la nube</span><span class="sxs-lookup"><span data-stu-id="abea9-109">Data management in cloud-native applications</span></span>

<span data-ttu-id="abea9-110">Los desarrolladores experimentados reconocerán fácilmente la arquitectura en el lado izquierdo de la figura 5-1.</span><span class="sxs-lookup"><span data-stu-id="abea9-110">Experienced developers will easily recognize the architecture on the left-side of figure 5-1.</span></span> <span data-ttu-id="abea9-111">En esta *aplicación monolítica,* los componentes de servicio empresarial se unen en un nivel de servicios compartidos, compartiendo datos de una única base de datos relacional.</span><span class="sxs-lookup"><span data-stu-id="abea9-111">In this *monolithic application*, business service components collocate together in a shared services tier, sharing data from a single relational database.</span></span>

<span data-ttu-id="abea9-112">En muchos sentidos, una sola base de datos simplifica la administración de datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-112">In many ways, a single database keeps data management simple.</span></span> <span data-ttu-id="abea9-113">Consultar datos en varias tablas es sencillo.</span><span class="sxs-lookup"><span data-stu-id="abea9-113">Querying data across multiple tables is straightforward.</span></span> <span data-ttu-id="abea9-114">Los cambios en los datos se actualizan juntos o todos se revierten.</span><span class="sxs-lookup"><span data-stu-id="abea9-114">Changes to data update together or they all rollback.</span></span> <span data-ttu-id="abea9-115">[Las transacciones ACID](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) garantizan una consistencia fuerte e inmediata.</span><span class="sxs-lookup"><span data-stu-id="abea9-115">[ACID transactions](https://docs.microsoft.com/windows/desktop/cossdk/acid-properties) guarantee strong and immediate consistency.</span></span>

<span data-ttu-id="abea9-116">Diseñando para nativos de la nube, tomamos un enfoque diferente.</span><span class="sxs-lookup"><span data-stu-id="abea9-116">Designing for cloud-native, we take a different approach.</span></span> <span data-ttu-id="abea9-117">En el lado derecho de la Figura 5-1, observe cómo la funcionalidad empresarial se separa en microservicios pequeños e independientes.</span><span class="sxs-lookup"><span data-stu-id="abea9-117">On the right-side of Figure 5-1, note how business functionality segregates into small, independent microservices.</span></span> <span data-ttu-id="abea9-118">Cada microservicio encapsula una funcionalidad empresarial específica y sus propios datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-118">Each microservice encapsulates a specific business capability and its own data.</span></span> <span data-ttu-id="abea9-119">La base de datos monolítica se descompone en un modelo de datos distribuidocon muchas bases de datos más pequeñas, cada una de las que se alinea con un microservicio.</span><span class="sxs-lookup"><span data-stu-id="abea9-119">The monolithic database decomposes into a distributed data model with many smaller databases, each aligning with a microservice.</span></span> <span data-ttu-id="abea9-120">Cuando el humo se borra, surge moscada con un diseño que expone una base de *datos por microservicio.*</span><span class="sxs-lookup"><span data-stu-id="abea9-120">When the smoke clears, we emerge with a design that exposes a *database per microservice*.</span></span>

## <a name="why"></a><span data-ttu-id="abea9-121">¿Por qué?</span><span class="sxs-lookup"><span data-stu-id="abea9-121">Why?</span></span>

<span data-ttu-id="abea9-122">Esta base de datos por microservicio proporciona muchas ventajas, especialmente para los sistemas que deben evolucionar rápidamente y admitir una escala masiva.</span><span class="sxs-lookup"><span data-stu-id="abea9-122">This database per microservice provides many benefits, especially for systems that must evolve rapidly and support massive scale.</span></span> <span data-ttu-id="abea9-123">Con este modelo...</span><span class="sxs-lookup"><span data-stu-id="abea9-123">With this model...</span></span>

- <span data-ttu-id="abea9-124">Los datos de dominio se encapsulan dentro del servicio</span><span class="sxs-lookup"><span data-stu-id="abea9-124">Domain data is encapsulated within the service</span></span>
- <span data-ttu-id="abea9-125">El esquema de datos puede evolucionar sin afectar directamente a otros servicios</span><span class="sxs-lookup"><span data-stu-id="abea9-125">Data schema can evolve without directly impacting other services</span></span>
- <span data-ttu-id="abea9-126">Cada almacén de datos puede escalar de forma independiente</span><span class="sxs-lookup"><span data-stu-id="abea9-126">Each data store can independently scale</span></span>
- <span data-ttu-id="abea9-127">Un error en el almacén de datos en un servicio no afectará directamente a otros servicios</span><span class="sxs-lookup"><span data-stu-id="abea9-127">A data store failure in one service won't directly impact other services</span></span>

<span data-ttu-id="abea9-128">La segregación de datos también permite que cada microservicio implemente el tipo de almacén de datos que mejor se optimiza para su carga de trabajo, las necesidades de almacenamiento y los patrones de lectura y escritura.</span><span class="sxs-lookup"><span data-stu-id="abea9-128">Segregating data also enables each microservice to implement the data store type that is best optimized for its workload, storage needs, and read/write patterns.</span></span> <span data-ttu-id="abea9-129">Las opciones incluyen almacenes de datos relacionales, de documentos, clave-valor e incluso basados en gráficos.</span><span class="sxs-lookup"><span data-stu-id="abea9-129">Choices include relational, document, key-value, and even graph-based data stores.</span></span>

<span data-ttu-id="abea9-130">La Figura 5-2 presenta el principio de persistencia políglota en un sistema nativo de la nube.</span><span class="sxs-lookup"><span data-stu-id="abea9-130">Figure 5-2 presents the principle of polyglot persistence in a cloud-native system.</span></span>

![Persistencia de datos políglotas](./media/polyglot-data-persistence.png)

<span data-ttu-id="abea9-132">**Figura 5-2**.</span><span class="sxs-lookup"><span data-stu-id="abea9-132">**Figure 5-2**.</span></span> <span data-ttu-id="abea9-133">Persistencia de datos políglotas</span><span class="sxs-lookup"><span data-stu-id="abea9-133">Polyglot data persistence</span></span>

<span data-ttu-id="abea9-134">Tenga en cuenta en la figura anterior cómo cada microservicio admite un tipo diferente de almacén de datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-134">Note in the previous figure how each microservice supports a different type of data store.</span></span>

- <span data-ttu-id="abea9-135">El microservicio de catálogo de productos consume una base de datos relacional para dar cabida a la estructura relacional enriquecida de sus datos subyacentes.</span><span class="sxs-lookup"><span data-stu-id="abea9-135">The product catalog microservice consumes a relational database to accommodate the rich relational structure of its underlying data.</span></span>
- <span data-ttu-id="abea9-136">El microservicio del carro de la compra consume una memoria caché distribuida que admite su almacén de datos de clave-valor simple.</span><span class="sxs-lookup"><span data-stu-id="abea9-136">The shopping cart microservice consumes a distributed cache that supports its simple, key-value data store.</span></span>
- <span data-ttu-id="abea9-137">El microservicio de ordenación consume una base de datos de documentos NoSql para operaciones de escritura junto con un almacén de clave/valor altamente desnormalizado para dar cabida a grandes volúmenes de operaciones de lectura.</span><span class="sxs-lookup"><span data-stu-id="abea9-137">The ordering microservice consumes both a NoSql document database for write operations along with a highly denormalized key/value store to accommodate high-volumes of read operations.</span></span>
  
<span data-ttu-id="abea9-138">Aunque las bases de datos relacionales siguen siendo relevantes para microservicios con datos complejos, las bases de datos NoSQL han ganado una popularidad considerable.</span><span class="sxs-lookup"><span data-stu-id="abea9-138">While relational databases remain relevant for microservices with complex data, NoSQL databases have gained considerable popularity.</span></span> <span data-ttu-id="abea9-139">Proporcionan una escala masiva y alta disponibilidad.</span><span class="sxs-lookup"><span data-stu-id="abea9-139">They provide massive scale and high availability.</span></span> <span data-ttu-id="abea9-140">Su naturaleza sin esquemas permite a los desarrolladores alejarse de una arquitectura de clases de datos con tipo y ORM que hacen que el cambio sea costoso y consume mucho tiempo.</span><span class="sxs-lookup"><span data-stu-id="abea9-140">Their schemaless nature allows developers to move away from an architecture of typed data classes and ORMs that make change expensive and time-consuming.</span></span> <span data-ttu-id="abea9-141">Cubrimos bases de datos NoSQL más adelante en este capítulo.</span><span class="sxs-lookup"><span data-stu-id="abea9-141">We cover NoSQL databases later in this chapter.</span></span>

 <span data-ttu-id="abea9-142">Aunque encapsular datos en microservicios independientes puede aumentar la agilidad, el rendimiento y la escalabilidad, también presenta muchos desafíos.</span><span class="sxs-lookup"><span data-stu-id="abea9-142">While encapsulating  data into separate microservices can increase agility, performance, and scalability, it also presents many challenges.</span></span> <span data-ttu-id="abea9-143">En la siguiente sección, analizamos estos desafíos junto con patrones y prácticas para ayudar a superarlos.</span><span class="sxs-lookup"><span data-stu-id="abea9-143">In the next section, we discuss these challenges along with patterns and practices to help overcome them.</span></span>  

## <a name="cross-service-queries"></a><span data-ttu-id="abea9-144">Consultas entre servicios</span><span class="sxs-lookup"><span data-stu-id="abea9-144">Cross-service queries</span></span>

<span data-ttu-id="abea9-145">Aunque los microservicios son independientes y se centran en capacidades funcionales específicas, como inventario, envío u pedido, con frecuencia requieren integración con otros microservicios.</span><span class="sxs-lookup"><span data-stu-id="abea9-145">While microservices are independent and focus on specific functional capabilities, like inventory, shipping, or ordering, they frequently require integration with other microservices.</span></span> <span data-ttu-id="abea9-146">A menudo, la integración implica un microservicio *que consulta* a otro para obtener datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-146">Often the integration involves one microservice *querying* another for data.</span></span> <span data-ttu-id="abea9-147">La Figura 5-3 muestra el escenario.</span><span class="sxs-lookup"><span data-stu-id="abea9-147">Figure 5-3 shows the scenario.</span></span>

![Consulta a través de microservicios](./media/cross-service-query.png)

<span data-ttu-id="abea9-149">**Figura 5-3**.</span><span class="sxs-lookup"><span data-stu-id="abea9-149">**Figure 5-3**.</span></span> <span data-ttu-id="abea9-150">Consulta a través de microservicios</span><span class="sxs-lookup"><span data-stu-id="abea9-150">Querying across microservices</span></span>

<span data-ttu-id="abea9-151">En la figura anterior, vemos un microservicio de cesta de la compra que agrega un elemento a la cesta de la compra de un usuario.</span><span class="sxs-lookup"><span data-stu-id="abea9-151">In the preceding figure, we see a shopping basket microservice that adds an item to a user's shopping basket.</span></span> <span data-ttu-id="abea9-152">Aunque el almacén de datos de este microservicio contiene datos de cesta y artículos de línea, no mantiene datos de productos o precios.</span><span class="sxs-lookup"><span data-stu-id="abea9-152">While the data store for this microservice contains basket and line item data, it doesn't maintain product or pricing data.</span></span> <span data-ttu-id="abea9-153">En su lugar, esos elementos de datos son propiedad del catálogo y los microservicios de precios.</span><span class="sxs-lookup"><span data-stu-id="abea9-153">Instead, those data items are owned by the catalog and pricing microservices.</span></span> <span data-ttu-id="abea9-154">Esto presenta un problema.</span><span class="sxs-lookup"><span data-stu-id="abea9-154">This presents a problem.</span></span> <span data-ttu-id="abea9-155">¿Cómo puede el microservicio de la cesta de la compra agregar un producto a la cesta de la compra del usuario cuando no tiene datos de productos ni precios en su base de datos?</span><span class="sxs-lookup"><span data-stu-id="abea9-155">How can the shopping basket microservice add a product to the user's shopping basket when it doesn't have product nor pricing data in its database?</span></span>

<span data-ttu-id="abea9-156">Una opción que se describe en el capítulo 4 es una [llamada HTTP directa](service-to-service-communication.md#queries) desde la cesta de la compra al catálogo y a los microservicios de precios.</span><span class="sxs-lookup"><span data-stu-id="abea9-156">One option discussed in Chapter 4 is a [direct HTTP call](service-to-service-communication.md#queries) from the shopping basket to the catalog and pricing microservices.</span></span> <span data-ttu-id="abea9-157">Sin embargo, en el capítulo 4, dijimos que las llamadas HTTP sincrónicas *acoplan* microservicios, lo que reduce su autonomía y disminuye sus beneficios arquitectónicos.</span><span class="sxs-lookup"><span data-stu-id="abea9-157">However, in chapter 4, we said synchronous HTTP calls *couple* microservices together, reducing their autonomy and diminishing their architectural benefits.</span></span>

<span data-ttu-id="abea9-158">También podríamos implementar un patrón de solicitud-respuesta con colas de entrada y salida independientes para cada servicio.</span><span class="sxs-lookup"><span data-stu-id="abea9-158">We could also implement a request-reply pattern with separate inbound and outbound queues for each service.</span></span> <span data-ttu-id="abea9-159">Sin embargo, este patrón es complicado y requiere fontanería para correlacionar mensajes de solicitud y respuesta.</span><span class="sxs-lookup"><span data-stu-id="abea9-159">However, this pattern is complicated and requires plumbing to correlate request and response messages.</span></span>
<span data-ttu-id="abea9-160">Aunque desacopla las llamadas de microservicio de back-end, el servicio de llamada debe esperar sincrónicamente a que se complete la llamada.</span><span class="sxs-lookup"><span data-stu-id="abea9-160">While it does decouple the backend microservice calls, the calling service must still synchronously wait for the call to complete.</span></span> <span data-ttu-id="abea9-161">Congestión de red, errores transitorios o un microservicio sobrecargado y pueden dar lugar a operaciones de larga ejecución e incluso con errores.</span><span class="sxs-lookup"><span data-stu-id="abea9-161">Network congestion, transient faults, or an overloaded microservice and can result in long-running and even failed operations.</span></span>

<span data-ttu-id="abea9-162">En su lugar, un patrón ampliamente aceptado para quitar dependencias entre servicios es el patrón de [vista materializado,](https://docs.microsoft.com/azure/architecture/patterns/materialized-view)que se muestra en la figura 5-4.</span><span class="sxs-lookup"><span data-stu-id="abea9-162">Instead, a widely accepted pattern for removing cross-service dependencies is the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-4.</span></span>

![Patrón de vista materializado](./media/materialized-view-pattern.png)

<span data-ttu-id="abea9-164">**Figura 5-4**.</span><span class="sxs-lookup"><span data-stu-id="abea9-164">**Figure 5-4**.</span></span> <span data-ttu-id="abea9-165">Materialized View Pattern</span><span class="sxs-lookup"><span data-stu-id="abea9-165">Materialized View Pattern</span></span>

<span data-ttu-id="abea9-166">Con este patrón, se coloca una tabla de datos local (conocida como modelo de *lectura)* en el servicio de cesta de la compra.</span><span class="sxs-lookup"><span data-stu-id="abea9-166">With this pattern, you place a local data table (known as a *read model*) in the shopping basket service.</span></span> <span data-ttu-id="abea9-167">Esta tabla contiene una copia desnormalizada de los datos necesarios del producto y los microservicios de precios.</span><span class="sxs-lookup"><span data-stu-id="abea9-167">This table contains a denormalized copy of the data needed from the product and pricing microservices.</span></span> <span data-ttu-id="abea9-168">Copiar los datos directamente en el microservicio de la cesta de la compra elimina la necesidad de costosas llamadas entre servicios.</span><span class="sxs-lookup"><span data-stu-id="abea9-168">Copying the data directly into the shopping basket microservice eliminates the need for expensive cross-service calls.</span></span> <span data-ttu-id="abea9-169">Con los datos locales del servicio, se mejora el tiempo de respuesta y la fiabilidad del servicio.</span><span class="sxs-lookup"><span data-stu-id="abea9-169">With the data local to the service, you improve the service's response time and reliability.</span></span> <span data-ttu-id="abea9-170">Además, tener su propia copia de los datos hace que el servicio de cesta de la compra sea más resistente.</span><span class="sxs-lookup"><span data-stu-id="abea9-170">Additionally, having its own copy of the data makes the shopping basket service more resilient.</span></span> <span data-ttu-id="abea9-171">Si el servicio de catálogo no estuviera disponible, no afectaría directamente al servicio de cesta de la compra.</span><span class="sxs-lookup"><span data-stu-id="abea9-171">If the catalog service should become unavailable, it wouldn't directly impact the shopping basket service.</span></span> <span data-ttu-id="abea9-172">La cesta de la compra puede seguir operando con los datos de su propia tienda.</span><span class="sxs-lookup"><span data-stu-id="abea9-172">The shopping basket can continue operating with the data from its own store.</span></span>

<span data-ttu-id="abea9-173">La captura con este enfoque es que ahora tiene datos duplicados en el sistema.</span><span class="sxs-lookup"><span data-stu-id="abea9-173">The catch with this approach is that you now have duplicate data in your system.</span></span> <span data-ttu-id="abea9-174">Sin embargo, duplicar *estratégicamente* los datos en sistemas nativos de la nube es una práctica establecida y no se considera un antipatrón, o una mala práctica.</span><span class="sxs-lookup"><span data-stu-id="abea9-174">However, *strategically* duplicating data in cloud-native systems is an established practice and not considered an anti-pattern, or bad practice.</span></span> <span data-ttu-id="abea9-175">Tenga en cuenta que *uno y un solo servicio* pueden poseer un conjunto de datos y tener autoridad sobre él.</span><span class="sxs-lookup"><span data-stu-id="abea9-175">Keep in mind that *one and only one service* can own a data set and have authority over it.</span></span> <span data-ttu-id="abea9-176">Deberá sincronizar los modelos de lectura cuando se actualice el sistema de registro.</span><span class="sxs-lookup"><span data-stu-id="abea9-176">You'll need to synchronize the read models when the system of record is updated.</span></span> <span data-ttu-id="abea9-177">La sincronización se implementa normalmente a través de mensajería asincrónica con un patrón de [publicación/suscripción,](service-to-service-communication.md#events)como se muestra en la figura 5.4.</span><span class="sxs-lookup"><span data-stu-id="abea9-177">Synchronization is typically implemented via asynchronous messaging with a [publish/subscribe pattern](service-to-service-communication.md#events), as shown in Figure 5.4.</span></span>

## <a name="distributed-transactions"></a><span data-ttu-id="abea9-178">Distributed transactions</span><span class="sxs-lookup"><span data-stu-id="abea9-178">Distributed transactions</span></span>

<span data-ttu-id="abea9-179">Aunque es difícil consultar datos entre microservicios, implementar una transacción en varios microservicios es aún más complejo.</span><span class="sxs-lookup"><span data-stu-id="abea9-179">While querying data across microservices is difficult, implementing a transaction across several microservices is even more complex.</span></span> <span data-ttu-id="abea9-180">El desafío inherente de mantener la coherencia de los datos entre orígenes de datos independientes en diferentes microservicios no se puede subestimada.</span><span class="sxs-lookup"><span data-stu-id="abea9-180">The inherent challenge of maintaining data consistency across independent data sources in different microservices can't be understated.</span></span> <span data-ttu-id="abea9-181">La falta de transacciones distribuidas en aplicaciones nativas de la nube significa que debe administrar las transacciones distribuidas mediante programación.</span><span class="sxs-lookup"><span data-stu-id="abea9-181">The lack of distributed transactions in cloud-native applications means that you must manage distributed transactions programmatically.</span></span> <span data-ttu-id="abea9-182">Usted pasa de un mundo de *consistencia inmediata* a la de *consistencia final.*</span><span class="sxs-lookup"><span data-stu-id="abea9-182">You move from a world of *immediate consistency* to that of *eventual consistency*.</span></span>

<span data-ttu-id="abea9-183">La Figura 5-5 muestra el problema.</span><span class="sxs-lookup"><span data-stu-id="abea9-183">Figure 5-5 shows the problem.</span></span>

![Transacción en patrón saga](./media/saga-transaction-operation.png)

<span data-ttu-id="abea9-185">**Figura 5-5**.</span><span class="sxs-lookup"><span data-stu-id="abea9-185">**Figure 5-5**.</span></span> <span data-ttu-id="abea9-186">Implementación de una transacción en microservicios</span><span class="sxs-lookup"><span data-stu-id="abea9-186">Implementing a transaction across microservices</span></span>

<span data-ttu-id="abea9-187">En la figura anterior, cinco microservicios independientes participan en una transacción distribuida que crea un pedido.</span><span class="sxs-lookup"><span data-stu-id="abea9-187">In the preceding figure, five independent microservices participate in a distributed transaction that creates an order.</span></span> <span data-ttu-id="abea9-188">Cada microservicio mantiene su propio almacén de datos e implementa una transacción local para su almacén.</span><span class="sxs-lookup"><span data-stu-id="abea9-188">Each microservice maintains its own data store and implements a local transaction for its store.</span></span> <span data-ttu-id="abea9-189">Para crear el pedido, la transacción local para *cada* microservicio individual debe realizarse correctamente o *todos* deben anular y revertir la operación.</span><span class="sxs-lookup"><span data-stu-id="abea9-189">To create the order, the local transaction for *each* individual microservice must succeed, or *all* must abort and roll back the operation.</span></span> <span data-ttu-id="abea9-190">Aunque la compatibilidad transaccional integrada está disponible dentro de cada uno de los microservicios, no hay compatibilidad para una transacción distribuida que abarcaría los cinco servicios para mantener la coherencia de los datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-190">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction that would span across all five services to keep data consistent.</span></span>

<span data-ttu-id="abea9-191">En su lugar, debe construir esta transacción distribuida *mediante programación.*</span><span class="sxs-lookup"><span data-stu-id="abea9-191">Instead, you must construct this distributed transaction *programmatically*.</span></span>

<span data-ttu-id="abea9-192">Un patrón popular para agregar soporte transaccional distribuido es el patrón Saga.</span><span class="sxs-lookup"><span data-stu-id="abea9-192">A popular pattern for adding distributed transactional support is the Saga pattern.</span></span> <span data-ttu-id="abea9-193">Se implementa agrupando las transacciones locales mediante programación y secuencialmente invocando cada una de ellas.</span><span class="sxs-lookup"><span data-stu-id="abea9-193">It's implemented by grouping local transactions together programmatically and sequentially invoking each one.</span></span> <span data-ttu-id="abea9-194">Si se produce un error en alguna de las transacciones locales, Saga anula la operación e invoca un conjunto de transacciones de [compensación.](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction)</span><span class="sxs-lookup"><span data-stu-id="abea9-194">If any of the local transactions fail, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction).</span></span> <span data-ttu-id="abea9-195">Las transacciones de compensación deshacen los cambios realizados por las transacciones locales anteriores y restauran la coherencia de los datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-195">The compensating transactions undo the changes made by the preceding local transactions and restore data consistency.</span></span> <span data-ttu-id="abea9-196">La figura 5-6 muestra una transacción con errores con el patrón Saga.</span><span class="sxs-lookup"><span data-stu-id="abea9-196">Figure 5-6 shows a failed transaction with the Saga pattern.</span></span>

![Retrocede en el patrón saga](./media/saga-rollback-operation.png)

<span data-ttu-id="abea9-198">**Figura 5-6**.</span><span class="sxs-lookup"><span data-stu-id="abea9-198">**Figure 5-6**.</span></span> <span data-ttu-id="abea9-199">Revertir una transacción</span><span class="sxs-lookup"><span data-stu-id="abea9-199">Rolling back a transaction</span></span>

<span data-ttu-id="abea9-200">En la figura anterior, la operación *Actualizar inventario* ha fallado en el microservicio Inventario.</span><span class="sxs-lookup"><span data-stu-id="abea9-200">In the previous figure, the *Update Inventory* operation has failed in the Inventory microservice.</span></span> <span data-ttu-id="abea9-201">La Saga invoca un conjunto de transacciones de compensación (en rojo) para ajustar los recuentos de inventario, cancelar el pago y el pedido y devolver los datos de cada microservicio a un estado coherente.</span><span class="sxs-lookup"><span data-stu-id="abea9-201">The Saga invokes a set of compensating transactions (in red) to adjust the inventory counts, cancel the payment and the order, and return the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="abea9-202">Los patrones de Saga suelen coreografiarse como una serie de eventos relacionados, o orquestados como un conjunto de comandos relacionados.</span><span class="sxs-lookup"><span data-stu-id="abea9-202">Saga patterns are typically choreographed as a series of related events, or orchestrated as a set of related commands.</span></span> <span data-ttu-id="abea9-203">En el capítulo 4, discutimos el patrón de agregador de servicio que sería la base para una implementación orquestada de la saga.</span><span class="sxs-lookup"><span data-stu-id="abea9-203">In Chapter 4, we discussed the service aggregator pattern that would be the foundation for an orchestrated saga implementation.</span></span> <span data-ttu-id="abea9-204">También discutimos los eventos junto con los temas de Azure Service Bus y Azure Event Grid que serían una base para una implementación de saga coreografiada.</span><span class="sxs-lookup"><span data-stu-id="abea9-204">We also discussed eventing along with Azure Service Bus and Azure Event Grid topics that would be a foundation for a choreographed saga implementation.</span></span>

## <a name="high-volume-data"></a><span data-ttu-id="abea9-205">Datos de alto volumen</span><span class="sxs-lookup"><span data-stu-id="abea9-205">High volume data</span></span>

<span data-ttu-id="abea9-206">Las aplicaciones nativas de la nube grandes a menudo admiten requisitos de datos de gran volumen.</span><span class="sxs-lookup"><span data-stu-id="abea9-206">Large cloud-native applications often support high-volume data requirements.</span></span> <span data-ttu-id="abea9-207">En estos escenarios, las técnicas tradicionales de almacenamiento de datos pueden causar cuellos de botella.</span><span class="sxs-lookup"><span data-stu-id="abea9-207">In these scenarios, traditional data storage techniques can cause bottlenecks.</span></span> <span data-ttu-id="abea9-208">Para los sistemas complejos que se implementan a gran escala, la segregación de responsabilidad de comandos y consultas (CQRS) y el abastecimiento de eventos pueden mejorar el rendimiento de las aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="abea9-208">For complex systems that deploy on a large scale, both Command and Query Responsibility Segregation (CQRS) and Event Sourcing may improve application performance.</span></span>  

### <a name="cqrs"></a><span data-ttu-id="abea9-209">CQRS</span><span class="sxs-lookup"><span data-stu-id="abea9-209">CQRS</span></span>

<span data-ttu-id="abea9-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), es un patrón arquitectónico que puede ayudar a maximizar el rendimiento, la escalabilidad y la seguridad.</span><span class="sxs-lookup"><span data-stu-id="abea9-210">[CQRS](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that can help maximize performance, scalability, and security.</span></span> <span data-ttu-id="abea9-211">El patrón separa las operaciones que leen datos de las operaciones que escriben datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-211">The pattern separates operations that read data from those operations that write data.</span></span>

<span data-ttu-id="abea9-212">Para escenarios normales, el mismo modelo de entidad y el mismo objeto de repositorio de datos se utilizan *para* las operaciones de lectura y escritura.</span><span class="sxs-lookup"><span data-stu-id="abea9-212">For normal scenarios, the same entity model and data repository object are used for *both* read and write operations.</span></span>

<span data-ttu-id="abea9-213">Sin embargo, un escenario de datos de gran volumen puede beneficiarse de modelos y tablas de datos independientes para lecturas y escrituras.</span><span class="sxs-lookup"><span data-stu-id="abea9-213">However, a high volume data scenario can benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="abea9-214">Para mejorar el rendimiento, la operación de lectura podría consultar una representación altamente desnormalizada de los datos para evitar combinaciones de tablas repetitivas costosas y bloqueos de tabla.</span><span class="sxs-lookup"><span data-stu-id="abea9-214">To improve performance, the read operation could query against a highly denormalized representation of the data to avoid expensive repetitive table joins and table locks.</span></span> <span data-ttu-id="abea9-215">La operación de *escritura,* conocida como *comando*, se actualizaría con una representación totalmente normalizada de los datos que garantizaría la coherencia.</span><span class="sxs-lookup"><span data-stu-id="abea9-215">The *write* operation, known as a *command*, would update against a fully normalized representation of the data that would guarantee consistency.</span></span> <span data-ttu-id="abea9-216">A continuación, debe implementar un mecanismo para mantener ambas representaciones sincronizadas. Normalmente, cada vez que se modifica la tabla de escritura, publica un evento que replica la modificación en la tabla de lectura.</span><span class="sxs-lookup"><span data-stu-id="abea9-216">You then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it publishes an event that replicates the modification to the read table.</span></span>

<span data-ttu-id="abea9-217">La Figura 5-7 muestra una implementación del patrón CQRS.</span><span class="sxs-lookup"><span data-stu-id="abea9-217">Figure 5-7 shows an implementation of the CQRS pattern.</span></span>

![Segregación de responsabilidad de comandos y consultas](./media/cqrs-implementation.png)

<span data-ttu-id="abea9-219">**Figura 5-7**.</span><span class="sxs-lookup"><span data-stu-id="abea9-219">**Figure 5-7**.</span></span> <span data-ttu-id="abea9-220">Implementación de CQRS</span><span class="sxs-lookup"><span data-stu-id="abea9-220">CQRS implementation</span></span>

<span data-ttu-id="abea9-221">En la figura anterior, se implementan modelos de comando y consulta independientes.</span><span class="sxs-lookup"><span data-stu-id="abea9-221">In the previous figure, separate command and query models are implemented.</span></span> <span data-ttu-id="abea9-222">Cada operación de escritura de datos se guarda en el almacén de escritura y, a continuación, se propaga al almacén de lectura.</span><span class="sxs-lookup"><span data-stu-id="abea9-222">Each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="abea9-223">Preste mucha atención a cómo funciona el proceso de propagación de datos sobre el principio de [coherencia final.](http://www.cloudcomputingpatterns.org/eventual_consistency/)</span><span class="sxs-lookup"><span data-stu-id="abea9-223">Pay close attention to how the data propagation process operates on the principle of [eventual consistency](http://www.cloudcomputingpatterns.org/eventual_consistency/).</span></span> <span data-ttu-id="abea9-224">El modelo de lectura finalmente se sincroniza con el modelo de escritura, pero puede haber algún retraso en el proceso.</span><span class="sxs-lookup"><span data-stu-id="abea9-224">The read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span> <span data-ttu-id="abea9-225">Discutimos la consistencia final en la siguiente sección.</span><span class="sxs-lookup"><span data-stu-id="abea9-225">We discuss eventual consistency in the next section.</span></span>

<span data-ttu-id="abea9-226">Esta separación permite que las lecturas y escrituras se escalen de forma independiente.</span><span class="sxs-lookup"><span data-stu-id="abea9-226">This separation enables reads and writes to scale independently.</span></span> <span data-ttu-id="abea9-227">Las operaciones de lectura usan un esquema optimizado para las consultas, mientras que las escrituras usan un esquema optimizado para las actualizaciones.</span><span class="sxs-lookup"><span data-stu-id="abea9-227">Read operations use a schema optimized for queries, while the writes use a schema optimized for updates.</span></span> <span data-ttu-id="abea9-228">Las consultas de lectura van con datos desnormalizados, mientras que la lógica empresarial compleja se puede aplicar al modelo de escritura.</span><span class="sxs-lookup"><span data-stu-id="abea9-228">Read queries go against denormalized data, while complex business logic can be applied to the write model.</span></span> <span data-ttu-id="abea9-229">Además, podría imponer una seguridad más estricta en las operaciones de escritura que las que exponen las lecturas.</span><span class="sxs-lookup"><span data-stu-id="abea9-229">As well, you might impose tighter security on write operations than those exposing reads.</span></span>

<span data-ttu-id="abea9-230">La implementación de CQRS puede mejorar el rendimiento de las aplicaciones para servicios nativos de la nube.</span><span class="sxs-lookup"><span data-stu-id="abea9-230">Implementing CQRS can improve application performance for cloud-native services.</span></span> <span data-ttu-id="abea9-231">Sin embargo, resulta en un diseño más complejo.</span><span class="sxs-lookup"><span data-stu-id="abea9-231">However, it does result in a more complex design.</span></span> <span data-ttu-id="abea9-232">Aplique este principio cuidadosamente y estratégicamente a las secciones de su aplicación nativa de la nube que se beneficiarán de él.</span><span class="sxs-lookup"><span data-stu-id="abea9-232">Apply this principle carefully and strategically to those sections of your cloud-native application that will benefit from it.</span></span> <span data-ttu-id="abea9-233">Para obtener más información sobre CQRS, consulte el libro de Microsoft [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span><span class="sxs-lookup"><span data-stu-id="abea9-233">For more on CQRS, see the Microsoft book [.NET Microservices: Architecture for Containerized .NET Applications](https://docs.microsoft.com/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/apply-simplified-microservice-cqrs-ddd-patterns).</span></span>

### <a name="event-sourcing"></a><span data-ttu-id="abea9-234">Abastecimiento de eventos</span><span class="sxs-lookup"><span data-stu-id="abea9-234">Event sourcing</span></span>

<span data-ttu-id="abea9-235">Otro enfoque para optimizar escenarios de datos de gran volumen implica [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span><span class="sxs-lookup"><span data-stu-id="abea9-235">Another approach to optimizing high volume data scenarios involves [Event Sourcing](https://docs.microsoft.com/azure/architecture/patterns/event-sourcing).</span></span>

<span data-ttu-id="abea9-236">Normalmente, un sistema almacena el estado actual de una entidad de datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-236">A system typically stores the current state of a data entity.</span></span> <span data-ttu-id="abea9-237">Si un usuario cambia su número de teléfono, por ejemplo, el registro de cliente se actualiza con el nuevo número.</span><span class="sxs-lookup"><span data-stu-id="abea9-237">If a user changes their phone number, for example, the customer record is updated with the new number.</span></span> <span data-ttu-id="abea9-238">Siempre sabemos el estado actual de una entidad de datos, pero cada actualización sobrescribe el estado anterior.</span><span class="sxs-lookup"><span data-stu-id="abea9-238">We always know the current state of a data entity, but each update overwrites the previous state.</span></span>

<span data-ttu-id="abea9-239">En la mayoría de los casos, este modelo funciona bien.</span><span class="sxs-lookup"><span data-stu-id="abea9-239">In most cases, this model works fine.</span></span> <span data-ttu-id="abea9-240">Sin embargo, en sistemas de gran volumen, la sobrecarga del bloqueo transaccional y las operaciones de actualización frecuentes puede afectar al rendimiento, la capacidad de respuesta y limitar la escalabilidad de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-240">In high volume systems, however, overhead from transactional locking and frequent update operations can impact database performance, responsiveness, and limit scalability.</span></span>

<span data-ttu-id="abea9-241">Event Sourcing adopta un enfoque diferente para capturar datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-241">Event Sourcing takes a different approach to capturing data.</span></span> <span data-ttu-id="abea9-242">Cada operación que afecta a los datos se conserva en un almacén de eventos.</span><span class="sxs-lookup"><span data-stu-id="abea9-242">Each operation that affects data is persisted to an event store.</span></span> <span data-ttu-id="abea9-243">En lugar de actualizar el estado de un registro de datos, anexamos cada cambio a una lista secuencial de eventos pasados, similar al libro mayor de un contable.</span><span class="sxs-lookup"><span data-stu-id="abea9-243">Instead of updating the state of a data record, we append each change to a sequential list of past events - similar to an accountant's ledger.</span></span> <span data-ttu-id="abea9-244">El almacén de eventos se convierte en el sistema de registro de los datos.</span><span class="sxs-lookup"><span data-stu-id="abea9-244">The Event Store becomes the system of record for the data.</span></span> <span data-ttu-id="abea9-245">Se utiliza para propagar varias vistas materializadas dentro del contexto delimitado de un microservicio.</span><span class="sxs-lookup"><span data-stu-id="abea9-245">It's used to propagate various materialized views within the bounded context of a microservice.</span></span> <span data-ttu-id="abea9-246">La Figura 5.8 muestra el patrón.</span><span class="sxs-lookup"><span data-stu-id="abea9-246">Figure 5.8 shows the pattern.</span></span>

![Aprovisionamiento de eventos](./media/event-sourcing.png)

<span data-ttu-id="abea9-248">**Figura 5-8**.</span><span class="sxs-lookup"><span data-stu-id="abea9-248">**Figure 5-8**.</span></span> <span data-ttu-id="abea9-249">Aprovisionamiento de eventos</span><span class="sxs-lookup"><span data-stu-id="abea9-249">Event Sourcing</span></span>

<span data-ttu-id="abea9-250">En la figura anterior, observe cómo cada entrada (en azul) para el carro de la compra de un usuario se anexa a un almacén de eventos subyacente.</span><span class="sxs-lookup"><span data-stu-id="abea9-250">In the previous figure, note how each entry (in blue) for a user's shopping cart is appended to an underlying event store.</span></span> <span data-ttu-id="abea9-251">En la vista materializada contigua, el sistema proyecta el estado actual reproduciendo todos los eventos asociados a cada carro de la compra.</span><span class="sxs-lookup"><span data-stu-id="abea9-251">In the adjoining materialized view, the system projects the current state by replaying all the events associated with each shopping cart.</span></span> <span data-ttu-id="abea9-252">Esta vista, o modelo de lectura, se expone de nuevo a la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="abea9-252">This view, or read model, is then exposed back to the UI.</span></span> <span data-ttu-id="abea9-253">Los eventos también se pueden integrar con sistemas y aplicaciones externos o consultarse para determinar el estado actual de una entidad.</span><span class="sxs-lookup"><span data-stu-id="abea9-253">Events can also be integrated with external systems and applications or queried to determine the current state of an entity.</span></span> <span data-ttu-id="abea9-254">Con este enfoque, usted mantiene la historia.</span><span class="sxs-lookup"><span data-stu-id="abea9-254">With this approach, you maintain history.</span></span> <span data-ttu-id="abea9-255">No solo conoce el estado actual de una entidad, sino también cómo llegó a este estado.</span><span class="sxs-lookup"><span data-stu-id="abea9-255">You know not only the current state of an entity, but also how you reached this state.</span></span>

<span data-ttu-id="abea9-256">Mecánicamente hablando, el abastecimiento de eventos simplifica el modelo de escritura.</span><span class="sxs-lookup"><span data-stu-id="abea9-256">Mechanically speaking, event sourcing simplifies the write model.</span></span> <span data-ttu-id="abea9-257">No hay actualizaciones ni eliminaciones.</span><span class="sxs-lookup"><span data-stu-id="abea9-257">There are no updates or deletes.</span></span> <span data-ttu-id="abea9-258">Anexar cada entrada de datos como un evento inmutable minimiza los conflictos de contención, bloqueo y simultaneidad asociados con las bases de datos relacionales.</span><span class="sxs-lookup"><span data-stu-id="abea9-258">Appending each data entry as an immutable event minimizes contention, locking, and concurrency conflicts associated with relational databases.</span></span> <span data-ttu-id="abea9-259">La creación de modelos de lectura con el patrón de vista materializado le permite desacoplar la vista del modelo de escritura y elegir el mejor almacén de datos para optimizar las necesidades de la interfaz de usuario de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="abea9-259">Building read models with the materialized view pattern enables you to decouple the view from the write model and choose the best data store to optimize the needs of your application UI.</span></span>

<span data-ttu-id="abea9-260">Para este patrón, considere la posibilidad de un almacén de datos que admita directamente el abastecimiento de eventos.</span><span class="sxs-lookup"><span data-stu-id="abea9-260">For this pattern, consider a data store that directly supports event sourcing.</span></span> <span data-ttu-id="abea9-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB y RavenDB son buenos candidatos.</span><span class="sxs-lookup"><span data-stu-id="abea9-261">Azure Cosmos DB, MongoDB, Cassandra, CouchDB, and RavenDB are good candidates.</span></span>

<span data-ttu-id="abea9-262">Al igual que con todos los patrones y tecnologías, implementar estratégicamente y cuando sea necesario.</span><span class="sxs-lookup"><span data-stu-id="abea9-262">As with all patterns and technologies, implement strategically and when needed.</span></span> <span data-ttu-id="abea9-263">Si bien el abastecimiento de eventos puede proporcionar un mayor rendimiento y escalabilidad, se produce a expensas de la complejidad y una curva de aprendizaje.</span><span class="sxs-lookup"><span data-stu-id="abea9-263">While event sourcing can provide increased performance and scalability, it comes at the expense of complexity and a learning curve.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="abea9-264">[Anterior](service-mesh-communication-infrastructure.md)
>[Siguiente](relational-vs-nosql-data.md)</span><span class="sxs-lookup"><span data-stu-id="abea9-264">[Previous](service-mesh-communication-infrastructure.md)
[Next](relational-vs-nosql-data.md)</span></span>
