---
title: Marcar eventos enrutados como controlados y control de clases
ms.date: 03/30/2017
helpviewer_keywords:
- tunneling events [WPF]
- class listeners [WPF]
- listeners [WPF]
- Preview routed events [WPF]
- instance listeners [WPF]
- events [WPF], bubbling
- suppressing events [WPF]
- routed events [WPF], Preview
- composited controls [WPF]
- events [WPF], tunneling
- routed events [WPF], marking as handled
- controls [WPF], compositing
- events [WPF], suppressing
- bubbling events [WPF]
ms.assetid: 5e745508-4861-4b48-b5f6-5fc7ce5289d2
ms.openlocfilehash: 55ed91a848ce69fa6ce3e69a654a56d7875912b5
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/14/2020
ms.locfileid: "79401044"
---
# <a name="marking-routed-events-as-handled-and-class-handling"></a><span data-ttu-id="0f8fd-102">Marcar eventos enrutados como controlados y control de clases</span><span class="sxs-lookup"><span data-stu-id="0f8fd-102">Marking Routed Events as Handled, and Class Handling</span></span>
<span data-ttu-id="0f8fd-103">Los controladores de un evento enrutado pueden marcar el evento como controlado en los datos del evento.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-103">Handlers for a routed event can mark the event handled within the event data.</span></span> <span data-ttu-id="0f8fd-104">Controlar el evento acorta de forma efectiva la ruta.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-104">Handling the event will effectively shorten the route.</span></span> <span data-ttu-id="0f8fd-105">El control de clases es un concepto de programación que admiten los eventos enrutados.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-105">Class handling is a programming concept that is supported by routed events.</span></span> <span data-ttu-id="0f8fd-106">Un controlador de clases tiene la oportunidad de controlar un evento enrutado determinado en un nivel de clase con un controlador que se invoca antes que cualquier controlador de instancias de cualquier instancia de la clase.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-106">A class handler has the opportunity to handle a particular routed event at a class level with a handler that is invoked before any instance handler on any instance of the class.</span></span>  

<a name="prerequisites"></a>
## <a name="prerequisites"></a><span data-ttu-id="0f8fd-107">Requisitos previos</span><span class="sxs-lookup"><span data-stu-id="0f8fd-107">Prerequisites</span></span>  
 <span data-ttu-id="0f8fd-108">En este tema se profundiza sobre los conceptos presentados en [Información general sobre eventos enrutados](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="0f8fd-108">This topic elaborates on concepts introduced in the [Routed Events Overview](routed-events-overview.md).</span></span>  
  
<a name="When_to_Mark_Events_as_Handled"></a>
## <a name="when-to-mark-events-as-handled"></a><span data-ttu-id="0f8fd-109">Cuándo se deben marcar los eventos como controlados</span><span class="sxs-lookup"><span data-stu-id="0f8fd-109">When to Mark Events as Handled</span></span>  
 <span data-ttu-id="0f8fd-110">Cuando se establece el <xref:System.Windows.RoutedEventArgs.Handled%2A> valor `true` de la propiedad en los datos de evento para un evento enrutado, esto se conoce como "marcar el evento controlado".</span><span class="sxs-lookup"><span data-stu-id="0f8fd-110">When you set the value of the <xref:System.Windows.RoutedEventArgs.Handled%2A> property to `true` in the event data for a routed event, this is referred to as "marking the event handled".</span></span> <span data-ttu-id="0f8fd-111">No hay ninguna regla absoluta sobre cuándo se deben marcar los eventos enrutados como controlados como autor de una aplicación o como autor de control que responde a eventos enrutados existentes o implementa nuevos eventos enrutados.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-111">There is no absolute rule for when you should mark routed events as handled, either as an application author, or as a control author who responds to existing routed events or implements new routed events.</span></span> <span data-ttu-id="0f8fd-112">En su mayor parte, el concepto de "controlado" tal como se lleva en los datos de eventos del evento enrutado [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] debe utilizarse como un protocolo limitado para las respuestas de su propia aplicación a los diversos eventos enrutados expuestos en las API, así como para cualquier evento enrutado personalizado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-112">For the most part, the concept of "handled" as carried in the routed event's event data should be used as a limited protocol for your own application's responses to the various routed events exposed in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] APIs as well as for any custom routed events.</span></span> <span data-ttu-id="0f8fd-113">Otra forma de considerar la cuestión del "control" es que, generalmente, debería marcar un evento enrutado como controlado si el código respondió al evento enrutado de manera significativa y relativamente completa.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-113">Another way to consider the "handled" issue is that you should generally mark a routed event handled if your code responded to the routed event in a significant and relatively complete way.</span></span> <span data-ttu-id="0f8fd-114">Normalmente, no debería haber más de una respuesta significativa que requiera implementaciones del controlador independientes para cualquier instancia de evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-114">Typically, there should not be more than one significant response that requires separate handler implementations for any single routed event occurrence.</span></span> <span data-ttu-id="0f8fd-115">Si se necesitan más respuestas, se debe implementar el código necesario a través de la lógica de la aplicación encadenada con un único controlador, en lugar de usar el sistema de eventos enrutados para el reenvío.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-115">If more responses are needed, then the necessary code should be implemented through application logic that is chained within a single handler rather than by using the routed event system for forwarding.</span></span> <span data-ttu-id="0f8fd-116">El concepto de "significativo" también es subjetivo y depende de la aplicación o el código.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-116">The concept of what is "significant" is also subjective, and depends on your application or code.</span></span> <span data-ttu-id="0f8fd-117">Como guía general, estos son algunos ejemplos de "respuesta significativa": establecer el foco, modificar el estado público, establecer propiedades que afectan a la representación visual y generar otros eventos nuevos.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-117">As general guidance, some "significant response" examples include: setting focus, modifying public state, setting properties that affect the visual representation, and raising other new events.</span></span> <span data-ttu-id="0f8fd-118">Ejemplos de respuestas no significativas: modificar el estado privado (sin impacto visual ni representación de programación), registrar eventos o examinar los argumentos de un evento y decidir no responder a él.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-118">Examples of nonsignificant responses include: modifying private state (with no visual impact, or programmatic representation), logging of events, or looking at arguments of an event and choosing not to respond to it.</span></span>  
  
 <span data-ttu-id="0f8fd-119">El comportamiento del sistema de eventos enrutados refuerza este modelo de "respuesta [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] significativa" para <xref:System.Windows.UIElement.AddHandler%2A> usar el estado controlado de un evento enrutado, porque los controladores agregados o la firma común de no se invocan en respuesta a un evento enrutado donde los datos de evento ya están marcados como controlados.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-119">The routed event system behavior reinforces this "significant response" model for using handled state of a routed event, because handlers added in [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] or the common signature of <xref:System.Windows.UIElement.AddHandler%2A> are not invoked in response to a routed event where the event data is already marked handled.</span></span> <span data-ttu-id="0f8fd-120">Debe realizar el esfuerzo adicional de agregar `handledEventsToo` un<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>controlador con la versión del parámetro ( ) para controlar los eventos enrutados marcados como controlados por participantes anteriores en la ruta del evento.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-120">You must go through the extra effort of adding a handler with the `handledEventsToo` parameter version (<xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>) in order to handle routed events that are marked handled by earlier participants in the event route.</span></span>  
  
 <span data-ttu-id="0f8fd-121">En algunas circunstancias, los propios controles marcan ciertos eventos enrutados como controlados.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-121">In some circumstances, controls themselves mark certain routed events as handled.</span></span> <span data-ttu-id="0f8fd-122">Un evento enrutado controlado representa una decisión de los autores de control de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] por la que las acciones del control de respuesta al evento enrutado son significativas o completas como parte de la implementación del control, y el evento no necesita ningún otro control.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-122">A handled routed event represents a decision by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] control authors that the control's actions in response to the routed event are significant or complete as part of the control implementation, and the event needs no further handling.</span></span> <span data-ttu-id="0f8fd-123">Normalmente, para hacerlo, se agrega un controlador de clase para un evento o se reemplaza uno de los elementos virtuales de controlador de clase que existen en una clase base.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-123">Usually this is done by adding a class handler for an event, or by overriding one of the class handler virtuals that exist on a base class.</span></span> <span data-ttu-id="0f8fd-124">Si es necesario, puede resolver el control de eventos. Consulte [Solución de la supresión de eventos mediante controles](#WorkingAroundEventSuppressionByControls) más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-124">You can still work around this event handling if necessary; see [Working Around Event Suppression by Controls](#WorkingAroundEventSuppressionByControls) later in this topic.</span></span>  
  
<a name="Preview_Events_vs__Bubbling_Events_and_Handling"></a>
## <a name="preview-tunneling-events-vs-bubbling-events-and-event-handling"></a><span data-ttu-id="0f8fd-125">Eventos de "vista previa" (túnel) frente a eventos de propagación y manejo de eventos</span><span class="sxs-lookup"><span data-stu-id="0f8fd-125">"Preview" (Tunneling) Events vs. Bubbling Events, and Event Handling</span></span>  
 <span data-ttu-id="0f8fd-126">Los eventos enrutados de vista previa son eventos que siguen una ruta de tunelización a través del árbol de elementos.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-126">Preview routed events are events that follow a tunneling route through the element tree.</span></span> <span data-ttu-id="0f8fd-127">"Preview", expresado en la convención de nomenclatura, indica el principio general para los eventos de entrada que establece que los eventos enrutados de vista previa (tunelización) se generan antes que el evento enrutado de propagación equivalente.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-127">The "Preview" expressed in the naming convention is indicative of the general principle for input events that preview (tunneling) routed events are raised prior to the equivalent bubbling routed event.</span></span> <span data-ttu-id="0f8fd-128">Además, los eventos enrutados de entrada que tienen un par de tunelización y propagación tienen una lógica de control distinta.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-128">Also, input routed events that have a tunneling and bubbling pair have a distinct handling logic.</span></span> <span data-ttu-id="0f8fd-129">Si un agente de escucha de eventos marca el evento enrutado de tunelización/vista previa, el evento enrutado de propagación se marcará como controlado incluso antes de que cualquier agente de escucha de evento enrutado de propagación lo reciba.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-129">If the tunneling/preview routed event is marked as handled by an event listener, then the bubbling routed event will be marked handled even before any listeners of the bubbling routed event receive it.</span></span> <span data-ttu-id="0f8fd-130">Los eventos enrutados de tunelización y propagación son, técnicamente, eventos independientes, pero comparten deliberadamente la misma instancia de datos de evento para habilitar este comportamiento.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-130">The tunneling and bubbling routed events are technically separate events, but they deliberately share the same instance of event data to enable this behavior.</span></span>  
  
 <span data-ttu-id="0f8fd-131">La conexión entre los eventos enrutados de tunelización y propagación se realiza mediante la implementación interna de cómo cualquier clase de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] determinada genera sus propios eventos enrutados declarados, y este es el caso de los eventos enrutados de entrada emparejados.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-131">The connection between the tunneling and bubbling routed events is accomplished by the internal implementation of how any given [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] class raises its own declared routed events, and this is true of the paired input routed events.</span></span> <span data-ttu-id="0f8fd-132">Sin embargo, a menos que exista esta implementación de nivel de clase, no hay ninguna conexión entre un evento enrutado de tunelización y uno de propagación que comparten el esquema de nomenclatura: sin tal implementación, serían dos eventos enrutados completamente independientes y no se generarían en secuencia ni compartirían datos de evento.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-132">But unless this class-level implementation exists, there is no connection between a tunneling routed event and a bubbling routed event that share the naming scheme: without such implementation they would be two entirely separate routed events and would not be raised in sequence or share event data.</span></span>  
  
 <span data-ttu-id="0f8fd-133">Para obtener más información sobre cómo implementar pares de eventos enrutados de entrada de tunelización y propagación en una clase personalizada, consulte [Cómo: Crear un evento enrutado personalizado](how-to-create-a-custom-routed-event.md).</span><span class="sxs-lookup"><span data-stu-id="0f8fd-133">For more information about how to implement tunnel/bubble input routed event pairs in a custom class, see [Create a Custom Routed Event](how-to-create-a-custom-routed-event.md).</span></span>  
  
<a name="Class_Handlers_and_Instance_Handlers"></a>
## <a name="class-handlers-and-instance-handlers"></a><span data-ttu-id="0f8fd-134">Controladores de clases y controladores de instancias</span><span class="sxs-lookup"><span data-stu-id="0f8fd-134">Class Handlers and Instance Handlers</span></span>  
 <span data-ttu-id="0f8fd-135">Los eventos enrutados consideran dos tipos distintos de agentes de escucha para el evento: de clase y de instancia.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-135">Routed events consider two different types of listeners to the event: class listeners and instance listeners.</span></span> <span data-ttu-id="0f8fd-136">Los agentes de escucha de <xref:System.Windows.EventManager> clase<xref:System.Windows.EventManager.RegisterClassHandler%2A>existen porque los tipos han llamado a una API determinada , , en su constructor estático, o han invalidado un método virtual de controlador de clase de una clase base de elemento.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-136">Class listeners exist because types have called a particular <xref:System.Windows.EventManager> API ,<xref:System.Windows.EventManager.RegisterClassHandler%2A>, in their static constructor, or have overridden a class handler virtual method from an element base class.</span></span> <span data-ttu-id="0f8fd-137">Los agentes de escucha de instancia son instancias/elementos de clase concretos <xref:System.Windows.UIElement.AddHandler%2A>en los que se han adjuntado uno o varios controladores para ese evento enrutado mediante una llamada a .</span><span class="sxs-lookup"><span data-stu-id="0f8fd-137">Instance listeners are particular class instances/elements where one or more handlers have been attached for that routed event by a call to <xref:System.Windows.UIElement.AddHandler%2A>.</span></span> <span data-ttu-id="0f8fd-138">Los [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] eventos enrutados existentes realizan <xref:System.Windows.UIElement.AddHandler%2A> llamadas como parte{} del{} contenedor de eventos de Common Language [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] Runtime (CLR) agregar y quitar implementaciones del evento, que es también cómo se habilita el mecanismo simple de adjuntar controladores de eventos a través de una sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-138">Existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] routed events make calls to <xref:System.Windows.UIElement.AddHandler%2A> as part of the common language runtime (CLR) event wrapper add{} and remove{} implementations of the event, which is also how the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] mechanism of attaching event handlers via an attribute syntax is enabled.</span></span> <span data-ttu-id="0f8fd-139">Por lo [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] tanto, incluso el uso <xref:System.Windows.UIElement.AddHandler%2A> simple en última instancia equivale a una llamada.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-139">Therefore even the simple [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] usage ultimately equates to an <xref:System.Windows.UIElement.AddHandler%2A> call.</span></span>  
  
 <span data-ttu-id="0f8fd-140">Se comprueban las implementaciones de controlador registradas de los elementos del árbol visual.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-140">Elements within the visual tree are checked for registered handler implementations.</span></span> <span data-ttu-id="0f8fd-141">Los controladores se pueden invocar a lo largo de la ruta en el orden inherente al tipo de la estrategia de enrutamiento para el evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-141">Handlers are potentially invoked throughout the route, in the order that is inherent in the type of the routing strategy for that routed event.</span></span> <span data-ttu-id="0f8fd-142">Por ejemplo, los eventos enrutados de propagación invocan primero los controladores adjuntos al mismo elemento que generó el evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-142">For instance, bubbling routed events will first invoke those handlers that are attached to the same element that raised the routed event.</span></span> <span data-ttu-id="0f8fd-143">A continuación, el evento enrutado "se propaga" en el siguiente elemento primario y así sucesivamente hasta que se alcanza el elemento raíz de aplicación.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-143">Then the routed event "bubbles" to the next parent element and so on until the application root element is reached.</span></span>  
  
 <span data-ttu-id="0f8fd-144">Desde la perspectiva del elemento raíz en una ruta de propagación, si el control de clases o cualquier elemento más cercano al origen del evento enrutado invoca controladores que marcan los argumentos de evento como controlados, no se invocan controladores en los elementos raíz y la ruta del evento se acorta eficazmente antes de llegar al elemento raíz.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-144">From the perspective of the root element in a bubbling route, if class handling or any element closer to the source of the routed event invoke handlers that mark the event arguments as being handled, then handlers on the root elements are not invoked, and the event route is effectively shortened before reaching that root element.</span></span> <span data-ttu-id="0f8fd-145">Sin embargo, la ruta no se detiene por completo, ya que se pueden agregar controladores mediante la condición especial de que se deben invocar igualmente, incluso si un controlador de clase o de instancia ha marcado el evento enrutado como controlado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-145">However, the route is not completely halted, because handlers can be added using a special conditional that they should still be invoked, even if a class handler or instance handler has marked the routed event as handled.</span></span> <span data-ttu-id="0f8fd-146">Esto se explica en [Adición de controladores de instancias que se generan incluso cuando los eventos se marcan como controlados](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-146">This is explained in [Adding Instance Handlers That Are Raised Even When Events Are Marked Handled](#AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled), later in this topic.</span></span>  
  
 <span data-ttu-id="0f8fd-147">En un nivel más profundo que la ruta del evento, también puede haber varios controladores de clases que actúen en cualquier instancia de una clase.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-147">At a deeper level than the event route, there are also potentially multiple class handlers acting on any given instance of a class.</span></span> <span data-ttu-id="0f8fd-148">Esto se debe a que el modelo de control de clase para los eventos enrutados permite que todas las clases posibles de una jerarquía de clases registren su propio controlador de clase para cada evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-148">This is because the class handling model for routed events enables all possible classes in a class hierarchy to each register its own class handler for each routed event.</span></span> <span data-ttu-id="0f8fd-149">Cada controlador de clase se agrega a un almacén interno y, cuando se construye la ruta de eventos para una aplicación, todos los controladores de clase se agregan a la ruta del evento.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-149">Each class handler is added to an internal store, and when the event route for an application is constructed, the class handlers are all added to the event route.</span></span> <span data-ttu-id="0f8fd-150">Los controladores de clase se agregan a la ruta de modo que el controlador de la clase más derivada se invoca primero y los controladores de clase de cada clase base sucesiva se invocan después.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-150">Class handlers are added to the route such that the most-derived class handler is invoked first, and class handlers from each successive base class are invoked next.</span></span> <span data-ttu-id="0f8fd-151">Por lo general, los controladores de clase no están registrados por lo que también responden a eventos enrutados que ya se marcaron como controlados.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-151">Generally, class handlers are not registered such that they also respond to routed events that were already marked handled.</span></span> <span data-ttu-id="0f8fd-152">Por consiguiente, este mecanismo de control de clases habilita una de dos opciones:</span><span class="sxs-lookup"><span data-stu-id="0f8fd-152">Therefore, this class handling mechanism enables one of two choices:</span></span>  
  
- <span data-ttu-id="0f8fd-153">Las clases derivadas pueden complementar el control de clases que se hereda de la clase base agregando un controlador que no marca el evento enrutado como controlado, porque el controlador de la clase base se invocará después del controlador de la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-153">Derived classes can supplement the class handling that is inherited from the base class by adding a handler that does not mark the routed event handled, because the base class handler will be invoked sometime after the derived class handler.</span></span>  
  
- <span data-ttu-id="0f8fd-154">Las clases derivadas pueden reemplazar el control de clases de la clase base agregando un controlador de clase que marque el evento enrutado como controlado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-154">Derived classes can replace the class handling from the base class by adding a class handler that marks the routed event handled.</span></span> <span data-ttu-id="0f8fd-155">Debe tener cuidado con este enfoque, porque es posible que cambie el diseño del control de base deseado en áreas como el aspecto visual, la lógica de estado, el control de entrada y la gestión de comandos.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-155">You should be cautious with this approach, because it will potentially change the intended base control design in areas such as visual appearance, state logic, input handling, and command handling.</span></span>  
  
<a name="Class_Handling_of_Routed_Events"></a>
## <a name="class-handling-of-routed-events-by-control-base-classes"></a><span data-ttu-id="0f8fd-156">Control de clases de eventos enrutados mediante clases base de control</span><span class="sxs-lookup"><span data-stu-id="0f8fd-156">Class Handling of Routed Events by Control Base Classes</span></span>  
 <span data-ttu-id="0f8fd-157">En cada nodo de elemento dado de una ruta de eventos, los agentes de escucha de clase tienen la oportunidad de responder al evento enrutado antes que cualquier agente de escucha de instancia en el elemento.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-157">On each given element node in an event route, class listeners have the opportunity to respond to the routed event before any instance listener on the element can.</span></span> <span data-ttu-id="0f8fd-158">Por este motivo, los controladores de clase se usan a veces para suprimir eventos enrutados que una implementación de clase de control determinada no quiere que se propaguen más o para proporcionar un control especial de ese evento enrutado que es una característica de la clase.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-158">For this reason, class handlers are sometimes used to suppress routed events that a particular control class implementation does not wish to propagate further, or to provide special handling of that routed event that is a feature of the class.</span></span> <span data-ttu-id="0f8fd-159">Por ejemplo, una clase podría generar su propio evento específico de clase con información más específica sobre el significado de alguna condición de entrada de usuario en el contexto de esa clase en particular.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-159">For instance, a class might raise its own class-specific event that contains more specifics about what some user input condition means in the context of that particular class.</span></span> <span data-ttu-id="0f8fd-160">La implementación de la clase, a continuación, puede marcar el evento enrutado más general como controlado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-160">The class implementation might then mark the more general routed event as handled.</span></span> <span data-ttu-id="0f8fd-161">Los controladores de clase sin suelen agregarse de forma que no se invocan para eventos <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> enrutados donde los datos de eventos compartidos ya estaban marcados como controlados, pero para los casos atípicos también hay una firma que registra los controladores de clase para invocar incluso cuando los eventos enrutados se marcan como controlados.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-161">Class handlers are typically added such that they are not invoked for routed events where shared event data was already marked handled, but for atypical cases there is also a <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that registers class handlers to invoke even when routed events are marked handled.</span></span>  
  
### <a name="class-handler-virtuals"></a><span data-ttu-id="0f8fd-162">Elementos virtuales de controlador de clase</span><span class="sxs-lookup"><span data-stu-id="0f8fd-162">Class Handler Virtuals</span></span>  
 <span data-ttu-id="0f8fd-163">Algunos elementos, en particular <xref:System.Windows.UIElement>los elementos base como ,\*exponen los métodos virtuales vacíos "On\*Event" y "OnPreview Event" que corresponden a su lista de eventos enrutados públicos.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-163">Some elements, particularly the base elements such as <xref:System.Windows.UIElement>, expose empty "On\*Event" and "OnPreview\*Event" virtual methods that correspond to their list of public routed events.</span></span> <span data-ttu-id="0f8fd-164">Estos métodos virtuales se pueden invalidar para implementar un controlador de clase para el evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-164">These virtual methods can be overridden to implement a class handler for that routed event.</span></span> <span data-ttu-id="0f8fd-165">Las clases de elemento base registran estos métodos <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> virtuales como su controlador de clases para cada evento enrutado mediante como se describió anteriormente.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-165">The base element classes register these virtual methods as their class handler for each such routed event using <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> as described earlier.</span></span> <span data-ttu-id="0f8fd-166">Los métodos virtuales On\*Event facilitan la implementación del control de clases para los eventos enrutados pertinentes, sin necesidad de una inicialización especial en constructores estáticos para cada tipo.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-166">The On\*Event virtual methods make it much simpler to implement class handling for the relevant routed events, without requiring special initialization in static constructors for each type.</span></span> <span data-ttu-id="0f8fd-167">Por ejemplo, puede agregar el <xref:System.Windows.UIElement.DragEnter> control <xref:System.Windows.UIElement> de clases para <xref:System.Windows.UIElement.OnDragEnter%2A> el evento en cualquier clase derivada reemplazando el método virtual.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-167">For instance, you can add class handling for the <xref:System.Windows.UIElement.DragEnter> event in any <xref:System.Windows.UIElement> derived class by overriding the <xref:System.Windows.UIElement.OnDragEnter%2A> virtual method.</span></span> <span data-ttu-id="0f8fd-168">Dentro de la invalidación, podría controlar el evento enrutado, generar otros eventos, iniciar una lógica específica de clase que podría cambiar las propiedades de elemento en instancias, o cualquier combinación de esas acciones.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-168">Within the override, you could handle the routed event, raise other events, initiate class-specific logic that might change element properties on instances, or any combination of those actions.</span></span> <span data-ttu-id="0f8fd-169">Por lo general, debe llamar a la implementación base en dichas invalidaciones incluso si marca el evento como controlado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-169">You should generally call the base implementation in such overrides even if you mark the event handled.</span></span> <span data-ttu-id="0f8fd-170">Se recomienda llamar a la implementación base porque el método virtual se encuentra en la clase base.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-170">Calling the base implementation is strongly recommended because the virtual method is on the base class.</span></span> <span data-ttu-id="0f8fd-171">El patrón virtual protegido estándar de llamar a las implementaciones base desde cada elemento virtual, básicamente, reemplaza y es comparable a un mecanismo similar que es nativo al control de clases de eventos enrutados, mediante el cual se llama a los controladores de clase de todas las clases de una jerarquía de clases en una instancia determinada, comenzando por el controlador de la clase más derivada y continuando hasta el controlador de la clase base.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-171">The standard protected virtual pattern of calling the base implementations from each virtual essentially replaces and parallels a similar mechanism that is native to routed event class handling, whereby class handlers for all classes in a class hierarchy are called on any given instance, starting with the most-derived class' handler and continuing to the base class handler.</span></span> <span data-ttu-id="0f8fd-172">Solo se debe omitir la llamada de implementación base si la clase tiene un requisito deliberado para cambiar la lógica de control de clase base.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-172">You should only omit the base implementation call if your class has a deliberate requirement to change the base class handling logic.</span></span> <span data-ttu-id="0f8fd-173">Si se llama a la implementación base antes o después, el código de invalidación dependerá de la naturaleza de la implementación.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-173">Whether you call the base implementation before or after your overriding code will depend on the nature of your implementation.</span></span>  
  
#### <a name="input-event-class-handling"></a><span data-ttu-id="0f8fd-174">Control de clase de evento de entrada</span><span class="sxs-lookup"><span data-stu-id="0f8fd-174">Input Event Class Handling</span></span>  
 <span data-ttu-id="0f8fd-175">Los métodos virtuales de controlador de clase se registran de modo que solo se invocan en casos donde ya no se marcan los datos de evento compartidos como controlados.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-175">The class handler virtual methods are all registered such that they are only invoked in cases where any shared event data are not already marked handled.</span></span> <span data-ttu-id="0f8fd-176">Además, solo para los eventos de entrada, las versiones de tunelización y propagación, normalmente, se producen en secuencia y comparten datos de eventos.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-176">Also, for the input events uniquely, the tunneling and bubbling versions typically are raised in sequence and share event data.</span></span> <span data-ttu-id="0f8fd-177">Esto supone que, para un par determinado de controladores de clase de eventos de entrada, donde uno es la versión de tunelización y el otro, la de propagación, no es recomendable marcar el evento como controlado inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-177">This entails that for a given pair of class handlers of input events where one is the tunneling version and the other is the bubbling version, you may not want to mark the event handled immediately.</span></span> <span data-ttu-id="0f8fd-178">Si implementa el método virtual de control de clase de tunelización para marcar el evento como controlado, el controlador de clase de propagación no se podrá invocar (además de impedir que se invoque cualquier controlador de instancias registrado normalmente para el evento de tunelización o propagación).</span><span class="sxs-lookup"><span data-stu-id="0f8fd-178">If you implement the tunneling class handling virtual method to mark the event handled, that will prevent the bubbling class handler from being invoked (as well as preventing any normally registered instance handlers for either the tunneling or bubbling event from being invoked).</span></span>  
  
 <span data-ttu-id="0f8fd-179">Una vez completado el control de clases en un nodo, se consideran los agentes de escucha de instancia.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-179">Once class handling on a node is complete, the instance listeners are considered.</span></span>  
  
<a name="AddingInstanceHandlersthatAreRaisedEvenWhenEventsareMarkedHandled"></a>
## <a name="adding-instance-handlers-that-are-raised-even-when-events-are-marked-handled"></a><span data-ttu-id="0f8fd-180">Adición de controladores de instancias que se generan incluso cuando los eventos se marcan como controlados</span><span class="sxs-lookup"><span data-stu-id="0f8fd-180">Adding Instance Handlers That Are Raised Even When Events Are Marked Handled</span></span>  
 <span data-ttu-id="0f8fd-181">El <xref:System.Windows.UIElement.AddHandler%2A> método proporciona una sobrecarga determinada que permite agregar controladores que el sistema de eventos invocará siempre que un evento llegue al elemento de control de la ruta, incluso si algún otro controlador ya ha ajustado los datos del evento para marcar ese evento como controlado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-181">The <xref:System.Windows.UIElement.AddHandler%2A> method supplies a particular overload that allows you to add handlers that will be invoked by the event system whenever an event reaches the handling element in the route, even if some other handler has already adjusted the event data to mark that event as handled.</span></span> <span data-ttu-id="0f8fd-182">Normalmente, esto no se hace.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-182">This is not typically done.</span></span> <span data-ttu-id="0f8fd-183">Por lo general, se pueden escribir controladores para ajustar todas las áreas del código de aplicación que podrían verse afectadas por un evento, independientemente de dónde se controlara en un árbol de elementos, incluso si se quieren varios resultados finales.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-183">Generally, handlers can be written to adjust all areas of application code that might be influenced by an event, regardless of where it was handled in an element tree, even if multiple end results are desired.</span></span> <span data-ttu-id="0f8fd-184">Además, normalmente, solo hay un elemento que necesite responder a ese evento y la lógica de aplicación adecuada ya se ha ejecutado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-184">Also, typically there is really only one element that needs to respond to that event, and the appropriate application logic had already happened.</span></span> <span data-ttu-id="0f8fd-185">Pero la sobrecarga `handledEventsToo` está disponible para los casos excepcionales en que otro elemento de una composición de control o árbol de elementos ya se ha marcado como controlado, pero otros elementos superiores o inferiores del árbol de elementos (dependiendo de la ruta) aún quieren tener sus propios controladores invocados.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-185">But the `handledEventsToo` overload is available for the exceptional cases where some other element in an element tree or control compositing has already marked an event as handled, but other elements either higher or lower in the element tree (depending on route) still wish to have their own handlers invoked.</span></span>  
  
#### <a name="when-to-mark-handled-events-as-unhandled"></a><span data-ttu-id="0f8fd-186">Cuándo se deben marcar los eventos controlados como no controlados</span><span class="sxs-lookup"><span data-stu-id="0f8fd-186">When to Mark Handled Events as Unhandled</span></span>  
 <span data-ttu-id="0f8fd-187">Por lo general, los eventos enrutados marcados<xref:System.Windows.RoutedEventArgs.Handled%2A> como controlados no deben marcarse como no controlados (establecidos en `false`) ni siquiera por controladores que actúan en `handledEventsToo`.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-187">Generally, routed events that are marked handled should not be marked unhandled (<xref:System.Windows.RoutedEventArgs.Handled%2A> set back to `false`) even by handlers that act on `handledEventsToo`.</span></span> <span data-ttu-id="0f8fd-188">Sin embargo, algunos eventos de entrada tienen representaciones de eventos de alto nivel y de nivel inferior que pueden superponerse cuando el evento de alto nivel se ve en una posición en el árbol y el evento de bajo nivel en otra posición.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-188">However, some input events have high-level and lower-level event representations that can overlap when the high-level event is seen at one position in the tree and the low-level event at another position.</span></span> <span data-ttu-id="0f8fd-189">Por ejemplo, considere el caso en el que un elemento <xref:System.Windows.UIElement.TextInput> secundario escucha un evento de clave de <xref:System.Windows.UIElement.KeyDown>alto nivel, como mientras un elemento primario escucha un evento de bajo nivel como .</span><span class="sxs-lookup"><span data-stu-id="0f8fd-189">For instance, consider the case where a child element listens to a high-level key event such as <xref:System.Windows.UIElement.TextInput> while a parent element listens to a low-level event such as <xref:System.Windows.UIElement.KeyDown>.</span></span> <span data-ttu-id="0f8fd-190">Si el elemento primario controla el evento de bajo nivel, el evento de nivel superior se puede suprimir incluso en el elemento secundario que, intuitivamente, debería tener la primera oportunidad de controlar el evento.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-190">If the parent element handles the low-level event, the higher-level event can be suppressed even in the child element that intuitively should have first opportunity to handle the event.</span></span>  
  
 <span data-ttu-id="0f8fd-191">En estas situaciones, puede ser necesario agregar controladores a los elementos primarios y secundarios para el evento de bajo nivel.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-191">In these situations it may be necessary to add handlers to both parent elements and child elements for the low-level event.</span></span> <span data-ttu-id="0f8fd-192">La implementación del controlador del elemento secundario puede marcar el evento de bajo nivel como controlado, pero la implementación del controlador del elemento primario lo marcaría de nuevo como no controlado para que los elementos superiores del árbol (así como el evento de alto nivel) puedan tener la oportunidad de responder.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-192">The child element handler implementation can mark the low-level event as handled, but the parent element handler implementation would set it unhandled again so that further elements up the tree (as well as the high-level event) can have the opportunity to respond.</span></span> <span data-ttu-id="0f8fd-193">Esta situación debería ser poco frecuente.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-193">This situation is should be fairly rare.</span></span>  
  
<a name="Deliberately_Suppressing_Input_Events_for_Control"></a>
## <a name="deliberately-suppressing-input-events-for-control-compositing"></a><span data-ttu-id="0f8fd-194">Supresión deliberada de eventos de entrada para la composición de control</span><span class="sxs-lookup"><span data-stu-id="0f8fd-194">Deliberately Suppressing Input Events for Control Compositing</span></span>  
 <span data-ttu-id="0f8fd-195">El escenario principal donde se utiliza el control de clases de eventos enrutados es para los eventos de entrada y los controles compuestos.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-195">The main scenario where class handling of routed events is used is for input events and composited controls.</span></span> <span data-ttu-id="0f8fd-196">Un control compuesto está, por definición, compuesto por varios controles prácticos o clases base de control.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-196">A composited control is by definition composed of multiple practical controls or control base classes.</span></span> <span data-ttu-id="0f8fd-197">A menudo, el autor del control quiere amalgamar todos los posibles eventos de entrada que cada uno de los subcomponentes pueda generar a fin de notificar todo el control como el origen del evento singular.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-197">Often the author of the control wishes to amalgamate all of the possible input events that each of the subcomponents might raise, in order to report the entire control as the singular event source.</span></span> <span data-ttu-id="0f8fd-198">En algunos casos, puede que el autor del control quiera suprimir los eventos de los componentes por completo o sustituir un evento definido por el componente que lleva más información o implica un comportamiento más concreto.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-198">In some cases the control author might wish to suppress the events from components entirely, or substitute a component-defined event that carries more information or implies a more specific behavior.</span></span> <span data-ttu-id="0f8fd-199">El ejemplo canónico que es inmediatamente visible [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> para cualquier autor de componentes es cómo un controla cualquier evento del mouse que finalmente se resolverá en el evento intuitivo que todos los botones tienen: un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-199">The canonical example that is immediately visible to any component author is how a [!INCLUDE[TLA#tla_winclient](../../../../includes/tlasharptla-winclient-md.md)] <xref:System.Windows.Controls.Button> handles any mouse event that will eventually resolve to the intuitive event that all buttons have: a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 <span data-ttu-id="0f8fd-200">La <xref:System.Windows.Controls.Button> clase<xref:System.Windows.Controls.Primitives.ButtonBase>base ( <xref:System.Windows.Controls.Control> ) deriva de <xref:System.Windows.FrameworkElement> la <xref:System.Windows.UIElement>que a su vez deriva y , y <xref:System.Windows.UIElement> gran parte de la infraestructura de eventos necesaria para el procesamiento de entrada de control está disponible en el nivel.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-200">The <xref:System.Windows.Controls.Button> base class (<xref:System.Windows.Controls.Primitives.ButtonBase>) derives from <xref:System.Windows.Controls.Control> which in turn derives from <xref:System.Windows.FrameworkElement> and <xref:System.Windows.UIElement>, and much of the event infrastructure needed for control input processing is available at the <xref:System.Windows.UIElement> level.</span></span> <span data-ttu-id="0f8fd-201">En particular, <xref:System.Windows.UIElement> <xref:System.Windows.Input.Mouse> procesa eventos generales que controlan las pruebas de posicionamiento para el cursor del <xref:System.Windows.UIElement.MouseLeftButtonDown>mouse dentro de sus límites y proporciona eventos distintos para las acciones de botón más comunes, como .</span><span class="sxs-lookup"><span data-stu-id="0f8fd-201">In particular, <xref:System.Windows.UIElement> processes general <xref:System.Windows.Input.Mouse> events that handle hit testing for the mouse cursor within its bounds, and provides distinct events for the most common button actions, such as <xref:System.Windows.UIElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="0f8fd-202"><xref:System.Windows.UIElement>también proporciona una <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> virtual vacía como <xref:System.Windows.UIElement.MouseLeftButtonDown>el <xref:System.Windows.Controls.Primitives.ButtonBase> controlador de clases preregistrado para , y lo reemplaza.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-202"><xref:System.Windows.UIElement> also provides an empty virtual <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> as the preregistered class handler for <xref:System.Windows.UIElement.MouseLeftButtonDown>, and <xref:System.Windows.Controls.Primitives.ButtonBase> overrides it.</span></span> <span data-ttu-id="0f8fd-203">De <xref:System.Windows.Controls.Primitives.ButtonBase> forma similar, <xref:System.Windows.UIElement.MouseLeftButtonUp>usa controladores de clase para .</span><span class="sxs-lookup"><span data-stu-id="0f8fd-203">Similarly, <xref:System.Windows.Controls.Primitives.ButtonBase> uses class handlers for <xref:System.Windows.UIElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="0f8fd-204">En las invalidaciones, que se pasan los datos <xref:System.Windows.RoutedEventArgs> del evento, <xref:System.Windows.RoutedEventArgs.Handled%2A> las `true`implementaciones marcan esa instancia como controlada estableciendo en , y los mismos datos de evento es lo que continúa a lo largo del resto de la ruta a otros controladores de clase y también a controladores de instancias o establecedores de eventos.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-204">In the overrides, which are passed the event data, the implementations mark that <xref:System.Windows.RoutedEventArgs> instance as handled by setting <xref:System.Windows.RoutedEventArgs.Handled%2A> to `true`, and that same event data is what continues along the remainder of the route to other class handlers and also to instance handlers or event setters.</span></span> <span data-ttu-id="0f8fd-205">Además, la <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> invalidación generará el <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento a continuación.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-205">Also, the <xref:System.Windows.Controls.Primitives.ButtonBase.OnMouseLeftButtonUp%2A> override will next raise the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="0f8fd-206">El resultado final para la mayoría <xref:System.Windows.UIElement.MouseLeftButtonDown> <xref:System.Windows.UIElement.MouseLeftButtonUp> de los agentes de escucha <xref:System.Windows.Controls.Primitives.ButtonBase.Click>será que los eventos y "desaparecen" y se reemplazan en su lugar por , un evento que tiene más significado porque se sabe que este evento se originó a partir de un botón verdadero y no de alguna pieza compuesta del botón o de algún otro elemento por completo.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-206">The end result for most listeners will be that the <xref:System.Windows.UIElement.MouseLeftButtonDown> and <xref:System.Windows.UIElement.MouseLeftButtonUp> events "disappear" and are replaced instead by <xref:System.Windows.Controls.Primitives.ButtonBase.Click>, an event that holds more meaning because it is known that this event originated from a true button and not some composite piece of the button or from some other element entirely.</span></span>  
  
<a name="WorkingAroundEventSuppressionByControls"></a>
### <a name="working-around-event-suppression-by-controls"></a><span data-ttu-id="0f8fd-207">Solución de la supresión de eventos mediante controles</span><span class="sxs-lookup"><span data-stu-id="0f8fd-207">Working Around Event Suppression by Controls</span></span>  
 <span data-ttu-id="0f8fd-208">A veces, este comportamiento de supresión de eventos en controles individuales puede interferir con algunas intenciones más generales de la lógica de control de eventos de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-208">Sometimes this event suppression behavior within individual controls can interfere with some more general intentions of event handling logic for your application.</span></span> <span data-ttu-id="0f8fd-209">Por ejemplo, si por alguna razón <xref:System.Windows.UIElement.MouseLeftButtonDown> la aplicación tenía un controlador para ubicado en el elemento <xref:System.Windows.UIElement.MouseLeftButtonDown> raíz <xref:System.Windows.UIElement.MouseLeftButtonUp> de la aplicación, se daría cuenta de que cualquier clic del mouse en un botón no invocaría o controladores en el nivel raíz.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-209">For instance, if for some reason your application had a handler for <xref:System.Windows.UIElement.MouseLeftButtonDown> located at the application root element, you would notice that any mouse click on a button would not invoke <xref:System.Windows.UIElement.MouseLeftButtonDown> or <xref:System.Windows.UIElement.MouseLeftButtonUp> handlers at the root level.</span></span> <span data-ttu-id="0f8fd-210">En realidad, el evento en sí se propagó hacia arriba (de nuevo, las rutas de evento no están finalizadas realmente, pero el sistema de eventos enrutados cambia su comportamiento de invocación de controlador después de marcarse como controlado).</span><span class="sxs-lookup"><span data-stu-id="0f8fd-210">The event itself actually did bubble up (again, event routes are not truly ended, but the routed event system changes their handler invocation behavior after being marked handled).</span></span> <span data-ttu-id="0f8fd-211">Cuando el evento enrutado <xref:System.Windows.Controls.Primitives.ButtonBase> alcanzó <xref:System.Windows.UIElement.MouseLeftButtonDown> el botón, el control <xref:System.Windows.Controls.Primitives.ButtonBase.Click> de clase marcó el controlado porque deseaba sustituir el evento con más significado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-211">When the routed event reached the button, the <xref:System.Windows.Controls.Primitives.ButtonBase> class handling marked the <xref:System.Windows.UIElement.MouseLeftButtonDown> handled because it wished to substitute the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event with more meaning.</span></span> <span data-ttu-id="0f8fd-212">Por lo <xref:System.Windows.UIElement.MouseLeftButtonDown> tanto, no se invocaría ningún controlador estándar más arriba de la ruta.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-212">Therefore, any standard <xref:System.Windows.UIElement.MouseLeftButtonDown> handler further up the route would not be invoked.</span></span> <span data-ttu-id="0f8fd-213">Hay dos técnicas que puede usar para asegurarse de que los controladores se invoquen en estas circunstancias.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-213">There are two techniques you can use to ensure that your handlers would be invoked in this circumstance.</span></span>  
  
 <span data-ttu-id="0f8fd-214">La primera técnica consiste en agregar `handledEventsToo` deliberadamente el controlador mediante la firma de <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-214">The first technique is to deliberately add the handler using the `handledEventsToo` signature of <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29>.</span></span> <span data-ttu-id="0f8fd-215">Una limitación de este enfoque es que esta técnica para adjuntar un controlador de eventos solo es posible desde el código, no desde el marcado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-215">A limitation of this approach is that this technique for attaching an event handler is only possible from code, not from markup.</span></span> <span data-ttu-id="0f8fd-216">La sintaxis simple de especificar el nombre del controlador de eventos como un valor de atributo de evento a través de [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] no permite ese comportamiento.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-216">The simple syntax of specifying the event handler name as an event attribute value via [!INCLUDE[TLA#tla_xaml](../../../../includes/tlasharptla-xaml-md.md)] does not enable that behavior.</span></span>  
  
 <span data-ttu-id="0f8fd-217">La segunda técnica solo funciona para los eventos de entrada, donde se emparejan las versiones de tunelización y propagación del evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-217">The second technique works only for input events, where the tunneling and bubbling versions of the routed event are paired.</span></span> <span data-ttu-id="0f8fd-218">Para estos eventos enrutados, también puede agregar controladores al evento enrutado equivalente de tunelización/vista previa.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-218">For these routed events, you can add handlers to the preview/tunneling equivalent routed event instead.</span></span> <span data-ttu-id="0f8fd-219">El evento enrutado se tunelizará por la ruta partiendo de la raíz, por lo que el código de control de clase del botón no lo interceptaría, siempre que haya adjuntado el controlador Preview en algún nivel de elemento antecesor en el árbol de elementos de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-219">That routed event will tunnel through the route starting from the root, so the button class handling code would not intercept it, presuming that you attached the Preview handler at some ancestor element level in the application's element tree.</span></span> <span data-ttu-id="0f8fd-220">Si usa este enfoque, tenga cuidado al marcar cualquier evento Preview como controlado.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-220">If you use this approach, be cautious about marking any Preview event handled.</span></span> <span data-ttu-id="0f8fd-221">Para el ejemplo <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> dado con el control en el elemento <xref:System.Windows.RoutedEventArgs.Handled%2A> raíz, si marcó el <xref:System.Windows.Controls.Primitives.ButtonBase.Click> evento como en la implementación del controlador, realmente suprimiría el evento.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-221">For the example given with <xref:System.Windows.UIElement.PreviewMouseLeftButtonDown> being handled at the root element, if you marked the event as <xref:System.Windows.RoutedEventArgs.Handled%2A> in the handler implementation, you would actually suppress the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span> <span data-ttu-id="0f8fd-222">Normalmente, no es un comportamiento deseable.</span><span class="sxs-lookup"><span data-stu-id="0f8fd-222">That is typically not desirable behavior.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="0f8fd-223">Consulte también</span><span class="sxs-lookup"><span data-stu-id="0f8fd-223">See also</span></span>

- <xref:System.Windows.EventManager>
- [<span data-ttu-id="0f8fd-224">Eventos de vista previa</span><span class="sxs-lookup"><span data-stu-id="0f8fd-224">Preview Events</span></span>](preview-events.md)
- [<span data-ttu-id="0f8fd-225">Crear un evento enrutado personalizado</span><span class="sxs-lookup"><span data-stu-id="0f8fd-225">Create a Custom Routed Event</span></span>](how-to-create-a-custom-routed-event.md)
- [<span data-ttu-id="0f8fd-226">Información general sobre eventos enrutados</span><span class="sxs-lookup"><span data-stu-id="0f8fd-226">Routed Events Overview</span></span>](routed-events-overview.md)
