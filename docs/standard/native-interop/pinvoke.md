---
title: Invocación de plataforma (P/Invoke)
description: Obtenga información sobre cómo llamar a funciones nativas a través de P/Invoke en. NET.
ms.date: 01/18/2019
ms.openlocfilehash: fa8b43edfba50fbc620f257c4e7caf1673f83235
ms.sourcegitcommit: 5f236cd78cf09593c8945a7d753e0850e96a0b80
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/07/2020
ms.locfileid: "75706310"
---
# <a name="platform-invoke-pinvoke"></a><span data-ttu-id="bd278-103">Invocación de plataforma (P/Invoke)</span><span class="sxs-lookup"><span data-stu-id="bd278-103">Platform Invoke (P/Invoke)</span></span>

<span data-ttu-id="bd278-104">P/Invoke es una tecnología que permite acceder a estructuras, devoluciones de llamada y funciones de bibliotecas no administradas desde el código administrado.</span><span class="sxs-lookup"><span data-stu-id="bd278-104">P/Invoke is a technology that allows you to access structs, callbacks, and functions in unmanaged libraries from your managed code.</span></span> <span data-ttu-id="bd278-105">La mayor parte de la API de P/Invoke se encuentra en dos espacios de nombres: `System` y `System.Runtime.InteropServices`.</span><span class="sxs-lookup"><span data-stu-id="bd278-105">Most of the P/Invoke API is contained in two namespaces: `System` and `System.Runtime.InteropServices`.</span></span> <span data-ttu-id="bd278-106">Mediante estos dos espacios de nombres puede acceder a las herramientas que describen cómo quiere comunicarse con el componente nativo.</span><span class="sxs-lookup"><span data-stu-id="bd278-106">Using these two namespaces give you the tools to describe how you want to communicate with the native component.</span></span>

<span data-ttu-id="bd278-107">Empecemos por el ejemplo más común, es decir, llamar a funciones no administradas en el código administrado.</span><span class="sxs-lookup"><span data-stu-id="bd278-107">Let’s start from the most common example, and that is calling unmanaged functions in your managed code.</span></span> <span data-ttu-id="bd278-108">Vamos a mostrar un cuadro de mensaje desde una aplicación de línea de comandos:</span><span class="sxs-lookup"><span data-stu-id="bd278-108">Let’s show a message box from a command-line application:</span></span>

[!code-csharp[MessageBox](~/samples/snippets/standard/interop/pinvoke/messagebox.cs)]

<span data-ttu-id="bd278-109">El ejemplo anterior es simple, pero resalta lo que es necesario para invocar las funciones no administradas desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="bd278-109">The previous example is simple, but it does show off what's needed to invoke unmanaged functions from managed code.</span></span> <span data-ttu-id="bd278-110">Veamos en detalle el ejemplo:</span><span class="sxs-lookup"><span data-stu-id="bd278-110">Let’s step through the example:</span></span>

- <span data-ttu-id="bd278-111">En la línea 1 se muestra el uso de la instrucción para el espacio de nombres `System.Runtime.InteropServices`, que es el espacio de nombres que contiene todos los elementos que necesitamos.</span><span class="sxs-lookup"><span data-stu-id="bd278-111">Line #1 shows the using statement for the `System.Runtime.InteropServices` namespace that holds all the items needed.</span></span>
- <span data-ttu-id="bd278-112">En la línea 7 se introduce el atributo `DllImport`.</span><span class="sxs-lookup"><span data-stu-id="bd278-112">Line #7 introduces the `DllImport` attribute.</span></span> <span data-ttu-id="bd278-113">Este atributo es fundamental, ya que le indica al tiempo de ejecución que debe cargar la DLL no administrada.</span><span class="sxs-lookup"><span data-stu-id="bd278-113">This attribute is crucial, as it tells the runtime that it should load the unmanaged DLL.</span></span> <span data-ttu-id="bd278-114">La cadena que se pasa es la DLL en la que está nuestra función de destino.</span><span class="sxs-lookup"><span data-stu-id="bd278-114">The string passed in is the DLL our target function is in.</span></span> <span data-ttu-id="bd278-115">Además, especifica qué [juego de caracteres](./charset.md) se usará para serializar las cadenas.</span><span class="sxs-lookup"><span data-stu-id="bd278-115">Additionally, it specifies which [character set](./charset.md) to use for marshalling the strings.</span></span> <span data-ttu-id="bd278-116">Por último, especifica que esta función llama a [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) y que el runtime debe capturar ese código de error para que el usuario pueda recuperarlo a través de <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bd278-116">Finally, it specifies that this function calls [SetLastError](/windows/desktop/api/errhandlingapi/nf-errhandlingapi-setlasterror) and that the runtime should capture that error code so the user can retrieve it via <xref:System.Runtime.InteropServices.Marshal.GetLastWin32Error?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="bd278-117">La línea 8 es la esencia del trabajo de P/Invoke.</span><span class="sxs-lookup"><span data-stu-id="bd278-117">Line #8 is the crux of the P/Invoke work.</span></span> <span data-ttu-id="bd278-118">Define un método administrado que tiene **exactamente la misma firma** que el no administrado.</span><span class="sxs-lookup"><span data-stu-id="bd278-118">It defines a managed method that has the **exact same signature** as the unmanaged one.</span></span> <span data-ttu-id="bd278-119">Como puede ver, la declaración tiene una nueva palabra clave (`extern`) que le indica al tiempo de ejecución que esto es un método externo y que, cuando se invoca, el tiempo de ejecución debe buscarlo en el archivo DLL especificado en el atributo `DllImport`.</span><span class="sxs-lookup"><span data-stu-id="bd278-119">The declaration has a new keyword that you can notice, `extern`, which tells the runtime this is an external method, and that when you invoke it, the runtime should find it in the DLL specified in `DllImport` attribute.</span></span>

<span data-ttu-id="bd278-120">El resto del ejemplo simplemente invoca el método como si se tratara de cualquier otro método administrado.</span><span class="sxs-lookup"><span data-stu-id="bd278-120">The rest of the example is just invoking the method as you would any other managed method.</span></span>

<span data-ttu-id="bd278-121">El ejemplo es parecido para macOS.</span><span class="sxs-lookup"><span data-stu-id="bd278-121">The sample is similar for macOS.</span></span> <span data-ttu-id="bd278-122">El nombre de la biblioteca en el atributo `DllImport` debe cambiarse, ya que macOS tiene un esquema diferente para la nomenclatura de bibliotecas dinámicas.</span><span class="sxs-lookup"><span data-stu-id="bd278-122">The name of the library in the `DllImport` attribute needs to change since macOS has a different scheme of naming dynamic libraries.</span></span> <span data-ttu-id="bd278-123">En el ejemplo siguiente se usa la función `getpid(2)` para obtener el identificador de proceso de la aplicación e imprimirlo en la consola:</span><span class="sxs-lookup"><span data-stu-id="bd278-123">The following sample uses the `getpid(2)` function to get the process ID of the application and print it out to the console:</span></span>

[!code-csharp[getpid macOS](~/samples/snippets/standard/interop/pinvoke/getpid-macos.cs)]

<span data-ttu-id="bd278-124">También es similar en Linux.</span><span class="sxs-lookup"><span data-stu-id="bd278-124">It is also similar on Linux.</span></span> <span data-ttu-id="bd278-125">El nombre de la función es el mismo, ya que `getpid(2)` es la llamada del sistema estándar de [POSIX](https://en.wikipedia.org/wiki/POSIX).</span><span class="sxs-lookup"><span data-stu-id="bd278-125">The function name is the same, since `getpid(2)` is a standard [POSIX](https://en.wikipedia.org/wiki/POSIX) system call.</span></span>

[!code-csharp[getpid Linux](~/samples/snippets/standard/interop/pinvoke/getpid-linux.cs)]

## <a name="invoking-managed-code-from-unmanaged-code"></a><span data-ttu-id="bd278-126">Invocar código administrado desde código no administrado</span><span class="sxs-lookup"><span data-stu-id="bd278-126">Invoking managed code from unmanaged code</span></span>

<span data-ttu-id="bd278-127">El entorno de ejecución permite que la comunicación fluya en ambas direcciones, lo que permite llamar a código administrado desde funciones nativas mediante el uso de punteros de función.</span><span class="sxs-lookup"><span data-stu-id="bd278-127">The runtime allows communication to flow in both directions, enabling you to call back into managed code from native functions by using function pointers.</span></span> <span data-ttu-id="bd278-128">Lo más parecido a un puntero de función en código administrado es un **delegado**, por lo que esto es lo que se usa para permitir las devoluciones de llamada de código nativo a código administrado.</span><span class="sxs-lookup"><span data-stu-id="bd278-128">The closest thing to a function pointer in managed code is a **delegate**, so this is what is used to allow callbacks from native code into managed code.</span></span>

<span data-ttu-id="bd278-129">La forma en que se usa esta característica se parece al proceso de administrado a nativo que se ha descrito anteriormente.</span><span class="sxs-lookup"><span data-stu-id="bd278-129">The way to use this feature is similar to the managed to native process previously described.</span></span> <span data-ttu-id="bd278-130">En el caso de una devolución de llamada específica, debe definir un delegado que coincida con la firma y pasarlo al método externo.</span><span class="sxs-lookup"><span data-stu-id="bd278-130">For a given callback, you define a delegate that matches the signature and pass that into the external method.</span></span> <span data-ttu-id="bd278-131">El tiempo de ejecución se encargará de todo lo demás.</span><span class="sxs-lookup"><span data-stu-id="bd278-131">The runtime will take care of everything else.</span></span>

[!code-csharp[EnumWindows](~/samples/snippets/standard/interop/pinvoke/enumwindows.cs)]

<span data-ttu-id="bd278-132">Antes de examinar el ejemplo, conviene que analicemos las firmas de las funciones no administradas con las que tenemos que trabajar.</span><span class="sxs-lookup"><span data-stu-id="bd278-132">Before walking through the example, it's good to review the signatures of the unmanaged functions you need to work with.</span></span> <span data-ttu-id="bd278-133">La función a la que queremos llamar para enumerar todas las ventanas tiene la firma siguiente: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="bd278-133">The function to be called to enumerate all of the windows has the following signature: `BOOL EnumWindows (WNDENUMPROC lpEnumFunc, LPARAM lParam);`</span></span>

<span data-ttu-id="bd278-134">El primer parámetro es una devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="bd278-134">The first parameter is a callback.</span></span> <span data-ttu-id="bd278-135">Dicha devolución de llamada tiene la firma siguiente: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span><span class="sxs-lookup"><span data-stu-id="bd278-135">The said callback has the following signature: `BOOL CALLBACK EnumWindowsProc (HWND hwnd, LPARAM lParam);`</span></span>

<span data-ttu-id="bd278-136">Ahora, examinemos el proceso:</span><span class="sxs-lookup"><span data-stu-id="bd278-136">Now, let’s walk through the example:</span></span>

- <span data-ttu-id="bd278-137">En la línea 9 del ejemplo se define un delegado que coincide con la firma de la devolución de llamada desde código no administrado.</span><span class="sxs-lookup"><span data-stu-id="bd278-137">Line #9 in the example defines a delegate that matches the signature of the callback from unmanaged code.</span></span> <span data-ttu-id="bd278-138">Observe cómo se representan los tipos LPARAM y HWND mediante el uso de `IntPtr` en el código administrado.</span><span class="sxs-lookup"><span data-stu-id="bd278-138">Notice how the LPARAM and HWND types are represented using `IntPtr` in the managed code.</span></span>
- <span data-ttu-id="bd278-139">En las líneas 13 y 14 se introduce la función `EnumWindows` desde la biblioteca user32.dll.</span><span class="sxs-lookup"><span data-stu-id="bd278-139">Lines #13 and #14 introduce the `EnumWindows` function from the user32.dll library.</span></span>
- <span data-ttu-id="bd278-140">En las líneas de la 17 a la 20 se implementa el delegado.</span><span class="sxs-lookup"><span data-stu-id="bd278-140">Lines #17 - 20 implement the delegate.</span></span> <span data-ttu-id="bd278-141">En este sencillo ejemplo, solo queremos generar el identificador de la consola.</span><span class="sxs-lookup"><span data-stu-id="bd278-141">For this simple example, we just want to output the handle to the console.</span></span>
- <span data-ttu-id="bd278-142">Por último, en la línea 24, se invoca el método externo y se pasa el delegado.</span><span class="sxs-lookup"><span data-stu-id="bd278-142">Finally, in line #24, the external method is called and passed in the delegate.</span></span>

<span data-ttu-id="bd278-143">Los ejemplos de Linux y macOS se muestran a continuación.</span><span class="sxs-lookup"><span data-stu-id="bd278-143">The Linux and macOS examples are shown below.</span></span> <span data-ttu-id="bd278-144">Para ellos, usamos la función `ftw` que se encuentra en `libc`, la biblioteca de C.</span><span class="sxs-lookup"><span data-stu-id="bd278-144">For them, we use the `ftw` function that can be found in `libc`, the C library.</span></span> <span data-ttu-id="bd278-145">Esta función se usa para atravesar las jerarquías de directorio y toma un puntero a una función como uno de sus parámetros.</span><span class="sxs-lookup"><span data-stu-id="bd278-145">This function is used to traverse directory hierarchies and it takes a pointer to a function as one of its parameters.</span></span> <span data-ttu-id="bd278-146">Dicha función tiene la firma siguiente: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span><span class="sxs-lookup"><span data-stu-id="bd278-146">The said function has the following signature: `int (*fn) (const char *fpath, const struct stat *sb, int typeflag)`.</span></span>

[!code-csharp[ftw Linux](~/samples/snippets/standard/interop/pinvoke/ftw-linux.cs)]

<span data-ttu-id="bd278-147">El ejemplo de macOS usa la misma función. La única diferencia es el argumento del atributo `DllImport`, ya que macOS guarda `libc` en un lugar diferente.</span><span class="sxs-lookup"><span data-stu-id="bd278-147">macOS example uses the same function, and the only difference is the argument to the `DllImport` attribute, as macOS keeps `libc` in a different place.</span></span>

[!code-csharp[ftw macOS](~/samples/snippets/standard/interop/pinvoke/ftw-macos.cs)]

<span data-ttu-id="bd278-148">Los dos ejemplos anteriores dependen de parámetros y, en ambos casos, los parámetros se proporcionan como tipos administrados.</span><span class="sxs-lookup"><span data-stu-id="bd278-148">Both of the previous examples depend on parameters, and in both cases, the parameters are given as managed types.</span></span> <span data-ttu-id="bd278-149">El tiempo de ejecución hace "lo correcto" y los procesa en sus equivalentes en el otro lado.</span><span class="sxs-lookup"><span data-stu-id="bd278-149">Runtime does the "right thing" and processes these into its equivalents on the other side.</span></span> <span data-ttu-id="bd278-150">Obtenga información sobre cómo los tipos se serializan al código nativo en nuestra página en [Serialización de tipos](type-marshaling.md).</span><span class="sxs-lookup"><span data-stu-id="bd278-150">Learn about how types are marshaled to native code in our page on [Type marshaling](type-marshaling.md).</span></span>

## <a name="more-resources"></a><span data-ttu-id="bd278-151">Más recursos</span><span class="sxs-lookup"><span data-stu-id="bd278-151">More resources</span></span>

- <span data-ttu-id="bd278-152">[Wiki de PInvoke.net](https://www.pinvoke.net/): una wiki excelente con información sobre API comunes de Windows y cómo llamarlas.</span><span class="sxs-lookup"><span data-stu-id="bd278-152">[PInvoke.net wiki](https://www.pinvoke.net/) an excellent Wiki with information on common Windows APIs and how to call them.</span></span>
- [<span data-ttu-id="bd278-153">P/Invoke en C++/CLI</span><span class="sxs-lookup"><span data-stu-id="bd278-153">P/Invoke in C++/CLI</span></span>](/cpp/dotnet/native-and-dotnet-interoperability)
- [<span data-ttu-id="bd278-154">Documentación de Mono en P/Invoke</span><span class="sxs-lookup"><span data-stu-id="bd278-154">Mono documentation on P/Invoke</span></span>](https://www.mono-project.com/docs/advanced/pinvoke/)
