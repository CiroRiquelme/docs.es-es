---
title: Detalles de la sintaxis XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 5f8bb862ce443fd7397036b10f69cda65a6960bc
ms.sourcegitcommit: 62285ec11fa8e8424bab00511a90760c60e63c95
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/20/2020
ms.locfileid: "81646141"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="a01cb-102">Detalles de la sintaxis XAML</span><span class="sxs-lookup"><span data-stu-id="a01cb-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="a01cb-103">En este tema se definen los términos que se usan para describir los elementos de la sintaxis XAML.</span><span class="sxs-lookup"><span data-stu-id="a01cb-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="a01cb-104">Estos términos se usan con frecuencia en el resto de esta documentación, tanto para la documentación de WPF específicamente como para los otros marcos que usan XAML o los conceptos XAML básicos habilitados por la compatibilidad con el lenguaje XAML en el nivel System.Xaml.</span><span class="sxs-lookup"><span data-stu-id="a01cb-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="a01cb-105">En este tema se amplía la terminología básica introducida en el tema Información general sobre [XAML (WPF).](../../../desktop-wpf/fundamentals/xaml.md)</span><span class="sxs-lookup"><span data-stu-id="a01cb-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  

<a name="the_xaml_language_specification"></a>
## <a name="the-xaml-language-specification"></a><span data-ttu-id="a01cb-106">La especificación del lenguaje XAML</span><span class="sxs-lookup"><span data-stu-id="a01cb-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="a01cb-107">La terminología de sintaxis XAML definida aquí también se define o se hace referencia dentro de la especificación del lenguaje XAML.</span><span class="sxs-lookup"><span data-stu-id="a01cb-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="a01cb-108">XAML es un lenguaje basado en XML y sigue o expande las reglas estructurales XML.</span><span class="sxs-lookup"><span data-stu-id="a01cb-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="a01cb-109">Parte de la terminología se comparte o se basa en la terminología que se utiliza comúnmente al describir el lenguaje XML o el modelo de objetos de documento XML.</span><span class="sxs-lookup"><span data-stu-id="a01cb-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="a01cb-110">Para obtener más información acerca de la especificación del lenguaje XAML, descargue [ \[MS-XAML\] ](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) desde el Centro de descarga de Microsoft.</span><span class="sxs-lookup"><span data-stu-id="a01cb-110">For more information about the XAML language specification, download [\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>
## <a name="xaml-and-clr"></a><span data-ttu-id="a01cb-111">XAML y CLR</span><span class="sxs-lookup"><span data-stu-id="a01cb-111">XAML and CLR</span></span>  
 <span data-ttu-id="a01cb-112">XAML es un lenguaje de marcado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-112">XAML is a markup language.</span></span> <span data-ttu-id="a01cb-113">Common Language Runtime (CLR), tal como lo implica su nombre, habilita la ejecución en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="a01cb-113">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="a01cb-114">XAML no es por sí mismo uno de los lenguajes comunes que consume directamente el tiempo de ejecución de CLR.</span><span class="sxs-lookup"><span data-stu-id="a01cb-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="a01cb-115">En su lugar, puede pensar que XAML admite su propio sistema de tipos.</span><span class="sxs-lookup"><span data-stu-id="a01cb-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="a01cb-116">El sistema de análisis XAML determinado que usa WPFWPF se basa en el sistema de tipos CLR y CLR.</span><span class="sxs-lookup"><span data-stu-id="a01cb-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="a01cb-117">Los tipos XAML se asignan a tipos CLR para crear instancias de una representación en tiempo de ejecución cuando se analiza XAML para WPF.</span><span class="sxs-lookup"><span data-stu-id="a01cb-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="a01cb-118">Por este motivo, el resto de la discusión de la sintaxis en este documento incluirá referencias al sistema de tipos CLR, aunque las discusiones de sintaxis equivalentes en la especificación del lenguaje XAML no lo hacen.</span><span class="sxs-lookup"><span data-stu-id="a01cb-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="a01cb-119">(Según el nivel de especificación del lenguaje XAML, los tipos XAML se podrían asignar a cualquier otro sistema de tipos, que no tiene que ser el CLR, pero que requeriría la creación y el uso de un analizador XAML diferente.)</span><span class="sxs-lookup"><span data-stu-id="a01cb-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="a01cb-120">Miembros de Tipos y Herencia de Clases</span><span class="sxs-lookup"><span data-stu-id="a01cb-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="a01cb-121">Las propiedades y los eventos que [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] aparecen como miembros XAML de un tipo a menudo se heredan de los tipos base.</span><span class="sxs-lookup"><span data-stu-id="a01cb-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="a01cb-122">Por ejemplo, considere `<Button Background="Blue" .../>`este ejemplo: .</span><span class="sxs-lookup"><span data-stu-id="a01cb-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="a01cb-123">La <xref:System.Windows.Controls.Control.Background%2A> propiedad no es una <xref:System.Windows.Controls.Button> propiedad declarada inmediatamente en la clase, si se va a examinar la definición de clase, los resultados de reflexión o la documentación.</span><span class="sxs-lookup"><span data-stu-id="a01cb-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="a01cb-124">En <xref:System.Windows.Controls.Control.Background%2A> su lugar, <xref:System.Windows.Controls.Control> se hereda de la clase base.</span><span class="sxs-lookup"><span data-stu-id="a01cb-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="a01cb-125">El comportamiento de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] herencia de clases de los elementos XAML es una desviación significativa de una interpretación aplicada por el esquema del marcado XML.</span><span class="sxs-lookup"><span data-stu-id="a01cb-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="a01cb-126">La herencia de clases puede volverse compleja, especialmente cuando las clases base intermedias son abstractas o cuando intervienen interfaces.</span><span class="sxs-lookup"><span data-stu-id="a01cb-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="a01cb-127">Esta es una razón por la que el conjunto de elementos XAML y sus atributos permisibles es difícil de representar con precisión y completamente utilizando los tipos de esquema que se usan normalmente para la programación XML, como el formato DTD o XSD.</span><span class="sxs-lookup"><span data-stu-id="a01cb-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for XML programming, such as DTD or XSD format.</span></span> <span data-ttu-id="a01cb-128">Otra razón es que las características de extensibilidad y asignación de tipos del propio lenguaje XAML impiden la integridad de cualquier representación fija de los tipos y miembros permitidos.</span><span class="sxs-lookup"><span data-stu-id="a01cb-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>
## <a name="object-element-syntax"></a><span data-ttu-id="a01cb-129">Sintaxis de elemento de objeto</span><span class="sxs-lookup"><span data-stu-id="a01cb-129">Object Element Syntax</span></span>  
 <span data-ttu-id="a01cb-130">*Sintaxis* de elemento de objeto es la sintaxis de marcado XAML que crea una instancia de una clase o estructura CLR mediante la declaración de un elemento XML.</span><span class="sxs-lookup"><span data-stu-id="a01cb-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="a01cb-131">Esta sintaxis es similar a la sintaxis de elemento de otros lenguajes de marcado como HTML.</span><span class="sxs-lookup"><span data-stu-id="a01cb-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="a01cb-132">La sintaxis del elemento de\<objeto comienza con un corchete angular izquierdo ( ), seguido inmediatamente por el nombre de tipo de la clase o estructura que se crea una instancia.</span><span class="sxs-lookup"><span data-stu-id="a01cb-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="a01cb-133">Cero o más espacios pueden seguir el nombre de tipo, y también se pueden declarar cero o más atributos en el elemento de objeto, con uno o más espacios que separan cada par de nombre de atributo "valor".</span><span class="sxs-lookup"><span data-stu-id="a01cb-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="a01cb-134">Por último, debe cumplirse una de las siguientes condiciones:</span><span class="sxs-lookup"><span data-stu-id="a01cb-134">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="a01cb-135">El elemento y la etiqueta deben cerrarse con una barra diagonal (/) seguida inmediatamente de un corchete de ángulo recto (>).</span><span class="sxs-lookup"><span data-stu-id="a01cb-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="a01cb-136">La etiqueta de apertura debe completarse con un corchete de ángulo recto (>).</span><span class="sxs-lookup"><span data-stu-id="a01cb-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="a01cb-137">Otros elementos de objeto, elementos de propiedad o texto interno, pueden seguir la etiqueta de apertura.</span><span class="sxs-lookup"><span data-stu-id="a01cb-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="a01cb-138">Exactamente qué contenido puede estar contenido aquí normalmente está restringido por el modelo de objetos del elemento.</span><span class="sxs-lookup"><span data-stu-id="a01cb-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="a01cb-139">La etiqueta de cierre equivalente para el elemento de objeto también debe existir, en el anidamiento y equilibrio adecuados con otros pares de etiquetas de apertura y cierre.</span><span class="sxs-lookup"><span data-stu-id="a01cb-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="a01cb-140">XAML implementado por .NET tiene un conjunto de reglas que asignan elementos de objeto en tipos, atributos en propiedades o eventos y espacios de nombres XAML a espacios de nombres CLR más ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="a01cb-141">Para WPF wpf y .NET, los elementos de objeto XAML se asignan a tipos .NET tal como se definen en los ensamblados a los que se hace referencia y los atributos se asignan a los miembros de esos tipos.</span><span class="sxs-lookup"><span data-stu-id="a01cb-141">For WPF and .NET, XAML object elements map to .NET types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="a01cb-142">Al hacer referencia a un tipo CLR en XAML, también tiene acceso a los miembros heredados de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="a01cb-143">Por ejemplo, el ejemplo siguiente es la sintaxis <xref:System.Windows.Controls.Button> de elemento de objeto <xref:System.Windows.FrameworkElement.Name%2A> que crea una instancia nueva de la clase y también especifica un atributo y un valor para ese atributo:</span><span class="sxs-lookup"><span data-stu-id="a01cb-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="a01cb-144">El ejemplo siguiente es la sintaxis de elemento de objeto que también incluye la sintaxis de propiedad de contenido XAML.</span><span class="sxs-lookup"><span data-stu-id="a01cb-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="a01cb-145">El texto interno contenido se usará <xref:System.Windows.Controls.TextBox> para establecer <xref:System.Windows.Controls.TextBox.Text%2A>la propiedad de contenido XAML, .</span><span class="sxs-lookup"><span data-stu-id="a01cb-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="a01cb-146">Modelos de contenido</span><span class="sxs-lookup"><span data-stu-id="a01cb-146">Content Models</span></span>  
 <span data-ttu-id="a01cb-147">Una clase puede admitir un uso como un elemento de objeto XAML en términos de la sintaxis, pero ese elemento solo funcionará correctamente en una aplicación o página cuando se coloca en una posición esperada de un modelo de contenido general o árbol de elementos.</span><span class="sxs-lookup"><span data-stu-id="a01cb-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="a01cb-148">Por ejemplo, <xref:System.Windows.Controls.MenuItem> normalmente, solo se debe <xref:System.Windows.Controls.Primitives.MenuBase> colocar como elemento <xref:System.Windows.Controls.Menu>secundario de una clase derivada como .</span><span class="sxs-lookup"><span data-stu-id="a01cb-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="a01cb-149">Los modelos de contenido para elementos específicos se documentan [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] como parte de las observaciones de las páginas de clase para los controles y otras clases que se pueden usar como elementos XAML.</span><span class="sxs-lookup"><span data-stu-id="a01cb-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>
## <a name="properties-of-object-elements"></a><span data-ttu-id="a01cb-150">Propiedades de los elementos de objeto</span><span class="sxs-lookup"><span data-stu-id="a01cb-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="a01cb-151">Las propiedades de XAML se establecen mediante una variedad de sintaxis posibles.</span><span class="sxs-lookup"><span data-stu-id="a01cb-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="a01cb-152">La sintaxis que se puede usar para una propiedad determinada variará en función de las características del sistema de tipos subyacentes de la propiedad que se va a establecer.</span><span class="sxs-lookup"><span data-stu-id="a01cb-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="a01cb-153">Al establecer valores de propiedades, se agregan entidades o características a los objetos tal como existen en el gráfico de objetos de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="a01cb-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="a01cb-154">El estado inicial del objeto creado a partir de un elemento de objeto se basa en el comportamiento del constructor sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="a01cb-154">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="a01cb-155">Normalmente, la aplicación usará algo distinto de una instancia completamente predeterminada de cualquier objeto determinado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>
## <a name="attribute-syntax-properties"></a><span data-ttu-id="a01cb-156">Sintaxis de atributos (propiedades)</span><span class="sxs-lookup"><span data-stu-id="a01cb-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="a01cb-157">Sintaxis de atributo es la sintaxis de marcado XAML que establece un valor para una propiedad mediante la declaración de un atributo en un elemento de objeto existente.</span><span class="sxs-lookup"><span data-stu-id="a01cb-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="a01cb-158">El nombre del atributo debe coincidir con el nombre de miembro CLR de la propiedad de la clase que respalda el elemento de objeto relevante.</span><span class="sxs-lookup"><span data-stu-id="a01cb-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="a01cb-159">El nombre del atributo va seguido de un operador de asignación (-).</span><span class="sxs-lookup"><span data-stu-id="a01cb-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="a01cb-160">El valor del atributo debe ser una cadena entre comillas.</span><span class="sxs-lookup"><span data-stu-id="a01cb-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a01cb-161">Puede utilizar comillas alternas para colocar una comilla literal dentro de un atributo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="a01cb-162">Por ejemplo, puede utilizar comillas simples como medio para declarar una cadena que contiene un carácter de comillas dobles dentro de ella.</span><span class="sxs-lookup"><span data-stu-id="a01cb-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="a01cb-163">Si utiliza comillas simples o dobles, debe usar un par coincidente para abrir y cerrar la cadena de valor de atributo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="a01cb-164">También hay secuencias de escape u otras técnicas disponibles para evitar las restricciones de caracteres impuestas por cualquier sintaxis XAML en particular.</span><span class="sxs-lookup"><span data-stu-id="a01cb-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="a01cb-165">Consulte [Entidades de caracteres XML y XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span><span class="sxs-lookup"><span data-stu-id="a01cb-165">See [XML Character Entities and XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span></span>  
  
 <span data-ttu-id="a01cb-166">Para establecerse a través de la sintaxis de atributo, una propiedad debe ser pública y debe ser grabable.</span><span class="sxs-lookup"><span data-stu-id="a01cb-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="a01cb-167">El valor de la propiedad en el sistema de tipos de respaldo debe ser un tipo de valor o debe ser un tipo de referencia al que se pueda crear una instancia o al que haga referencia un procesador XAML al tener acceso al tipo de respaldo relevante.</span><span class="sxs-lookup"><span data-stu-id="a01cb-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="a01cb-168">Para los eventos XAML de WPF, el evento al que se hace referencia como el nombre del atributo debe ser público y tener un delegado público.</span><span class="sxs-lookup"><span data-stu-id="a01cb-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="a01cb-169">La propiedad o evento debe ser un miembro de la clase o estructura que crea una instancia del elemento de objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="a01cb-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="a01cb-170">Procesamiento de valores de atributo</span><span class="sxs-lookup"><span data-stu-id="a01cb-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="a01cb-171">Un procesador XAML procesa el valor de cadena contenido entre comillas de apertura y cierre.</span><span class="sxs-lookup"><span data-stu-id="a01cb-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="a01cb-172">Para las propiedades, el comportamiento de procesamiento predeterminado viene determinado por el tipo de la propiedad CLR subyacente.</span><span class="sxs-lookup"><span data-stu-id="a01cb-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="a01cb-173">El valor del atributo se rellena con una de las siguientes opciones, utilizando este orden de procesamiento:</span><span class="sxs-lookup"><span data-stu-id="a01cb-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="a01cb-174">Si el procesador XAML encuentra una llave o un elemento <xref:System.Windows.Markup.MarkupExtension>de objeto que deriva de , la extensión de marcado a la que se hace referencia se evalúa primero en lugar de procesar el valor como una cadena y el objeto devuelto por la extensión de marcado se usa como valor.</span><span class="sxs-lookup"><span data-stu-id="a01cb-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="a01cb-175">En muchos casos, el objeto devuelto por una extensión de marcado será una referencia a un objeto existente o una expresión que aplace la evaluación hasta el tiempo de ejecución y no sea un objeto recién creado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="a01cb-176">Si la propiedad se declara <xref:System.ComponentModel.TypeConverter>con un atributo o el tipo de <xref:System.ComponentModel.TypeConverter>valor de esa propiedad se declara con un atributo , el valor de cadena del atributo se envía al convertidor de tipos como una entrada de conversión y el convertidor devolverá una nueva instancia de objeto.</span><span class="sxs-lookup"><span data-stu-id="a01cb-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="a01cb-177">Si no <xref:System.ComponentModel.TypeConverter>hay , se intenta una conversión directa al tipo de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="a01cb-178">Este nivel final es una conversión directa en el valor nativo del analizador entre los tipos primitivos del lenguaje XAML, o una comprobación de los nombres de constantes con nombre en una enumeración (el analizador tiene acceso a los valores coincidentes).</span><span class="sxs-lookup"><span data-stu-id="a01cb-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="a01cb-179">Valores de atributo de enumeración</span><span class="sxs-lookup"><span data-stu-id="a01cb-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="a01cb-180">Las enumeraciones en XAML se procesan intrínsecamente por analizadores XAML y los miembros de una enumeración deben especificarse especificando el nombre de cadena de una de las constantes con nombre de la enumeración.</span><span class="sxs-lookup"><span data-stu-id="a01cb-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="a01cb-181">Para los valores de enumeración no marcados, el comportamiento nativo consiste en procesar la cadena de un valor de atributo y resolverlo en uno de los valores de enumeración.</span><span class="sxs-lookup"><span data-stu-id="a01cb-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="a01cb-182">No se especifica la enumeración en el formato *Enumeración*. *Valor*, como se hace en el código.</span><span class="sxs-lookup"><span data-stu-id="a01cb-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="a01cb-183">En su lugar, solo se especifica *Value*y *Enumeration* se deduce por el tipo de la propiedad que se va a establecer.</span><span class="sxs-lookup"><span data-stu-id="a01cb-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="a01cb-184">Si especifica un atributo en la *enumeración*. *Forma de valor,* no se resolverá correctamente.</span><span class="sxs-lookup"><span data-stu-id="a01cb-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="a01cb-185">Para las enumeraciones flagwise, el <xref:System.Enum.Parse%2A?displayProperty=nameWithType> comportamiento se basa en el método.</span><span class="sxs-lookup"><span data-stu-id="a01cb-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="a01cb-186">Puede especificar varios valores para una enumeración flagwise separando cada valor con una coma.</span><span class="sxs-lookup"><span data-stu-id="a01cb-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="a01cb-187">Sin embargo, no puede combinar valores de enumeración que no sean con marca.</span><span class="sxs-lookup"><span data-stu-id="a01cb-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="a01cb-188">Por ejemplo, no puede utilizar la sintaxis de coma para intentar crear un <xref:System.Windows.Trigger> que actúa en varias condiciones de una enumeración que no es de marca:</span><span class="sxs-lookup"><span data-stu-id="a01cb-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="a01cb-189">Las enumeraciones Flagwise que admiten atributos que se pueden establecer en XAML son poco frecuentes en WPFWPF.</span><span class="sxs-lookup"><span data-stu-id="a01cb-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="a01cb-190">Sin embargo, <xref:System.Windows.Media.StyleSimulations>una de estas enumeraciones es .</span><span class="sxs-lookup"><span data-stu-id="a01cb-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="a01cb-191">Por ejemplo, podría utilizar la sintaxis de atributo flagwise delimitada por comas para modificar el ejemplo proporcionado en Comentarios para la <xref:System.Windows.Documents.Glyphs> clase; `StyleSimulations = "BoldSimulation"` podría `StyleSimulations = "BoldSimulation,ItalicSimulation"`llegar a ser .</span><span class="sxs-lookup"><span data-stu-id="a01cb-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="a01cb-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType>es otra propiedad donde se puede especificar más de un valor de enumeración.</span><span class="sxs-lookup"><span data-stu-id="a01cb-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="a01cb-193">Sin embargo, esta propiedad resulta ser <xref:System.Windows.Input.ModifierKeys> un caso especial, porque la enumeración admite su propio convertidor de tipos.</span><span class="sxs-lookup"><span data-stu-id="a01cb-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="a01cb-194">El convertidor de tipos para modificadores utiliza un signo más (+) como delimitador en lugar de una coma (,).</span><span class="sxs-lookup"><span data-stu-id="a01cb-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="a01cb-195">Esta conversión admite la sintaxis más tradicional para representar combinaciones de teclas en la programación de Microsoft Windows, como "Ctrl+Alt".</span><span class="sxs-lookup"><span data-stu-id="a01cb-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="a01cb-196">Propiedades y referencias de nombre de miembro de evento</span><span class="sxs-lookup"><span data-stu-id="a01cb-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="a01cb-197">Al especificar un atributo, puede hacer referencia a cualquier propiedad o evento que exista como miembro del tipo CLR que ha creado una instancia para el elemento de objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="a01cb-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="a01cb-198">O bien, puede hacer referencia a una propiedad adjunta o un evento adjunto, independientemente del elemento de objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="a01cb-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="a01cb-199">(Las propiedades adjuntas se describen en una próxima sección.)</span><span class="sxs-lookup"><span data-stu-id="a01cb-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="a01cb-200">También puede asignar un nombre a cualquier evento de cualquier objeto al que se pueda acceder a través del espacio de nombres predeterminado mediante un *typeName*. nombre parcialmente calificado del *evento;* esta sintaxis admite la asociación de controladores para eventos enrutados donde el controlador está diseñado para controlar el enrutamiento de eventos desde elementos secundarios, pero el elemento primario no tiene también ese evento en su tabla members.</span><span class="sxs-lookup"><span data-stu-id="a01cb-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="a01cb-201">Esta sintaxis se asemeja a una sintaxis de evento adjunta, pero el evento aquí no es un evento adjunto verdadero.</span><span class="sxs-lookup"><span data-stu-id="a01cb-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="a01cb-202">En su lugar, hace referencia a un evento con un nombre completo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="a01cb-203">Para obtener más información, consulte [Información general sobre eventos enrutados](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="a01cb-203">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="a01cb-204">Para algunos escenarios, los nombres de propiedad a veces se proporcionan como el valor de un atributo, en lugar del nombre del atributo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="a01cb-205">Ese nombre de propiedad también puede incluir calificadores, como la propiedad especificada en el formulario *ownerType*. *dependencyPropertyName*.</span><span class="sxs-lookup"><span data-stu-id="a01cb-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="a01cb-206">Este escenario es común al escribir estilos o plantillas en XAML.</span><span class="sxs-lookup"><span data-stu-id="a01cb-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="a01cb-207">Las reglas de procesamiento para los nombres de propiedad proporcionados como un valor de atributo son diferentes y se rigen por el tipo de la propiedad que se establece o por los comportamientos de determinados subsistemas WPFWPF.</span><span class="sxs-lookup"><span data-stu-id="a01cb-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="a01cb-208">Para obtener más información, consulte [Estilo y plantillas](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span><span class="sxs-lookup"><span data-stu-id="a01cb-208">For details, see [Styling and Templating](../../../desktop-wpf/fundamentals/styles-templates-overview.md).</span></span>  
  
 <span data-ttu-id="a01cb-209">Otro uso de los nombres de propiedad es cuando un valor de atributo describe una relación propiedad-propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="a01cb-210">Esta característica se utiliza para el enlace de datos <xref:System.Windows.PropertyPath> y para destinos de guión gráfico, y está habilitada por la clase y su convertidor de tipos.</span><span class="sxs-lookup"><span data-stu-id="a01cb-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="a01cb-211">Para obtener una descripción más completa de la semántica de búsqueda, vea [Sintaxis XAML PropertyPath](propertypath-xaml-syntax.md).</span><span class="sxs-lookup"><span data-stu-id="a01cb-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>
## <a name="property-element-syntax"></a><span data-ttu-id="a01cb-212">Sintaxis de elementos de propiedad</span><span class="sxs-lookup"><span data-stu-id="a01cb-212">Property Element Syntax</span></span>  
 <span data-ttu-id="a01cb-213">*Sintaxis* de elemento de propiedad es una sintaxis que difiere un poco de las reglas de sintaxis XML básicas para los elementos.</span><span class="sxs-lookup"><span data-stu-id="a01cb-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="a01cb-214">En XML, el valor de un atributo es una cadena de facto, con la única variación posible es qué formato de codificación de cadena se está utilizando.</span><span class="sxs-lookup"><span data-stu-id="a01cb-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="a01cb-215">En XAML, puede asignar otros elementos de objeto para que sean el valor de una propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="a01cb-216">Esta funcionalidad está habilitada por la sintaxis del elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="a01cb-217">En lugar de especificar la propiedad como un atributo dentro de la etiqueta de elemento, la propiedad se especifica mediante una etiqueta de elemento de apertura en *elementTypeName*. *PropertyName* form, el valor de la propiedad se especifica dentro y, a continuación, se cierra el elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="a01cb-218">En concreto, la sintaxis comienza con\<un corchete angular izquierdo ( ), seguido inmediatamente por el nombre de tipo de la clase o estructura en la que se encuentra la sintaxis del elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="a01cb-219">Esto es seguido inmediatamente por un único punto (.), luego por el nombre de una propiedad y, a continuación, por un corchete de ángulo recto (>).</span><span class="sxs-lookup"><span data-stu-id="a01cb-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="a01cb-220">Al igual que con la sintaxis de atributo, esa propiedad debe existir dentro de los miembros públicos declarados del tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="a01cb-221">El valor que se asignará a la propiedad se encuentra dentro del elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="a01cb-222">Normalmente, el valor se proporciona como uno o varios elementos de objeto, porque especificar objetos como valores es el escenario que la sintaxis del elemento de propiedad está diseñada para abordar.</span><span class="sxs-lookup"><span data-stu-id="a01cb-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="a01cb-223">Por último, una etiqueta de cierre equivalente que especifica el mismo *elementTypeName*. Se debe proporcionar una combinación *propertyName,* en el anidamiento adecuado y el equilibrio con otras etiquetas de elemento.</span><span class="sxs-lookup"><span data-stu-id="a01cb-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="a01cb-224">Por ejemplo, la siguiente es <xref:System.Windows.FrameworkElement.ContextMenu%2A> la sintaxis de elemento de propiedad para la propiedad de un <xref:System.Windows.Controls.Button>archivo .</span><span class="sxs-lookup"><span data-stu-id="a01cb-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="a01cb-225">El valor dentro de un elemento de propiedad también se puede dar como texto interno, <xref:System.String>en los casos en que el tipo de propiedad que se especifica es un tipo de valor primitivo, como , o una enumeración donde se especifica un nombre.</span><span class="sxs-lookup"><span data-stu-id="a01cb-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="a01cb-226">Estos dos usos son algo poco comunes, porque cada uno de estos casos también podría usar una sintaxis de atributo más simple.</span><span class="sxs-lookup"><span data-stu-id="a01cb-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="a01cb-227">Un escenario para rellenar un elemento de propiedad con una cadena es para las propiedades que no son la propiedad de contenido XAML pero todavía se usan para la representación del texto de la interfaz de usuario, y determinados elementos de espacio en blanco como sfines deben aparecer en ese texto de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="a01cb-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="a01cb-228">La sintaxis de atributo no puede conservar sellos de línea, pero la sintaxis de elementos de propiedad puede, siempre y cuando la conservación de espacios en blanco significativa esté activa (para obtener más información, vea Procesamiento de [espacio en blanco en XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span><span class="sxs-lookup"><span data-stu-id="a01cb-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span></span> <span data-ttu-id="a01cb-229">Otro escenario es para que [x:Uid Directiva](../../../desktop-wpf/xaml-services/xuid-directive.md) se puede aplicar al elemento de propiedad y, por lo tanto, marcar el valor dentro como un valor que se debe localizar en el WPFWPF salida BAML o por otras técnicas.</span><span class="sxs-lookup"><span data-stu-id="a01cb-229">Another scenario is so that [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="a01cb-230">Un elemento de propiedad no se representa en el árbol lógico WPFWPF.</span><span class="sxs-lookup"><span data-stu-id="a01cb-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="a01cb-231">Un elemento de propiedad es solo una sintaxis determinada para establecer una propiedad y no es un elemento que tiene una instancia u objeto que la respalda.</span><span class="sxs-lookup"><span data-stu-id="a01cb-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="a01cb-232">(Para obtener más información sobre el concepto de árbol lógico, vea [árboles en WPFWPF](trees-in-wpf.md).)</span><span class="sxs-lookup"><span data-stu-id="a01cb-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="a01cb-233">Para las propiedades donde se admite la sintaxis de atributo y elemento de propiedad, las dos sintaxis suelen tener el mismo resultado, aunque las sutilezas, como el control de espacios en blanco, pueden variar ligeramente entre las sintaxis.</span><span class="sxs-lookup"><span data-stu-id="a01cb-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>
## <a name="collection-syntax"></a><span data-ttu-id="a01cb-234">Sintaxis de colecciones</span><span class="sxs-lookup"><span data-stu-id="a01cb-234">Collection Syntax</span></span>  
 <span data-ttu-id="a01cb-235">La especificación XAML requiere implementaciones de procesador XAML para identificar las propiedades donde el tipo de valor es una colección.</span><span class="sxs-lookup"><span data-stu-id="a01cb-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="a01cb-236">La implementación general del procesador XAML en .NET se basa en código administrado y CLR, e identifica los tipos de colección a través de uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="a01cb-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="a01cb-237">Implementaciones <xref:System.Collections.IList>de tipo .</span><span class="sxs-lookup"><span data-stu-id="a01cb-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="a01cb-238">Implementaciones <xref:System.Collections.IDictionary>de tipo .</span><span class="sxs-lookup"><span data-stu-id="a01cb-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="a01cb-239">Tipo deriva <xref:System.Array> de (para obtener más información acerca de las matrices en XAML, vea [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span><span class="sxs-lookup"><span data-stu-id="a01cb-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="a01cb-240">Si el tipo de una propiedad es una colección, no es necesario especificar el tipo de colección deduducto en el marcado como un elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="a01cb-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="a01cb-241">En su lugar, los elementos que están diseñados para convertirse en los elementos de la colección se especifican como uno o varios elementos secundarios del elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="a01cb-242">Cada elemento de este tipo se evalúa en un objeto `Add` durante la carga y se agrega a la colección mediante una llamada al método de la colección implícita.</span><span class="sxs-lookup"><span data-stu-id="a01cb-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="a01cb-243">Por ejemplo, <xref:System.Windows.Style.Triggers%2A> la <xref:System.Windows.Style> propiedad de toma <xref:System.Windows.TriggerCollection>el tipo <xref:System.Collections.IList>de colección especializada , que implementa .</span><span class="sxs-lookup"><span data-stu-id="a01cb-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="a01cb-244">No es necesario crear <xref:System.Windows.TriggerCollection> una instancia de un elemento de objeto en el marcado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="a01cb-245">En su lugar, <xref:System.Windows.Trigger> especifique uno o `Style.Triggers` varios elementos como elementos dentro del elemento de propiedad, donde <xref:System.Windows.Trigger> (o <xref:System.Windows.TriggerCollection>una clase derivada) es el tipo esperado como el tipo de elemento para el fuertemente tipado e implícito .</span><span class="sxs-lookup"><span data-stu-id="a01cb-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="a01cb-246">Una propiedad puede ser un tipo de colección y la propiedad de contenido XAML para ese tipo y tipos derivados, que se describe en la siguiente sección de este tema.</span><span class="sxs-lookup"><span data-stu-id="a01cb-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="a01cb-247">Un elemento de colección implícita crea un miembro en la representación de árbol lógico, aunque no aparece en el marcado como un elemento.</span><span class="sxs-lookup"><span data-stu-id="a01cb-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="a01cb-248">Normalmente, el constructor del tipo primario realiza la creación de instancias de la colección que es una de sus propiedades y la colección inicialmente vacía pasa a formar parte del árbol de objetos.</span><span class="sxs-lookup"><span data-stu-id="a01cb-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="a01cb-249">Las interfaces genéricas<xref:System.Collections.Generic.IList%601> de <xref:System.Collections.Generic.IDictionary%602>lista y diccionario ( y ) no se admiten para la detección de colecciones.</span><span class="sxs-lookup"><span data-stu-id="a01cb-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="a01cb-250">Sin embargo, <xref:System.Collections.Generic.List%601> puede usar la clase como <xref:System.Collections.IList> una clase <xref:System.Collections.Generic.Dictionary%602> base, porque se implementa <xref:System.Collections.IDictionary> directamente, o como una clase base, porque se implementa directamente.</span><span class="sxs-lookup"><span data-stu-id="a01cb-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="a01cb-251">En las páginas de referencia de .NET para tipos de colección, esta sintaxis con la omisión deliberada del elemento de objeto para una colección se observa ocasionalmente en las secciones de sintaxis XAML como sintaxis de colección implícita.</span><span class="sxs-lookup"><span data-stu-id="a01cb-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="a01cb-252">Con la excepción del elemento raíz, cada elemento de objeto de un archivo XAML anidado como un elemento secundario de otro elemento es realmente un elemento que es uno o ambos de los siguientes casos: un miembro de una propiedad de colección implícita de su elemento primario o un elemento que especifica el valor de la propiedad de contenido XAML para el elemento primario (las propiedades de contenido XAML se tratarán en una sección próxima).</span><span class="sxs-lookup"><span data-stu-id="a01cb-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="a01cb-253">En otras palabras, la relación de los elementos primarios y secundarios en una página de marcado es realmente un único objeto en la raíz y cada elemento de objeto debajo de la raíz es una única instancia que proporciona un valor de propiedad del elemento primario o uno de los elementos de una colección que también es un valor de propiedad de tipo de colección del elemento primario.</span><span class="sxs-lookup"><span data-stu-id="a01cb-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="a01cb-254">Este concepto de raíz única es común con XML y se refuerza con <xref:System.Windows.Markup.XamlReader.Load%2A>frecuencia en el comportamiento de las API que cargan XAML como .</span><span class="sxs-lookup"><span data-stu-id="a01cb-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="a01cb-255">El ejemplo siguiente es una sintaxis con<xref:System.Windows.Media.GradientStopCollection>el elemento object para una colección ( ) especificada explícitamente.</span><span class="sxs-lookup"><span data-stu-id="a01cb-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="a01cb-256">Tenga en cuenta que no siempre es posible declarar explícitamente la colección.</span><span class="sxs-lookup"><span data-stu-id="a01cb-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="a01cb-257">Por ejemplo, se <xref:System.Windows.TriggerCollection> produciría un error <xref:System.Windows.Style.Triggers%2A> al intentar declarar explícitamente en el ejemplo mostrado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="a01cb-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="a01cb-258">Declarar explícitamente la colección requiere que la clase de <xref:System.Windows.TriggerCollection> colección debe admitir un constructor sin parámetros y no tiene un constructor sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="a01cb-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>
## <a name="xaml-content-properties"></a><span data-ttu-id="a01cb-259">Propiedades del contenido XAML</span><span class="sxs-lookup"><span data-stu-id="a01cb-259">XAML Content Properties</span></span>  
 <span data-ttu-id="a01cb-260">Sintaxis de contenido XAML es una sintaxis <xref:System.Windows.Markup.ContentPropertyAttribute> que solo está habilitada en las clases que especifican como parte de su declaración de clase.</span><span class="sxs-lookup"><span data-stu-id="a01cb-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="a01cb-261">Hace <xref:System.Windows.Markup.ContentPropertyAttribute> referencia al nombre de propiedad que es la propiedad content para ese tipo de elemento (incluidas las clases derivadas).</span><span class="sxs-lookup"><span data-stu-id="a01cb-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="a01cb-262">Cuando se procesa mediante un procesador XAML, los elementos secundarios o texto interno que se encuentran entre las etiquetas de apertura y cierre del elemento de objeto se asignarán para que sean el valor de la propiedad de contenido XAML para ese objeto.</span><span class="sxs-lookup"><span data-stu-id="a01cb-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="a01cb-263">Se le permite especificar elementos de propiedad explícitos para la propiedad content, pero este uso no se muestra generalmente en las secciones de sintaxis XAML de la referencia de .NET.</span><span class="sxs-lookup"><span data-stu-id="a01cb-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="a01cb-264">La técnica explícita/detallada tiene un valor ocasional para la claridad del marcado o como una cuestión de estilo de marcado, pero normalmente la intención de una propiedad de contenido es simplificar el marcado para que los elementos que están relacionados intuitivamente como elementos primarios y secundarios se pueden anidar directamente.</span><span class="sxs-lookup"><span data-stu-id="a01cb-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="a01cb-265">Las etiquetas de elemento de propiedad para otras propiedades de un elemento no se asignan como "contenido" según una definición de lenguaje XAML estricta; se procesan previamente en el orden de procesamiento del analizador XAML y no se consideran "contenido".</span><span class="sxs-lookup"><span data-stu-id="a01cb-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="a01cb-266">Los valores de propiedad de contenido XAML deben ser contiguos</span><span class="sxs-lookup"><span data-stu-id="a01cb-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="a01cb-267">El valor de una propiedad de contenido XAML debe darse completamente antes o completamente después de cualquier otro elemento de propiedad en ese elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="a01cb-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="a01cb-268">Esto es cierto si el valor de una propiedad de contenido XAML se especifica como una cadena o como uno o varios objetos.</span><span class="sxs-lookup"><span data-stu-id="a01cb-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="a01cb-269">Por ejemplo, el siguiente marcado no analiza:</span><span class="sxs-lookup"><span data-stu-id="a01cb-269">For example, the following markup does not parse:</span></span>  
  
```xaml  
<Button>I am a
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="a01cb-270">Esto es ilegal esencialmente porque si esta sintaxis se hizo explícita mediante el uso de sintaxis de elemento de propiedad para la propiedad content, la propiedad content se establecería dos veces:</span><span class="sxs-lookup"><span data-stu-id="a01cb-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="a01cb-271">Un ejemplo igualmente ilegal es si la propiedad content es una colección y los elementos secundarios se intercalan con elementos de propiedad:</span><span class="sxs-lookup"><span data-stu-id="a01cb-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="a01cb-272">Propiedades de contenido y sintaxis de colección combinadas</span><span class="sxs-lookup"><span data-stu-id="a01cb-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="a01cb-273">Para aceptar más de un único elemento de objeto como contenido, el tipo de la propiedad content debe ser específicamente un tipo de colección.</span><span class="sxs-lookup"><span data-stu-id="a01cb-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="a01cb-274">De forma similar a la sintaxis de elemento de propiedad para los tipos de colección, un procesador XAML debe identificar los tipos que son tipos de colección.</span><span class="sxs-lookup"><span data-stu-id="a01cb-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="a01cb-275">Si un elemento tiene una propiedad de contenido XAML y el tipo de la propiedad de contenido XAML es una colección, no es necesario especificar el tipo de colección implícita en el marcado como un elemento de objeto y no es necesario especificar la propiedad de contenido XAML como un elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="a01cb-276">Por lo tanto, el modelo de contenido aparente en el marcado ahora puede tener más de un elemento secundario asignado como contenido.</span><span class="sxs-lookup"><span data-stu-id="a01cb-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="a01cb-277">A continuación se muestra <xref:System.Windows.Controls.Panel> la sintaxis de contenido para una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="a01cb-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="a01cb-278">Todas <xref:System.Windows.Controls.Panel> las clases derivadas establecen <xref:System.Windows.Controls.Panel.Children%2A>la propiedad de contenido <xref:System.Windows.Controls.UIElementCollection>XAML , que requiere un valor de tipo .</span><span class="sxs-lookup"><span data-stu-id="a01cb-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="a01cb-279">Tenga en cuenta que <xref:System.Windows.Controls.Panel.Children%2A> ni el <xref:System.Windows.Controls.UIElementCollection> elemento de propiedad para ni el elemento para el es necesario en el marcado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="a01cb-280">Se trata de una característica de diseño de XAML [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] para que los elementos contenidos recursivamente que definen a se representan de forma más intuitiva como un árbol de elementos anidados con relaciones de elementos primarios y secundarios inmediatas, sin intervenir etiquetas de elementos de propiedad u objetos de colección.</span><span class="sxs-lookup"><span data-stu-id="a01cb-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="a01cb-281">De hecho, <xref:System.Windows.Controls.UIElementCollection> no se puede especificar explícitamente en el marcado como un elemento de objeto, por diseño.</span><span class="sxs-lookup"><span data-stu-id="a01cb-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="a01cb-282">Dado que su único uso previsto <xref:System.Windows.Controls.UIElementCollection> es como una colección implícita, no expone un constructor público sin parámetros y, por lo tanto, no se puede crear una instancia como un elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="a01cb-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="a01cb-283">Mezcla de elementos de propiedad y elementos de objeto en un objeto con una propiedad Content</span><span class="sxs-lookup"><span data-stu-id="a01cb-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="a01cb-284">La especificación XAML declara que un procesador XAML puede exigir que los elementos de objeto que se usan para rellenar la propiedad de contenido XAML dentro de un elemento de objeto deben ser contiguos y no se deben mezclar.</span><span class="sxs-lookup"><span data-stu-id="a01cb-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="a01cb-285">Los procesadores [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML aplican esta restricción para mezclar elementos de propiedad y contenido.</span><span class="sxs-lookup"><span data-stu-id="a01cb-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="a01cb-286">Puede tener un elemento de objeto secundario como el primer marcado inmediato dentro de un elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="a01cb-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="a01cb-287">A continuación, puede introducir elementos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-287">Then you can introduce property elements.</span></span> <span data-ttu-id="a01cb-288">O bien, puede especificar uno o varios elementos de propiedad, a continuación, el contenido y, a continuación, más elementos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="a01cb-289">Pero una vez que un elemento de propiedad sigue el contenido, no puede introducir más contenido, solo puede agregar elementos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="a01cb-290">Este requisito de orden de elemento de contenido /propiedad no se aplica al texto interno utilizado como contenido.</span><span class="sxs-lookup"><span data-stu-id="a01cb-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="a01cb-291">Sin embargo, sigue siendo un buen estilo de marcado para mantener el texto interno contiguo, porque un espacio en blanco significativo será difícil de detectar visualmente en el marcado si los elementos de propiedad se intercalan con el texto interno.</span><span class="sxs-lookup"><span data-stu-id="a01cb-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>
## <a name="xaml-namespaces"></a><span data-ttu-id="a01cb-292">Espacios de nombres XAML</span><span class="sxs-lookup"><span data-stu-id="a01cb-292">XAML Namespaces</span></span>  
 <span data-ttu-id="a01cb-293">Ninguno de los ejemplos de sintaxis anteriores especificó un espacio de nombres XAML distinto del espacio de nombres XAML predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="a01cb-294">En [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] las aplicaciones típicas, se especifica [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] que el espacio de nombres XAML predeterminado es el espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="a01cb-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="a01cb-295">Puede especificar espacios de nombres XAML distintos del espacio de nombres XAML predeterminado y seguir usando una sintaxis similar.</span><span class="sxs-lookup"><span data-stu-id="a01cb-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="a01cb-296">Pero, a continuación, en cualquier lugar donde se nombra una clase que no es accesible dentro del espacio de nombres XAML predeterminado, ese nombre de clase debe ir precedido por el prefijo del espacio de nombres XAML tal como se asigna al espacio de nombres CLR correspondiente.</span><span class="sxs-lookup"><span data-stu-id="a01cb-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="a01cb-297">Por ejemplo, `<custom:Example/>` es sintaxis de elemento `Example` de objeto para crear instancias de una instancia de la clase, donde `custom` el espacio de nombres CLR que contiene esa clase (y posiblemente la información de ensamblado externo que contiene tipos de respaldo) se asignó previamente al prefijo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="a01cb-298">Para obtener más información acerca de los espacios de nombres XAML, vea [Espacios de nombres XAML y Asignación](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)de espacios de nombres para XAML de WPF .</span><span class="sxs-lookup"><span data-stu-id="a01cb-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>
## <a name="markup-extensions"></a><span data-ttu-id="a01cb-299">Extensiones de marcado</span><span class="sxs-lookup"><span data-stu-id="a01cb-299">Markup Extensions</span></span>  
 <span data-ttu-id="a01cb-300">XAML define una entidad de programación de extensión de marcado que habilita un escape del control normal del procesador XAML de valores de atributo de cadena o elementos de objeto y aplaza el procesamiento a una clase de respaldo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="a01cb-301">El carácter que identifica una extensión de marcado a un procesador XAML cuando se usa la sintaxis de atributo es la llave de apertura (-), seguida de cualquier carácter que no sea una llave de cierre ( .</span><span class="sxs-lookup"><span data-stu-id="a01cb-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="a01cb-302">La primera cadena que sigue a la llave de apertura debe hacer referencia a la clase que proporciona el comportamiento de extensión determinado, donde la referencia puede omitir la subcadena "Extension" si esa subcadena forma parte del nombre de clase true.</span><span class="sxs-lookup"><span data-stu-id="a01cb-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="a01cb-303">A partir de entonces, puede aparecer un único espacio y, a continuación, la implementación de la extensión utiliza cada carácter sucesivo como entrada, hasta que se encuentra la llave de cierre.</span><span class="sxs-lookup"><span data-stu-id="a01cb-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="a01cb-304">La implementación XAML <xref:System.Windows.Markup.MarkupExtension> de .NET usa la clase abstracta [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] como base para todas las extensiones de marcado admitidas por otros marcos o tecnologías.</span><span class="sxs-lookup"><span data-stu-id="a01cb-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="a01cb-305">Las extensiones [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] de marcado que implementan específicamente a menudo están diseñadas para proporcionar un medio para hacer referencia a otros objetos existentes o para hacer referencias diferidas a objetos que se evaluarán en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="a01cb-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="a01cb-306">Por ejemplo, un simple WPFWPF enlace `{Binding}` de datos se realiza mediante la especificación de la extensión de marcado en lugar del valor que una propiedad determinada normalmente tomaría.</span><span class="sxs-lookup"><span data-stu-id="a01cb-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="a01cb-307">Muchas de las extensiones de marcado WPFWPF habilitan una sintaxis de atributo para las propiedades en las que una sintaxis de atributo no sería posible de otro modo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="a01cb-308">Por ejemplo, <xref:System.Windows.Style> un objeto es un tipo relativamente complejo que contiene una serie anidada de objetos y propiedades.</span><span class="sxs-lookup"><span data-stu-id="a01cb-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="a01cb-309">Los estilos de WPFWPF se <xref:System.Windows.ResourceDictionary>definen normalmente como un recurso en un archivo , y, a continuación, se hace referencia a través de una de las dos extensiones de marcado de WPFWPF que solicitan un recurso.</span><span class="sxs-lookup"><span data-stu-id="a01cb-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="a01cb-310">La extensión de marcado aplaza la evaluación del valor de propiedad <xref:System.Windows.FrameworkElement.Style%2A> a una <xref:System.Windows.Style>búsqueda de recursos y permite proporcionar el valor de la propiedad, tomando el tipo , en la sintaxis de atributo como en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="a01cb-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="a01cb-311">Aquí, `StaticResource` identifica <xref:System.Windows.StaticResourceExtension> la clase que proporciona la implementación de extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="a01cb-312">La siguiente `MyStyle` cadena se utiliza como entrada <xref:System.Windows.StaticResourceExtension> para el constructor no predeterminado, donde el <xref:System.Windows.ResourceKey>parámetro tomado de la cadena de extensión declara el solicitado .</span><span class="sxs-lookup"><span data-stu-id="a01cb-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="a01cb-313">`MyStyle`se espera que sea el valor <xref:System.Windows.Style> [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) de un definido como recurso.</span><span class="sxs-lookup"><span data-stu-id="a01cb-313">`MyStyle` is expected to be the [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="a01cb-314">El uso de la extensión de [marcado StaticResource](staticresource-markup-extension.md) solicita que el recurso se use para proporcionar el <xref:System.Windows.Style> valor de propiedad a través de la lógica de búsqueda de recursos estáticos en tiempo de carga.</span><span class="sxs-lookup"><span data-stu-id="a01cb-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="a01cb-315">Para más información sobre las extensiones de marcado, consulte [Extensiones de marcado y XAML de WPF](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="a01cb-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="a01cb-316">Para obtener una referencia de extensiones de marcado y otras características de programación XAML habilitadas en la implementación XAML general de .NET, vea [Espacio de nombres XAML (x:) Características del idioma](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="a01cb-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="a01cb-317">Para las extensiones de marcado específicas de WPF, vea [Extensiones XAML de WPF](wpf-xaml-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="a01cb-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>
## <a name="attached-properties"></a><span data-ttu-id="a01cb-318">Propiedades asociadas</span><span class="sxs-lookup"><span data-stu-id="a01cb-318">Attached Properties</span></span>  
 <span data-ttu-id="a01cb-319">Las propiedades adjuntas son un concepto de programación introducido en XAML mediante el cual las propiedades pueden ser propiedad de un tipo determinado y definirse como atributos o elementos de propiedad en cualquier elemento.</span><span class="sxs-lookup"><span data-stu-id="a01cb-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="a01cb-320">El escenario principal para el que están diseñadas las propiedades adjuntas es permitir que los elementos secundarios de una estructura de marcado notifiquen información a un elemento primario sin necesidad de un modelo de objetos ampliamente compartido en todos los elementos.</span><span class="sxs-lookup"><span data-stu-id="a01cb-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="a01cb-321">Por el contrario, los elementos primarios pueden usar las propiedades adjuntas para notificar información a los elementos secundarios.</span><span class="sxs-lookup"><span data-stu-id="a01cb-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="a01cb-322">Para obtener más información sobre el propósito de las propiedades adjuntas y cómo crear sus propias propiedades adjuntas, vea Información general sobre [propiedades adjuntas](attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="a01cb-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="a01cb-323">Las propiedades adjuntas utilizan una sintaxis que se asemeja superficialmente a la sintaxis del elemento de propiedad, ya que también se especifica un *typeName*. *combinación propertyName.*</span><span class="sxs-lookup"><span data-stu-id="a01cb-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="a01cb-324">Hay dos diferencias importantes:</span><span class="sxs-lookup"><span data-stu-id="a01cb-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="a01cb-325">Puede usar *typeName*. *combinación propertyName* incluso al establecer una propiedad adjunta a través de la sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="a01cb-326">Las propiedades adjuntas son el único caso en el que calificar el nombre de propiedad es un requisito en una sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="a01cb-327">También puede utilizar la sintaxis de elemento de propiedad para las propiedades adjuntas.</span><span class="sxs-lookup"><span data-stu-id="a01cb-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="a01cb-328">Sin embargo, para la sintaxis de elemento de propiedad típica, *typeName* que especifique es el elemento de objeto que contiene el elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="a01cb-329">Si hace referencia a una propiedad adjunta, *typeName* es la clase que define la propiedad adjunta, no el elemento de objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="a01cb-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>
## <a name="attached-events"></a><span data-ttu-id="a01cb-330">Eventos asociados</span><span class="sxs-lookup"><span data-stu-id="a01cb-330">Attached Events</span></span>  
 <span data-ttu-id="a01cb-331">Los eventos adjuntos son otro concepto de programación introducido en XAML donde los eventos se pueden definir por un tipo específico, pero los controladores se pueden adjuntar en cualquier elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="a01cb-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="a01cb-332">En la implementación WOF, a menudo el tipo que define un evento adjunto es un tipo estático que define un servicio y, a veces, esos eventos adjuntos se exponen mediante un alias de evento enrutado en tipos que exponen el servicio.</span><span class="sxs-lookup"><span data-stu-id="a01cb-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="a01cb-333">Los controladores de eventos adjuntos se especifican mediante la sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="a01cb-334">Al igual que con los eventos adjuntos, la sintaxis de atributo se expande para los eventos adjuntos para permitir un *typeName*. *eventName* usage, donde *typeName* es `Add` `Remove` la clase que proporciona y descriptores de acceso de controlador de eventos para la infraestructura de eventos adjunta y *eventName* es el nombre del evento.</span><span class="sxs-lookup"><span data-stu-id="a01cb-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="a01cb-335">Anatomía de un elemento raíz XAML</span><span class="sxs-lookup"><span data-stu-id="a01cb-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="a01cb-336">En la tabla siguiente se muestra un elemento raíz XAML típico desglosado, que muestra los atributos específicos de un elemento raíz:</span><span class="sxs-lookup"><span data-stu-id="a01cb-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="a01cb-337">Abrir el elemento de objeto del elemento raíz</span><span class="sxs-lookup"><span data-stu-id="a01cb-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="a01cb-338">El espacio[!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]de nombres XAML predeterminado ( )</span><span class="sxs-lookup"><span data-stu-id="a01cb-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="a01cb-339">El espacio de nombres XAML del lenguaje XAML</span><span class="sxs-lookup"><span data-stu-id="a01cb-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="a01cb-340">La declaración de clase parcial que conecta el marcado con cualquier código subyacente definido para la clase parcial</span><span class="sxs-lookup"><span data-stu-id="a01cb-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="a01cb-341">Fin del elemento object para la raíz.</span><span class="sxs-lookup"><span data-stu-id="a01cb-341">End of object element for the root.</span></span> <span data-ttu-id="a01cb-342">El objeto aún no está cerrado porque el elemento contiene elementos secundarios</span><span class="sxs-lookup"><span data-stu-id="a01cb-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="a01cb-343">Usos XAML opcionales y no recomendados</span><span class="sxs-lookup"><span data-stu-id="a01cb-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="a01cb-344">En las secciones siguientes se describen los usos de XAML que son técnicamente compatibles con los procesadores XAML, pero que producen detalles u otros problemas estéticos que interfieren con los archivos XAML que siguen siendo legibles al desarrollar aplicaciones que contienen orígenes XAML.</span><span class="sxs-lookup"><span data-stu-id="a01cb-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="a01cb-345">Usos opcionales de elementos de propiedad</span><span class="sxs-lookup"><span data-stu-id="a01cb-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="a01cb-346">Los usos de elementos de propiedad opcionales incluyen escribir explícitamente las propiedades de contenido de elemento que el procesador XAML considera implícitas.</span><span class="sxs-lookup"><span data-stu-id="a01cb-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="a01cb-347">Por ejemplo, al declarar el <xref:System.Windows.Controls.Menu>contenido de un , <xref:System.Windows.Controls.ItemsControl.Items%2A> puede optar <xref:System.Windows.Controls.Menu> por `<Menu.Items>` declarar explícitamente la <xref:System.Windows.Controls.MenuItem> `<Menu.Items>`colección de la etiqueta de elemento de <xref:System.Windows.Controls.Menu> propiedad como <xref:System.Windows.Controls.MenuItem> y colocar <xref:System.Windows.Controls.ItemsControl.Items%2A> cada uno dentro de , en lugar de usar el comportamiento de procesador XAML implícito que todos los elementos secundarios de a deben ser y se colocan en la colección.</span><span class="sxs-lookup"><span data-stu-id="a01cb-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="a01cb-348">A veces, los usos opcionales pueden ayudar a aclarar visualmente la estructura del objeto como se representa en el marcado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="a01cb-349">O a veces un uso explícito de elementos de propiedad puede evitar el marcado que es técnicamente funcional pero visualmente confuso, como extensiones de marcado anidadas dentro de un valor de atributo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="a01cb-350">Atributos calificados typeName.memberName completos</span><span class="sxs-lookup"><span data-stu-id="a01cb-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="a01cb-351">El *typeName*. *memberName* form para un atributo realmente funciona de forma más universal que solo el caso de evento enrutado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="a01cb-352">Pero en otras situaciones que la forma es superflua y debe evitarlo, aunque sólo sea por razones de estilo de marcado y legibilidad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="a01cb-353">En el ejemplo siguiente, cada una <xref:System.Windows.Controls.Control.Background%2A> de las tres referencias al atributo son completamente equivalentes:</span><span class="sxs-lookup"><span data-stu-id="a01cb-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="a01cb-354">`Button.Background`funciona porque la búsqueda calificada <xref:System.Windows.Controls.Button> para<xref:System.Windows.Controls.Control.Background%2A> esa propiedad en <xref:System.Windows.Controls.Button> es correcta (se heredó de Control) y es la clase del elemento de objeto o una clase base.</span><span class="sxs-lookup"><span data-stu-id="a01cb-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="a01cb-355">`Control.Background`funciona porque <xref:System.Windows.Controls.Control> la <xref:System.Windows.Controls.Control.Background%2A> clase <xref:System.Windows.Controls.Control> realmente <xref:System.Windows.Controls.Button> define y es una clase base.</span><span class="sxs-lookup"><span data-stu-id="a01cb-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="a01cb-356">Sin embargo, el siguiente *typeName*. *memberName* form example does not work and thus is shown commented:</span><span class="sxs-lookup"><span data-stu-id="a01cb-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="a01cb-357"><xref:System.Windows.Controls.Label>es otra clase <xref:System.Windows.Controls.Control>derivada de , y `Label.Background` si <xref:System.Windows.Controls.Label> hubiera especificado dentro de un elemento de objeto, este uso habría funcionado.</span><span class="sxs-lookup"><span data-stu-id="a01cb-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="a01cb-358">Sin <xref:System.Windows.Controls.Label> embargo, dado que no <xref:System.Windows.Controls.Button>es la clase o clase `Label.Background` base de , el comportamiento del procesador XAML especificado es procesar como una propiedad adjunta.</span><span class="sxs-lookup"><span data-stu-id="a01cb-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="a01cb-359">`Label.Background`no es una propiedad adjunta disponible y se produce un error en este uso.</span><span class="sxs-lookup"><span data-stu-id="a01cb-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="a01cb-360">elementos de propiedad baseTypeName.memberName</span><span class="sxs-lookup"><span data-stu-id="a01cb-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="a01cb-361">De forma análoga a cómo *typeName*. *memberName* form funciona para la sintaxis de atributo, *un baseTypeName*. La sintaxis *memberName* funciona para la sintaxis de elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="a01cb-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="a01cb-362">Por ejemplo, la sintaxis siguiente funciona:</span><span class="sxs-lookup"><span data-stu-id="a01cb-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="a01cb-363">Aquí, el elemento de `Control.Background` propiedad se dio como `Button`aunque el elemento de propiedad estaba contenido en .</span><span class="sxs-lookup"><span data-stu-id="a01cb-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="a01cb-364">Pero al igual que *typeName*. *memberName* form for attributes, *baseTypeName*. *memberName* es un estilo deficiente en el marcado y debe evitarlo.</span><span class="sxs-lookup"><span data-stu-id="a01cb-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="a01cb-365">Consulte también</span><span class="sxs-lookup"><span data-stu-id="a01cb-365">See also</span></span>

- [<span data-ttu-id="a01cb-366">Información general sobre XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="a01cb-366">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="a01cb-367">Espacio de nombres de XAML (x:) Características del lenguaje</span><span class="sxs-lookup"><span data-stu-id="a01cb-367">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="a01cb-368">Extensiones XAML de WPF</span><span class="sxs-lookup"><span data-stu-id="a01cb-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="a01cb-369">Información general sobre las propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="a01cb-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="a01cb-370">Clases TypeConverter y XAML</span><span class="sxs-lookup"><span data-stu-id="a01cb-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="a01cb-371">Clases XAML y personalizadas para WPF</span><span class="sxs-lookup"><span data-stu-id="a01cb-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
