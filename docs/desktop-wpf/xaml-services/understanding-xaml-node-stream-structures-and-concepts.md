---
title: Introducción a las estructuras y conceptos de secuencias de nodo XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML node streams [XAML Services]
- nodes [XAML Services], XAML node stream
- XAML [XAML Services], XAML node streams
ms.assetid: 7c11abec-1075-474c-9d9b-778e5dab21c3
ms.openlocfilehash: b3de3dca029c5e676fc7cdebc7735cfdade0228a
ms.sourcegitcommit: c2d9718996402993cf31541f11e95531bc68bad0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/27/2020
ms.locfileid: "81432861"
---
# <a name="xaml-node-stream-structures-and-concepts"></a><span data-ttu-id="62338-102">Estructuras y conceptos de flujo de nodo XAML</span><span class="sxs-lookup"><span data-stu-id="62338-102">XAML node stream structures and concepts</span></span>

<span data-ttu-id="62338-103">Los lectores XAML y los escritores XAML implementados en los servicios XAML de .NET se basan en el concepto de diseño de un flujo de nodo XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-103">XAML readers and XAML writers as implemented in .NET XAML Services are based on the design concept of a XAML node stream.</span></span> <span data-ttu-id="62338-104">El flujo de nodo XAML es una conceptualización de un conjunto de nodos XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-104">The XAML node stream is a conceptualization of a set of XAML nodes.</span></span> <span data-ttu-id="62338-105">En esta conceptualización, un procesador XAML recorre la estructura de las relaciones de nodo en el XAML de cada vez.</span><span class="sxs-lookup"><span data-stu-id="62338-105">In this conceptualization, a XAML processor walks through the structure of the node relationships in the XAML one at a time.</span></span> <span data-ttu-id="62338-106">En todo momento, solo existe un registro o posición actuales en un flujo de nodo XAML abierto, y muchos aspectos de la API informan únicamente sobre la información disponible en esa posición.</span><span class="sxs-lookup"><span data-stu-id="62338-106">At any time, only one current record or current position exists in an open XAML node stream, and many aspects of the API report only the information available from that position.</span></span> <span data-ttu-id="62338-107">El nodo actual en un flujo de nodo XAML se puede describir como un objeto, un miembro o un valor.</span><span class="sxs-lookup"><span data-stu-id="62338-107">The current node in a XAML node stream can be described as being an object, a member, or a value.</span></span> <span data-ttu-id="62338-108">Al tratar XAML como un flujo de nodo XAML, los lectores XAML pueden comunicarse con escritores XAML y habilitar un programa para ver, interactuar o modificar el contenido de un flujo de nodo XAML durante una operación de ruta de acceso de carga o de ruta de acceso de guardado que implica XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-108">By treating XAML as a XAML node stream, XAML readers can communicate with XAML writers and enable a program to view, interact with, or alter the contents of a XAML node stream during either a load path or a save path operation that involves XAML.</span></span> <span data-ttu-id="62338-109">El diseño de la API de lector y escritor XAML y el concepto de flujo de nodo XAML son <xref:System.Xml.XmlReader> <xref:System.Xml.XmlWriter> similares a los diseños y conceptos de lector y escritor relacionados anteriores, como el modelo de objetos de documento XML (DOM) y las clases y.</span><span class="sxs-lookup"><span data-stu-id="62338-109">XAML reader and writer API design and the XAML node stream concept are similar to previous related reader and writer designs and concepts, such as the XML Document Object Model (DOM) and the <xref:System.Xml.XmlReader> and <xref:System.Xml.XmlWriter> classes.</span></span> <span data-ttu-id="62338-110">En este tema se describen los conceptos de flujo de nodo XAML y se describe cómo se puede escribir rutinas que interactúan con las representaciones XAML en el nivel de nodo XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-110">This topic discusses XAML node stream concepts and describes how you can write routines that interact with XAML representations at the XAML node level.</span></span>

## <a name="loading-xaml-into-a-xaml-reader"></a><span data-ttu-id="62338-111">Cargar XAML en un lector XAML</span><span class="sxs-lookup"><span data-stu-id="62338-111">Loading XAML into a XAML Reader</span></span>

<span data-ttu-id="62338-112">La clase base <xref:System.Xaml.XamlReader> no declara una técnica determinada para cargar el XAML inicial en un lector XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-112">The base <xref:System.Xaml.XamlReader> class does not declare a particular technique for loading the initial XAML into a XAML reader.</span></span> <span data-ttu-id="62338-113">En su lugar, una clase derivada declara e implementa la técnica de carga, incluidas las características y restricciones generales de su origen de entrada para XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-113">Instead, a derived class declares and implements the loading technique, including the general characteristics and constraints of its input source for XAML.</span></span> <span data-ttu-id="62338-114">Por ejemplo, un <xref:System.Xaml.XamlObjectReader> lee un gráfico de objetos a partir del origen de entrada de un solo objeto que representa la raíz o la base.</span><span class="sxs-lookup"><span data-stu-id="62338-114">For example, a <xref:System.Xaml.XamlObjectReader> reads an object graph, starting from the input source of a single object that represents the root or base.</span></span> <span data-ttu-id="62338-115">A continuación, el <xref:System.Xaml.XamlObjectReader> genera un flujo de nodo XAML a partir del gráfico de objeto.</span><span class="sxs-lookup"><span data-stu-id="62338-115">The <xref:System.Xaml.XamlObjectReader> then produces a XAML node stream from the object graph.</span></span>

<span data-ttu-id="62338-116">La subclase definida por <xref:System.Xaml.XamlReader> servicios XAML <xref:System.Xaml.XamlXmlReader>de .NET más prominente es .</span><span class="sxs-lookup"><span data-stu-id="62338-116">The most prominent .NET XAML Services–defined <xref:System.Xaml.XamlReader> subclass is <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="62338-117"><xref:System.Xaml.XamlXmlReader> carga el XAML inicial, ya sea mediante la carga de un archivo de texto directamente a través de una ruta de acceso de archivo o flujo, o indirectamente a través de una clase de lector relacionada, como <xref:System.IO.TextReader>.</span><span class="sxs-lookup"><span data-stu-id="62338-117"><xref:System.Xaml.XamlXmlReader> loads the initial XAML, either by loading a text file directly through a stream or file path, or indirectly through a related reader class such as <xref:System.IO.TextReader>.</span></span> <span data-ttu-id="62338-118">Puede considerarse que el <xref:System.Xaml.XamlReader> contiene la totalidad del origen de entrada de XAML después de cargarse.</span><span class="sxs-lookup"><span data-stu-id="62338-118">The <xref:System.Xaml.XamlReader> can be thought of as containing the entirety of the XAML input source after it has loaded.</span></span> <span data-ttu-id="62338-119">Sin embargo, la API base de <xref:System.Xaml.XamlReader> está diseñada para que el lector interactúe con un único nodo del XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-119">However, the <xref:System.Xaml.XamlReader> base API is designed so that the reader is interacting with a single node of the XAML.</span></span> <span data-ttu-id="62338-120">Cuando se carga por primera vez, el primer nodo único que encuentra es la raíz de XAML y su objeto de inicio.</span><span class="sxs-lookup"><span data-stu-id="62338-120">When first loaded, the first single node you encounter is the root of the XAML, and its start object.</span></span>

### <a name="the-xaml-node-stream-concept"></a><span data-ttu-id="62338-121">El concepto de flujo de nodo XAML</span><span class="sxs-lookup"><span data-stu-id="62338-121">The XAML Node Stream Concept</span></span>

<span data-ttu-id="62338-122">Si está más familiarizado con un DOM, una metáfora de árbol o un enfoque basado en consultas para obtener acceso a tecnologías basadas en XML, una forma útil de conceptualizar un flujo de nodo XAML es la siguiente.</span><span class="sxs-lookup"><span data-stu-id="62338-122">If you are more familiar with a DOM, tree metaphor, or query-based approach towards accessing XML-based technologies, a helpful way to conceptualize a XAML node stream is as follows.</span></span> <span data-ttu-id="62338-123">Imagine que el XAML cargado es un DOM o un árbol donde todos los nodos posibles se expanden por completo y, a continuación, se presentan linealmente.</span><span class="sxs-lookup"><span data-stu-id="62338-123">Imagine that the loaded XAML is a DOM or a tree where every possible node is expanded all the way, and then presented linearly.</span></span> <span data-ttu-id="62338-124">A medida que avanza a través de los nodos, puede recorrer «hacia dentro» o «hacia fuera» los niveles que son pertinentes para un DOM, pero el flujo de nodo XAML no realiza un seguimiento explícitamente, ya que estos conceptos no son relevantes para un flujo de nodo.</span><span class="sxs-lookup"><span data-stu-id="62338-124">As you advance through the nodes, you might be traversing "in" or "out" of levels that would be relevant to a DOM, but the XAML node stream does not explicitly keep track because these level concepts are not relevant to a node stream.</span></span> <span data-ttu-id="62338-125">El flujo de nodo tiene una posición «actual», pero a menos que haya almacenado por su cuenta otras partes del flujo como referencias, no estará a la vista ningún aspecto del flujo de nodo que no sea la posición del nodo actual.</span><span class="sxs-lookup"><span data-stu-id="62338-125">The node stream has a "current" position, but unless you have stored other parts of the stream yourself as references, every aspect of the node stream other than the current node position is out of view.</span></span>

<span data-ttu-id="62338-126">El concepto de flujo de nodo XAML tiene la importante ventaja de que, si recorre todo el flujo de nodo, se asegura de que se ha procesado la representación de XAML al completo; no es necesario preocuparse de si una consulta, una operación DOM u otro enfoque no lineal para el procesamiento de la información perdió alguna parte de la representación XAML completa.</span><span class="sxs-lookup"><span data-stu-id="62338-126">The XAML node stream concept has the notable advantage that if you go through the entire node stream, you are assured that you have processed the entire XAML representation; you do not need to worry that a query, a DOM operation, or some other nonlinear approach to processing information has missed some part of the complete XAML representation.</span></span> <span data-ttu-id="62338-127">Por este motivo, la representación del flujo de nodo XAML es ideal no solo para conectar los lectores y escritores de XAML, sino para proporcionar un sistema donde puede insertar su propio proceso, que actúe entre las fases de lectura y escritura de una operación de procesamiento de XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-127">For this reason, the XAML node stream representation is ideal both for connecting XAML readers and XAML writers, and for providing a system where you can insert your own process that acts between the read and write phases of a XAML processing operation.</span></span> <span data-ttu-id="62338-128">En muchos casos, los lectores de XAML optimizan o reordenan deliberadamente el orden de los nodos del flujo de nodos XAML con respecto a cómo aparecerían en el texto de origen, binario o gráfico de objetos.</span><span class="sxs-lookup"><span data-stu-id="62338-128">In many cases, the ordering of nodes in the XAML node stream is deliberately optimized or reordered by XAML readers versus how the order might appear in the source text, binary, or object graph.</span></span> <span data-ttu-id="62338-129">Este comportamiento está diseñado para aplicar una arquitectura de procesamiento de XAML mediante la cual los escritores de XAML nunca están en una posición en la que tengan que ir hacia «atrás» en el flujo de nodo.</span><span class="sxs-lookup"><span data-stu-id="62338-129">This behavior is intended to enforce a XAML processing architecture whereby XAML writers are never in a position where they have to go "back" in the node stream.</span></span> <span data-ttu-id="62338-130">Idealmente, todas las operaciones de escritura XAML debe poder actuar en función del contexto de esquema y la posición actual del flujo de nodos.</span><span class="sxs-lookup"><span data-stu-id="62338-130">Ideally, all XAML write operations should be able to act based on schema context plus the current position of the node stream.</span></span>

## <a name="a-basic-reading-node-loop"></a><span data-ttu-id="62338-131">Un bucle de nodo de lectura básico</span><span class="sxs-lookup"><span data-stu-id="62338-131">A Basic Reading Node Loop</span></span>

<span data-ttu-id="62338-132">Un bucle de nodo de lectura básico para examinar un flujo de nodo XAML se compone de los siguientes conceptos.</span><span class="sxs-lookup"><span data-stu-id="62338-132">A basic reading node loop for examining a XAML node stream consists of the following concepts.</span></span> <span data-ttu-id="62338-133">A los efectos de los bucles de nodo tal como se describen en este tema, suponga que está leyendo un archivo XAML basado en texto y en lenguaje natural mediante <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="62338-133">For purposes of node loops as discussed in this topic, assume that you are reading a text-based, human-readable XAML file using <xref:System.Xaml.XamlXmlReader>.</span></span> <span data-ttu-id="62338-134">Los vínculos de esta sección hacen referencia a la API de bucle de nodo XAML específica implementada por <xref:System.Xaml.XamlXmlReader>.</span><span class="sxs-lookup"><span data-stu-id="62338-134">The links in this section refer to the particular XAML node loop API implemented by <xref:System.Xaml.XamlXmlReader>.</span></span>

- <span data-ttu-id="62338-135">Asegúrese de que no está al final del flujo de nodo XAML (consulte <xref:System.Xaml.XamlXmlReader.IsEof%2A>o use el <xref:System.Xaml.XamlXmlReader.Read%2A> valor devuelto).</span><span class="sxs-lookup"><span data-stu-id="62338-135">Make sure that you are not at the end of the XAML node stream (check <xref:System.Xaml.XamlXmlReader.IsEof%2A>, or use the <xref:System.Xaml.XamlXmlReader.Read%2A> return value).</span></span> <span data-ttu-id="62338-136">Si está al final del flujo, no hay ningún nodo actual y debe salir.</span><span class="sxs-lookup"><span data-stu-id="62338-136">If you are at the end of the stream, there is no current node and you should exit.</span></span>

- <span data-ttu-id="62338-137">Compruebe qué tipo de nodo del flujo de nodo XAML se expone actualmente mediante una llamada a <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="62338-137">Check what type of node the XAML node stream currently exposes by calling <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span>

- <span data-ttu-id="62338-138">Si tiene un escritor de objetos XAML asociado que esté directamente conectado, lo habitual es llamar a <xref:System.Xaml.XamlWriter.WriteNode%2A> en este momento.</span><span class="sxs-lookup"><span data-stu-id="62338-138">If you have an associated XAML object writer that is connected directly, you generally call <xref:System.Xaml.XamlWriter.WriteNode%2A> at this point.</span></span>

- <span data-ttu-id="62338-139">En función del <xref:System.Xaml.XamlNodeType> que se notifique como nodo actual o registro actual, haga una de las siguientes llamadas para obtener información sobre el contenido del nodo:</span><span class="sxs-lookup"><span data-stu-id="62338-139">Based on which <xref:System.Xaml.XamlNodeType> is reported as the current node or current record, call one of the following to obtain information about the node contents:</span></span>

  - <span data-ttu-id="62338-140">Para un <xref:System.Xaml.XamlXmlReader.NodeType%2A> de <xref:System.Xaml.XamlNodeType.StartMember> o <xref:System.Xaml.XamlNodeType.EndMember>, llame a <xref:System.Xaml.XamlXmlReader.Member%2A> para obtener información <xref:System.Xaml.XamlMember> sobre un miembro.</span><span class="sxs-lookup"><span data-stu-id="62338-140">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartMember> or <xref:System.Xaml.XamlNodeType.EndMember>, call <xref:System.Xaml.XamlXmlReader.Member%2A> to obtain <xref:System.Xaml.XamlMember> information about a member.</span></span> <span data-ttu-id="62338-141">El miembro puede <xref:System.Xaml.XamlDirective>ser un , y por lo tanto no necesariamente podría ser un miembro definido por tipo convencional del objeto anterior.</span><span class="sxs-lookup"><span data-stu-id="62338-141">The member might be a <xref:System.Xaml.XamlDirective>, and thus might not necessarily be a conventional type-defined member of the preceding object.</span></span> <span data-ttu-id="62338-142">Por ejemplo, `x:Name` aplicado a un objeto aparece como un miembro XAML donde <xref:System.Xaml.XamlMember.IsDirective%2A> es true y el <xref:System.Xaml.XamlMember.Name%2A> del miembro es `Name`, con otras propiedades que indican que esta directiva está bajo el espacio de nombres XAML del lenguaje XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-142">For example, `x:Name` applied to an object appears as a XAML member where <xref:System.Xaml.XamlMember.IsDirective%2A> is true and the <xref:System.Xaml.XamlMember.Name%2A> of the member is `Name`, with other properties indicating that this directive is under the XAML language XAML namespace.</span></span>

  - <span data-ttu-id="62338-143">Para un <xref:System.Xaml.XamlXmlReader.NodeType%2A> de <xref:System.Xaml.XamlNodeType.StartObject> o <xref:System.Xaml.XamlNodeType.EndObject>, llame a <xref:System.Xaml.XamlXmlReader.Type%2A> para obtener información <xref:System.Xaml.XamlType> sobre un objeto.</span><span class="sxs-lookup"><span data-stu-id="62338-143">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.StartObject> or <xref:System.Xaml.XamlNodeType.EndObject>, call <xref:System.Xaml.XamlXmlReader.Type%2A> to obtain <xref:System.Xaml.XamlType> information about an object.</span></span>

  - <span data-ttu-id="62338-144">Para un <xref:System.Xaml.XamlXmlReader.NodeType%2A> de <xref:System.Xaml.XamlNodeType.Value>, llame a <xref:System.Xaml.XamlXmlReader.Value%2A>.</span><span class="sxs-lookup"><span data-stu-id="62338-144">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.Value>, call <xref:System.Xaml.XamlXmlReader.Value%2A>.</span></span> <span data-ttu-id="62338-145">Un nodo es un valor si es la expresión más simple de un valor para un miembro, o el texto de inicialización de un objeto (sin embargo, debe tener en cuenta el comportamiento de conversión de tipos, tal como se describe en una sección posterior de este tema).</span><span class="sxs-lookup"><span data-stu-id="62338-145">A node is a value only if it is the simplest expression of a value for a member, or the initialization text for an object (however, you should be aware of type conversion behavior as documented in an upcoming section of this topic).</span></span>

  - <span data-ttu-id="62338-146">Para un <xref:System.Xaml.XamlXmlReader.NodeType%2A> de <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, llame a <xref:System.Xaml.XamlXmlReader.Namespace%2A> para obtener información de espacio de nombres para un nodo de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="62338-146">For a <xref:System.Xaml.XamlXmlReader.NodeType%2A> of <xref:System.Xaml.XamlNodeType.NamespaceDeclaration>, call <xref:System.Xaml.XamlXmlReader.Namespace%2A> to obtain namespace information for a namespace node.</span></span>

- <span data-ttu-id="62338-147">Llame a <xref:System.Xaml.XamlXmlReader.Read%2A> para avanzar el lector XAML al nodo siguiente en el flujo de nodo XAML, y vuelva a repetir los pasos.</span><span class="sxs-lookup"><span data-stu-id="62338-147">Call <xref:System.Xaml.XamlXmlReader.Read%2A> to advance the XAML reader to the next node in the XAML node stream, and repeat the steps again.</span></span>

<span data-ttu-id="62338-148">El flujo de nodo XAML proporcionado por los lectores XAML de Servicios XAML de .NET siempre proporciona un recorrido completo y profundo de todos los nodos posibles.</span><span class="sxs-lookup"><span data-stu-id="62338-148">The XAML node stream provided by .NET XAML Services XAML readers always provides a full, deep traversal of all possible nodes.</span></span> <span data-ttu-id="62338-149">Las técnicas de control de flujo típicas para un bucle de nodo XAML incluyen definir un cuerpo dentro de `while (reader.Read())`y activar <xref:System.Xaml.XamlXmlReader.NodeType%2A> en cada punto de nodo en el bucle de nodo.</span><span class="sxs-lookup"><span data-stu-id="62338-149">Typical flow-control techniques for a XAML node loop include defining a body within `while (reader.Read())`, and switching on <xref:System.Xaml.XamlXmlReader.NodeType%2A> at each node point in the node loop.</span></span>

<span data-ttu-id="62338-150">Si el flujo de nodo está al final del archivo, el nodo actual es null.</span><span class="sxs-lookup"><span data-stu-id="62338-150">If the node stream is at end of file, the current node is null.</span></span>

<span data-ttu-id="62338-151">El bucle más sencillo que usa un lector y un escritor es similar al siguiente ejemplo.</span><span class="sxs-lookup"><span data-stu-id="62338-151">The simplest loop that uses a reader and writer resembles the following example.</span></span>

```csharp
XamlXmlReader xxr = new XamlXmlReader(new StringReader(xamlStringToLoad));
//where xamlStringToLoad is a string of well formed XAML
XamlObjectWriter xow = new XamlObjectWriter(xxr.SchemaContext);
while (xxr.Read()) {
  xow.WriteNode(xxr);
}
```

<span data-ttu-id="62338-152">Este ejemplo básico de un bucle de nodo XAML de ruta de acceso de carga conecta de forma transparente el lector XAML y el escritor XAML, sin hacer nada diferente que si hubiera usado <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="62338-152">This basic example of a load path XAML node loop transparently connects the XAML reader and XAML writer, doing nothing different than if you had used <xref:System.Xaml.XamlServices.Parse%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="62338-153">Pero, a continuación, esta estructura básica se expande para aplicarse a su escenario de escritura o lectura.</span><span class="sxs-lookup"><span data-stu-id="62338-153">But this basic structure is then expanded to apply to your reading or writing scenario.</span></span> <span data-ttu-id="62338-154">Algunos escenarios posibles son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="62338-154">Some possible scenarios are as follows:</span></span>

- <span data-ttu-id="62338-155">Active <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span><span class="sxs-lookup"><span data-stu-id="62338-155">Switch on <xref:System.Xaml.XamlXmlReader.NodeType%2A>.</span></span> <span data-ttu-id="62338-156">Realice diferentes acciones en función de qué tipo de nodo se está leyendo.</span><span class="sxs-lookup"><span data-stu-id="62338-156">Perform different actions depending on which node type is being read.</span></span>

- <span data-ttu-id="62338-157">No llame a <xref:System.Xaml.XamlWriter.WriteNode%2A> en todos los casos.</span><span class="sxs-lookup"><span data-stu-id="62338-157">Do not call <xref:System.Xaml.XamlWriter.WriteNode%2A> in all cases.</span></span> <span data-ttu-id="62338-158">Solo llame a <xref:System.Xaml.XamlWriter.WriteNode%2A> en algunos casos de <xref:System.Xaml.XamlXmlReader.NodeType%2A> .</span><span class="sxs-lookup"><span data-stu-id="62338-158">Only call <xref:System.Xaml.XamlWriter.WriteNode%2A> in some <xref:System.Xaml.XamlXmlReader.NodeType%2A> cases.</span></span>

- <span data-ttu-id="62338-159">Dentro de la lógica de un tipo de nodo determinado, analice las características concretas de ese nodo y actúe sobre ellas.</span><span class="sxs-lookup"><span data-stu-id="62338-159">Within the logic for a particular node type, analyze the specifics of that node and act on them.</span></span> <span data-ttu-id="62338-160">Por ejemplo, solo podría escribir objetos que provengan de un espacio de nombres XAML determinado y, a continuación, quitar o aplazar cualquier objeto que no provenga de ese espacio de nombres XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-160">For example, you could only write objects that come from a particular XAML namespace, and then drop or defer any objects not from that XAML namespace.</span></span> <span data-ttu-id="62338-161">También podría anular o reprocesar de otro modo las directivas XAML que su sistema XAML no admita como parte de su procesamiento del miembro.</span><span class="sxs-lookup"><span data-stu-id="62338-161">Or you could drop or otherwise reprocess any XAML directives that your XAML system does not support as part of your member processing.</span></span>

- <span data-ttu-id="62338-162">Defina un <xref:System.Xaml.XamlObjectWriter> personalizado que invalide los métodos `Write*` , posiblemente realizando la asignación de tipos que omite el contexto de esquema XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-162">Define a custom <xref:System.Xaml.XamlObjectWriter> that overrides `Write*` methods, possibly performing type mapping that bypasses XAML schema context.</span></span>

- <span data-ttu-id="62338-163">Construya el <xref:System.Xaml.XamlXmlReader> de modo que use un contexto de esquema XAML no predeterminado, para que el lector y el escritor usen las diferencias personalizadas en el comportamiento XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-163">Construct the <xref:System.Xaml.XamlXmlReader> to use a nondefault XAML schema context, so that customized differences in XAML behavior are used both by the reader and the writer.</span></span>

### <a name="accessing-xaml-beyond-the-node-loop-concept"></a><span data-ttu-id="62338-164">Acceder a XAML más allá del concepto de bucle de nodo</span><span class="sxs-lookup"><span data-stu-id="62338-164">Accessing XAML Beyond the Node Loop Concept</span></span>

<span data-ttu-id="62338-165">Existen otras maneras de trabajar con una representación de XAML, además del bucle de nodo XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-165">There are potentially other ways to work with a XAML representation other than as a XAML node loop.</span></span> <span data-ttu-id="62338-166">Por ejemplo, podría existir un lector XAML que puede leer un nodo indexado o en concreto acceder a los nodos directamente a través de `x:Name`, `x:Uid`u otros identificadores.</span><span class="sxs-lookup"><span data-stu-id="62338-166">For example, there could exist a XAML reader that can read an indexed node, or in particular accesses nodes directly by `x:Name`, by `x:Uid`, or through other identifiers.</span></span> <span data-ttu-id="62338-167">Los servicios XAML de .NET no proporcionan una implementación completa, pero proporciona un patrón sugerido a través de servicios y tipos de soporte técnico.</span><span class="sxs-lookup"><span data-stu-id="62338-167">.NET XAML Services does not provide a full implementation, but provides a suggested pattern through services and support types.</span></span> <span data-ttu-id="62338-168">Para más información, vea <xref:System.Xaml.IXamlIndexingReader> y <xref:System.Xaml.XamlNodeList>.</span><span class="sxs-lookup"><span data-stu-id="62338-168">For more information, see <xref:System.Xaml.IXamlIndexingReader> and <xref:System.Xaml.XamlNodeList>.</span></span>

## <a name="working-with-the-current-node"></a><span data-ttu-id="62338-169">Trabajar con el nodo actual</span><span class="sxs-lookup"><span data-stu-id="62338-169">Working with the Current Node</span></span>

<span data-ttu-id="62338-170">La mayoría de los escenarios que usan un bucle de nodo XAML no leen solo los nodos.</span><span class="sxs-lookup"><span data-stu-id="62338-170">Most scenarios that use a XAML node loop do not only read the nodes.</span></span> <span data-ttu-id="62338-171">La mayoría de los escenarios procesan los nodos actuales y pasan cada nodo de uno en uno a una implementación de <xref:System.Xaml.XamlWriter>.</span><span class="sxs-lookup"><span data-stu-id="62338-171">Most scenarios process current nodes and pass each node one at a time to an implementation of <xref:System.Xaml.XamlWriter>.</span></span>

<span data-ttu-id="62338-172">En el escenario típico de ruta de acceso de carga, un <xref:System.Xaml.XamlXmlReader> genera un flujo de nodo XAML; los nodos XAML se procesan según su lógica y su contexto de esquema XAML; y los nodos se pasan a un <xref:System.Xaml.XamlObjectWriter>.</span><span class="sxs-lookup"><span data-stu-id="62338-172">In the typical load path scenario, a <xref:System.Xaml.XamlXmlReader> produces a XAML node stream; the XAML nodes are processed according to your logic and XAML schema context; and the nodes are passed to a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="62338-173">A continuación, integre el gráfico de objetos resultante en su aplicación o marco.</span><span class="sxs-lookup"><span data-stu-id="62338-173">You then integrate the resulting object graph into your application or framework.</span></span>

<span data-ttu-id="62338-174">En un escenario típico de ruta de acceso de guardado, un <xref:System.Xaml.XamlObjectReader> lee el gráfico de objetos, se procesan los nodos XAML individuales y un <xref:System.Xaml.XamlXmlWriter> genera el resultado serializado como un archivo de texto XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-174">In a typical save path scenario, a <xref:System.Xaml.XamlObjectReader> reads the object graph, individual XAML nodes are processed, and a <xref:System.Xaml.XamlXmlWriter> outputs the serialized result as a XAML text file.</span></span> <span data-ttu-id="62338-175">La clave es que tanto las rutas de acceso como los escenarios implican trabajar exactamente con un nodo XAML a la vez y los nodos XAML están disponibles para el tratamiento de forma estandarizada definida por el sistema de tipos XAML y the.NET API de servicios XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-175">The key is that both paths and scenarios involve working with exactly one XAML node at a time, and the XAML nodes are available for treatment in a standardized way that is defined by the XAML type system and the.NET XAML Services APIs.</span></span>

### <a name="frames-and-scope"></a><span data-ttu-id="62338-176">Marcos y ámbito</span><span class="sxs-lookup"><span data-stu-id="62338-176">Frames and Scope</span></span>

<span data-ttu-id="62338-177">Un bucle de nodo XAML le guía a través de un flujo de nodo XAML de manera lineal.</span><span class="sxs-lookup"><span data-stu-id="62338-177">A XAML node loop walks through a XAML node stream in a linear way.</span></span> <span data-ttu-id="62338-178">El flujo de nodo recorre los objetos, los miembros que contienen otros objetos y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="62338-178">The node stream traverses into objects, into members that contain other objects, and so on.</span></span> <span data-ttu-id="62338-179">A menudo resulta útil realizar un seguimiento del ámbito dentro del flujo de nodo XAML implementando un concepto de marco de pila.</span><span class="sxs-lookup"><span data-stu-id="62338-179">It is often useful to keep track of scope within the XAML node stream by implementing a frame and stack concept.</span></span> <span data-ttu-id="62338-180">Esto es especialmente cierto si está ajustando activamente el flujo de nodo mientras está en él.</span><span class="sxs-lookup"><span data-stu-id="62338-180">This is particularly true if you are actively adjusting the node stream while you are in it.</span></span> <span data-ttu-id="62338-181">La compatibilidad de marco de pila que implemente como parte de la lógica de bucle de nodo puede contar ámbitos `StartObject` (o `GetObject`) y `EndObject` a medida que desciende en una estructura de nodo XAML, si la estructura se considera desde una perspectiva de DOM.</span><span class="sxs-lookup"><span data-stu-id="62338-181">The frame and stack support that you implement as part of your node loop logic could count `StartObject` (or `GetObject`) and `EndObject` scopes as you descend into a XAML node structure if the structure is thought of from a DOM perspective.</span></span>

## <a name="traversing-and-entering-object-nodes"></a><span data-ttu-id="62338-182">Atravesar y escribir nodos de objeto</span><span class="sxs-lookup"><span data-stu-id="62338-182">Traversing and Entering Object Nodes</span></span>

<span data-ttu-id="62338-183">El primer nodo de un flujo de nodos cuando se abre un lector de XAML es el nodo de objeto de inicio del objeto raíz.</span><span class="sxs-lookup"><span data-stu-id="62338-183">The first node in a node stream when it is opened by a XAML reader is the start-object node of the root object.</span></span> <span data-ttu-id="62338-184">Por definición, este objeto siempre es un nodo de objeto único y no tiene ningún nodo del mismo nivel.</span><span class="sxs-lookup"><span data-stu-id="62338-184">By definition, this object is always a single object node and has no peers.</span></span> <span data-ttu-id="62338-185">En cualquier ejemplo de XAML real, el objeto raíz se define de modo que tenga una o varias propiedades que contienen más objetos, y estas propiedades tienen nodos de miembro.</span><span class="sxs-lookup"><span data-stu-id="62338-185">In any real-world XAML example, the root object is defined to have one or more properties that hold more objects, and these properties have member nodes.</span></span> <span data-ttu-id="62338-186">Los nodos de miembro tienen uno o más nodos de objeto, o en su lugar también pueden terminar en un nodo de valor.</span><span class="sxs-lookup"><span data-stu-id="62338-186">The member nodes then have one or more object nodes, or might also terminate in a value node instead.</span></span> <span data-ttu-id="62338-187">El objeto raíz suele definir los ámbitos de nombres XAML, que sintácticamente se asignan como atributos en el marcado de texto XAML, pero se asignan a un tipo de nodo `Namescope` en la representación del flujo de nodo XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-187">The root object typically defines XAML namescopes, which are syntactically assigned as attributes in the XAML text markup but map to a `Namescope` node type in the XAML node stream representation.</span></span>

<span data-ttu-id="62338-188">Considere el siguiente ejemplo XAML (esto es XAML arbitrario, no respaldado por tipos existentes en .NET).</span><span class="sxs-lookup"><span data-stu-id="62338-188">Consider the following XAML example (this is arbitrary XAML, not backed by existing types in .NET).</span></span> <span data-ttu-id="62338-189">Suponga que en este modelo de objetos, `FavorCollection` es `List<T>` de `Favor`, `Balloon` y `NoiseMaker` son asignables a `Favor`, la propiedad `Balloon.Color` está respaldada por un objeto `Color` similar a la forma en que WPF define los colores como nombres de colores conocidos, y `Color` admite un convertidor de tipos para la sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="62338-189">Assume that in this object model, `FavorCollection` is `List<T>` of `Favor`, `Balloon` and `NoiseMaker` are assignable to `Favor`, the `Balloon.Color` property is backed by a `Color` object similar to how WPF defines colors as known color names, and `Color` supports a type converter for attribute syntax.</span></span>

|<span data-ttu-id="62338-190">Marcado XAML</span><span class="sxs-lookup"><span data-stu-id="62338-190">XAML markup</span></span>|<span data-ttu-id="62338-191">Flujo de nodo XAML resultante</span><span class="sxs-lookup"><span data-stu-id="62338-191">Resulting XAML node stream</span></span>|
|-----------------|--------------------------------|
|`<Party`|<span data-ttu-id="62338-192">`Namespace` para `Party`</span><span class="sxs-lookup"><span data-stu-id="62338-192">`Namespace` node for `Party`</span></span>|
|`xmlns="PartyXamlNamespace">`|<span data-ttu-id="62338-193">`StartObject` para `Party`</span><span class="sxs-lookup"><span data-stu-id="62338-193">`StartObject` node for `Party`</span></span>|
|`<Party.Favors>`|<span data-ttu-id="62338-194">`StartMember` para `Party.Favors`</span><span class="sxs-lookup"><span data-stu-id="62338-194">`StartMember` node for `Party.Favors`</span></span>|
||<span data-ttu-id="62338-195">Nodo`StartObject` para la `FavorCollection`implícita</span><span class="sxs-lookup"><span data-stu-id="62338-195">`StartObject` node for implicit `FavorCollection`</span></span>|
||<span data-ttu-id="62338-196">Nodo`StartMember` para la propiedad Items `FavorCollection` implícita</span><span class="sxs-lookup"><span data-stu-id="62338-196">`StartMember` node for implicit `FavorCollection` items property.</span></span>|
|`<Balloon`|<span data-ttu-id="62338-197">`StartObject` para `Balloon`</span><span class="sxs-lookup"><span data-stu-id="62338-197">`StartObject` node for `Balloon`</span></span>|
|`Color="Red"`|<span data-ttu-id="62338-198">`StartMember` para `Color`</span><span class="sxs-lookup"><span data-stu-id="62338-198">`StartMember` node for `Color`</span></span><br /><br /> <span data-ttu-id="62338-199">`Value` para la cadena de valor de atributo `"Red"`</span><span class="sxs-lookup"><span data-stu-id="62338-199">`Value` node for the attribute value string `"Red"`</span></span><br /><br /> <span data-ttu-id="62338-200">`EndMember` para `Color`</span><span class="sxs-lookup"><span data-stu-id="62338-200">`EndMember` for `Color`</span></span>|
|`HasHelium="True"`|<span data-ttu-id="62338-201">`StartMember` para `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="62338-201">`StartMember` node for `HasHelium`</span></span><br /><br /> <span data-ttu-id="62338-202">`Value` para la cadena de valor de atributo `"True"`</span><span class="sxs-lookup"><span data-stu-id="62338-202">`Value` node for the attribute value string `"True"`</span></span><br /><br /> <span data-ttu-id="62338-203">`EndMember` para `HasHelium`</span><span class="sxs-lookup"><span data-stu-id="62338-203">`EndMember` for `HasHelium`</span></span>|
|`>`|<span data-ttu-id="62338-204">`EndObject` para `Balloon`</span><span class="sxs-lookup"><span data-stu-id="62338-204">`EndObject` for `Balloon`</span></span>|
|`<NoiseMaker>Loudest</NoiseMaker>`|<span data-ttu-id="62338-205">`StartObject` para `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="62338-205">`StartObject` node for `NoiseMaker`</span></span><br /><br /> <span data-ttu-id="62338-206">`StartMember` para `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="62338-206">`StartMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="62338-207">`Value` para la cadena de valor de inicialización `"Loudest"`</span><span class="sxs-lookup"><span data-stu-id="62338-207">`Value` node for the initialization value string `"Loudest"`</span></span><br /><br /> <span data-ttu-id="62338-208">`EndMember` para `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="62338-208">`EndMember` node for `_Initialization`</span></span><br /><br /> <span data-ttu-id="62338-209">`EndObject` para `NoiseMaker`</span><span class="sxs-lookup"><span data-stu-id="62338-209">`EndObject` for `NoiseMaker`</span></span>|
||<span data-ttu-id="62338-210">Nodo`EndMember` para la propiedad Items `FavorCollection` implícita</span><span class="sxs-lookup"><span data-stu-id="62338-210">`EndMember` node for implicit `FavorCollection` items property.</span></span>|
||<span data-ttu-id="62338-211">Nodo`EndObject` para la `FavorCollection`implícita</span><span class="sxs-lookup"><span data-stu-id="62338-211">`EndObject` node for implicit `FavorCollection`</span></span>|
|`</Party.Favors>`|<span data-ttu-id="62338-212">`EndMember` para `Favors`</span><span class="sxs-lookup"><span data-stu-id="62338-212">`EndMember` for `Favors`</span></span>|
|`</Party>`|<span data-ttu-id="62338-213">`EndObject` para `Party`</span><span class="sxs-lookup"><span data-stu-id="62338-213">`EndObject` for `Party`</span></span>|

<span data-ttu-id="62338-214">En el flujo de nodo XAML, puede confiar en el comportamiento siguiente:</span><span class="sxs-lookup"><span data-stu-id="62338-214">In the XAML node stream, you can rely on the following behavior:</span></span>

- <span data-ttu-id="62338-215">Si existe un nodo `Namespace` , se agrega al flujo inmediatamente antes del `StartObject` que declaró el espacio de nombres XAML con `xmlns`.</span><span class="sxs-lookup"><span data-stu-id="62338-215">If a `Namespace` node exists, it is added to the stream immediately before the `StartObject` that declared the XAML namespace with `xmlns`.</span></span> <span data-ttu-id="62338-216">Vuelva a consultar la tabla anterior con el XAML y el flujo de nodo de ejemplo.</span><span class="sxs-lookup"><span data-stu-id="62338-216">Look at the previous table with the XAML and example node stream again.</span></span> <span data-ttu-id="62338-217">Observe que los nodos `StartObject` y `Namespace` parecen estar transpuestos con respecto a sus posiciones de declaración en el marcado de texto.</span><span class="sxs-lookup"><span data-stu-id="62338-217">Notice how the `StartObject` and `Namespace` nodes seem to be transposed versus their declaration positions in text markup.</span></span> <span data-ttu-id="62338-218">Esto es representativo del comportamiento donde los nodos de espacios de nombres siempre aparecen antes que el nodo al que se aplican en el flujo de nodos.</span><span class="sxs-lookup"><span data-stu-id="62338-218">This is representative of the behavior where the namespace nodes always appear ahead of the node they apply to in the node stream.</span></span> <span data-ttu-id="62338-219">Este diseño se debe a que la información del espacio de nombres es vital para los escritores de objetos y debe conocerse antes de que el escritor de objetos intente realizar una asignación de tipos o procesar de otra manera el objeto.</span><span class="sxs-lookup"><span data-stu-id="62338-219">The purpose of this design is that the namespace information is vital to object writers and must be known before the object writer attempts to perform type mapping or otherwise process the object.</span></span> <span data-ttu-id="62338-220">Si se coloca la información del espacio de nombres XAML delante de su ámbito de aplicación en el flujo, es más fácil procesar el flujo de nodo en el orden presentado.</span><span class="sxs-lookup"><span data-stu-id="62338-220">Placing the XAML namespace information ahead of its application scope in the stream makes it simpler to always process the node stream in its presented order.</span></span>

- <span data-ttu-id="62338-221">Debido a la consideración anterior, en la mayoría de los casos de marcado reales, lo primero que se lee es uno o más nodos `Namespace` al atravesar los nodos desde el principio, no el `StartObject` de la raíz.</span><span class="sxs-lookup"><span data-stu-id="62338-221">Because of the above consideration, it is one or more `Namespace` nodes that you read first in most real-world markup cases when traversing nodes from the start, not the `StartObject` of the root.</span></span>

- <span data-ttu-id="62338-222">Un nodo `StartObject` puede ir seguido de un `StartMember`, un `Value`o un `EndObject`inmediato.</span><span class="sxs-lookup"><span data-stu-id="62338-222">A `StartObject` node can be followed by `StartMember`, `Value`, or an immediate `EndObject`.</span></span> <span data-ttu-id="62338-223">Nunca va inmediatamente seguido de otro `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="62338-223">It is never followed immediately by another `StartObject`.</span></span>

- <span data-ttu-id="62338-224">Un `StartMember` puede ir seguido de un `StartObject`, un `Value`o un `EndMember`inmediato.</span><span class="sxs-lookup"><span data-stu-id="62338-224">A `StartMember` can be followed by a `StartObject`, `Value`, or an immediate `EndMember`.</span></span> <span data-ttu-id="62338-225">Puede ir seguido de un `GetObject`, para los miembros en los que se supone que el valor procede de un valor existente del objeto primario, en lugar de un `StartObject` que crearía una instancia de un nuevo valor.</span><span class="sxs-lookup"><span data-stu-id="62338-225">It can be followed by `GetObject`, for members where the value is supposed to come from an existing value of the parent object rather than a `StartObject` that would instantiate a new value.</span></span> <span data-ttu-id="62338-226">También puede ir seguido de un nodo `Namespace` , que se aplica a un próximo `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="62338-226">It can also be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span> <span data-ttu-id="62338-227">Nunca va inmediatamente seguido de otro `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="62338-227">It is never followed immediately by another `StartMember`.</span></span>

- <span data-ttu-id="62338-228">Un nodo `Value` representa el propio valor; no hay ningún «EndValue».</span><span class="sxs-lookup"><span data-stu-id="62338-228">A `Value` node represents the value itself; there is no "EndValue".</span></span> <span data-ttu-id="62338-229">Solo puede ir seguido de un `EndMember`.</span><span class="sxs-lookup"><span data-stu-id="62338-229">It can be followed only by an `EndMember`.</span></span>

  - <span data-ttu-id="62338-230">El texto de inicialización de XAML del objeto, tal y como puede usarlo la construcción, no da como resultado una estructura Objeto-Valor.</span><span class="sxs-lookup"><span data-stu-id="62338-230">XAML initialization text of the object as might be used by construction does not result in an Object-Value structure.</span></span> <span data-ttu-id="62338-231">En su lugar, se crea un nodo de miembro dedicado para un miembro denominado `_Initialization`</span><span class="sxs-lookup"><span data-stu-id="62338-231">Instead, a dedicated member node for a member named `_Initialization` is created.</span></span> <span data-ttu-id="62338-232">y ese nodo de miembro contiene la cadena de valor de inicialización.</span><span class="sxs-lookup"><span data-stu-id="62338-232">and that member node contains the initialization value string.</span></span> <span data-ttu-id="62338-233">Si existe, `_Initialization` siempre es el primer `StartMember`.</span><span class="sxs-lookup"><span data-stu-id="62338-233">If it exists, `_Initialization` is always the first `StartMember`.</span></span> <span data-ttu-id="62338-234">`_Initialization` se puede calificar en algunas representaciones de servicios XAML con el ámbito de nombres XAML del lenguaje XAML, para aclarar que `_Initialization` no es una propiedad definida en los tipos de respaldo.</span><span class="sxs-lookup"><span data-stu-id="62338-234">`_Initialization` may be qualified in some XAML services representations with the XAML language XAML namescope, to clarify that `_Initialization` is not a defined property in backing types.</span></span>

  - <span data-ttu-id="62338-235">Una combinación Miembro-Valor representa la configuración de atributo del valor.</span><span class="sxs-lookup"><span data-stu-id="62338-235">A Member-Value combination represents an attribute setting of the value.</span></span> <span data-ttu-id="62338-236">Finalmente podría haber un convertidor de valores implicado en el procesamiento de este valor, y el valor es una cadena sin formato.</span><span class="sxs-lookup"><span data-stu-id="62338-236">There might eventually be a value converter involved in processing this value, and the value is a plain string.</span></span> <span data-ttu-id="62338-237">Sin embargo, esto no se evalúa hasta que un escritor de objetos XAML procesa este flujo de nodo.</span><span class="sxs-lookup"><span data-stu-id="62338-237">However, that is not evaluated until a XAML object writer processes this node stream.</span></span> <span data-ttu-id="62338-238">El escritor de objetos XAML posee el contexto de esquema XAML, la asignación del sistema de tipos y otras compatibilidades que son necesarios para las conversiones de valores.</span><span class="sxs-lookup"><span data-stu-id="62338-238">The XAML object writer possesses the necessary XAML schema context, type system mapping, and other support needed for value conversions.</span></span>

- <span data-ttu-id="62338-239">Un nodo `EndMember` puede ir seguido de un nodo `StartMember` para un miembro subsiguiente, o bien de un nodo `EndObject` para el propietario del miembro.</span><span class="sxs-lookup"><span data-stu-id="62338-239">An `EndMember` node can be followed by a `StartMember` node for a subsequent member, or by an `EndObject` node for the member owner.</span></span>

- <span data-ttu-id="62338-240">Un nodo `EndObject` puede ir seguido de un nodo `EndMember` .</span><span class="sxs-lookup"><span data-stu-id="62338-240">An `EndObject` node can be followed by an `EndMember` node.</span></span> <span data-ttu-id="62338-241">También puede ir seguido de un nodo `StartObject` para los casos en que los objetos sean del mismo nivel en los elementos de la colección.</span><span class="sxs-lookup"><span data-stu-id="62338-241">It can also be followed by a `StartObject` node for cases where the objects are peers in a collection's items.</span></span> <span data-ttu-id="62338-242">Asimismo, puede ir seguido de un nodo `Namespace` , que se aplica a un próximo `StartObject`.</span><span class="sxs-lookup"><span data-stu-id="62338-242">Or it can be followed by a `Namespace` node, which applies to an upcoming `StartObject`.</span></span>

  - <span data-ttu-id="62338-243">Para el caso único de cerrar el flujo de nodo completo, el `EndObject` de la raíz no va seguido de nada; el lector es ahora el final del archivo y <xref:System.Xaml.XamlReader.Read%2A> devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="62338-243">For the unique case of closing the entire node stream, the `EndObject` of the root is not followed by anything; the reader is now end-of-file, and <xref:System.Xaml.XamlReader.Read%2A> returns `false`.</span></span>

## <a name="value-converters-and-the-xaml-node-stream"></a><span data-ttu-id="62338-244">Convertidores de valores y flujo de nodo XAML</span><span class="sxs-lookup"><span data-stu-id="62338-244">Value Converters and the XAML Node Stream</span></span>

<span data-ttu-id="62338-245">Un convertidor de valores es un término general para referirse a una extensión de marcado, un convertidor de tipos (incluidos los serializadores de valores) u otra clase dedicada que se notifica como un convertidor de valores a través del sistema de tipos XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-245">A value converter is a general term for a markup extension, a type converter (including value serializers) or another dedicated class that is reported as a value converter through the XAML type system.</span></span> <span data-ttu-id="62338-246">En el flujo de nodo XAML, el uso de un convertidor de tipos y el uso de una extensión de marcado tienen representaciones muy diferentes.</span><span class="sxs-lookup"><span data-stu-id="62338-246">In the XAML node stream, a type converter usage and a markup extension usage have very different representations.</span></span>

### <a name="type-converters-in-the-xaml-node-stream"></a><span data-ttu-id="62338-247">Convertidores de tipos en el flujo de nodo XAML</span><span class="sxs-lookup"><span data-stu-id="62338-247">Type Converters in the XAML Node Stream</span></span>

<span data-ttu-id="62338-248">Un conjunto de atributos que finalmente tiene como resultado un uso del convertidor de tipos se notifica en el flujo de nodo XAML como un valor de un miembro.</span><span class="sxs-lookup"><span data-stu-id="62338-248">An attribute set that eventually results in a type converter usage is reported in the XAML node stream as a value of a member.</span></span> <span data-ttu-id="62338-249">El flujo de nodo XAML no intenta generar un objeto de instancia del convertidor de tipos y pasarle el valor.</span><span class="sxs-lookup"><span data-stu-id="62338-249">The XAML node stream does not attempt to produce a type converter instance object and pass the value to it.</span></span> <span data-ttu-id="62338-250">El uso de la implementación de conversión de un convertidor de tipos requiere invocar el contexto de esquema XAML y usarlo para la asignación de tipos.</span><span class="sxs-lookup"><span data-stu-id="62338-250">Using a type converter's conversion implementation requires invoking the XAML schema context and using it for type-mapping.</span></span> <span data-ttu-id="62338-251">Incluso el proceso de determinar qué clase de convertidor de tipos se debería usar para procesar el valor requiere indirectamente el contexto de esquema XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-251">Even determining which type converter class should be used to process the value requires the XAML schema context indirectly.</span></span> <span data-ttu-id="62338-252">Cuando se usa el contexto de esquema XAML predeterminado, esa información está disponible en el sistema de tipos XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-252">When you use the default XAML schema context, that information is available from the XAML type system.</span></span> <span data-ttu-id="62338-253">Si necesita información sobre la clase del convertidor de tipos en el nivel de flujo de nodo XAML antes de la conexión a un escritor de XAML, puede obtenerla en la información <xref:System.Xaml.XamlMember> del miembro que se va a establecer.</span><span class="sxs-lookup"><span data-stu-id="62338-253">If you need the type converter class information at the XAML node stream level before connection to a XAML writer, you can obtain it from the <xref:System.Xaml.XamlMember> information of the member being set.</span></span> <span data-ttu-id="62338-254">Pero de lo contrario, la entrada del convertidor de tipos debe conservarse en el flujo de nodo XAML como un valor sin formato hasta que se realicen el resto de operaciones que requieren el sistema de asignación de tipos y el contexto de esquema XAML, por ejemplo, la creación de objetos por un escritor de objetos XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-254">But otherwise, type converter input should be preserved in the XAML node stream as a plain value until the remainder of operations that require the type-mapping system and XAML schema context are performed, for example the object creation by a XAML object writer.</span></span>

<span data-ttu-id="62338-255">Por ejemplo, considere el siguiente esquema de definición de clase y el uso XAML para dicho esquema:</span><span class="sxs-lookup"><span data-stu-id="62338-255">For example, consider the following class definition outline and XAML usage for it:</span></span>

```csharp
public class BoardSizeConverter : TypeConverter {
  //converts from string to an int[2] by splitting on an "x" char
}
public class GameBoard {
  [TypeConverter(typeof(BoardSizeConverter))]
  public int[] BoardSize; //2x2 array, initialization not shown
}
```

```xaml
<GameBoard BoardSize="8x8"/>
```

<span data-ttu-id="62338-256">Una representación de texto del flujo de nodo XAML para este uso se puede expresar de la siguiente manera:</span><span class="sxs-lookup"><span data-stu-id="62338-256">A text representation of the XAML node stream for this usage could be expressed as the following:</span></span>

<span data-ttu-id="62338-257">`StartObject` con <xref:System.Xaml.XamlType> que representa `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="62338-257">`StartObject` with <xref:System.Xaml.XamlType> representing `GameBoard`</span></span>

<span data-ttu-id="62338-258">`StartMember` con <xref:System.Xaml.XamlMember> que representa `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="62338-258">`StartMember` with <xref:System.Xaml.XamlMember> representing `BoardSize`</span></span>

<span data-ttu-id="62338-259">Nodo`Value` con la cadena de texto «`8x8`»</span><span class="sxs-lookup"><span data-stu-id="62338-259">`Value` node, with text string "`8x8`"</span></span>

<span data-ttu-id="62338-260">`EndMember` coincide con `BoardSize`</span><span class="sxs-lookup"><span data-stu-id="62338-260">`EndMember` matches `BoardSize`</span></span>

<span data-ttu-id="62338-261">`EndObject` coincide con `GameBoard`</span><span class="sxs-lookup"><span data-stu-id="62338-261">`EndObject` matches `GameBoard`</span></span>

<span data-ttu-id="62338-262">Observe que no hay ninguna instancia del convertidor de tipos en este flujo de nodo.</span><span class="sxs-lookup"><span data-stu-id="62338-262">Notice that there is no type converter instance in this node stream.</span></span> <span data-ttu-id="62338-263">Sin embargo, puede obtener información del convertidor de tipos llamando a <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> en el <xref:System.Xaml.XamlMember> para `BoardSize`.</span><span class="sxs-lookup"><span data-stu-id="62338-263">But you can get type converter information by calling <xref:System.Xaml.XamlMember.TypeConverter%2A?displayProperty=nameWithType> on the <xref:System.Xaml.XamlMember> for `BoardSize`.</span></span> <span data-ttu-id="62338-264">Si tiene un contexto de esquema XAML válido, también puede invocar los métodos de convertidor obteniendo una instancia de <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span><span class="sxs-lookup"><span data-stu-id="62338-264">If you have a valid XAML schema context, you can also invoke the converter methods by obtaining an instance from <xref:System.Xaml.Schema.XamlValueConverter%601.ConverterInstance%2A>.</span></span>

### <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="62338-265">Extensiones de marcado en el flujo de nodo XAML</span><span class="sxs-lookup"><span data-stu-id="62338-265">Markup Extensions in the XAML Node Stream</span></span>

<span data-ttu-id="62338-266">El uso de una extensión de marcado se notifica en el flujo de nodo XAML como un nodo de objeto dentro de un miembro, donde el objeto representa una instancia de la extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="62338-266">A markup extension usage is reported in the XAML node stream as an object node within a member, where the object represents a markup extension instance.</span></span> <span data-ttu-id="62338-267">Por lo tanto, el uso de una extensión de marcado se presenta más explícitamente en la representación del flujo de nodo que el uso de un convertidor de tipos, y contiene más información.</span><span class="sxs-lookup"><span data-stu-id="62338-267">Thus a markup extension usage is presented more explicitly in the node stream representation than a type converter usage is, and carries more information.</span></span> <span data-ttu-id="62338-268">La información de<xref:System.Xaml.XamlMember> podría no mencionar nada sobre la extensión de marcado, ya que el uso es situacional y varía en cada caso de marcado posible; no es dedicado ni implícito por tipo o miembro, como es el caso de los convertidores de tipos.</span><span class="sxs-lookup"><span data-stu-id="62338-268"><xref:System.Xaml.XamlMember> information could not have told you anything about the markup extension, because the usage is situational and varies in each possible markup case; it is not dedicated and implicit per type or member as is the case with type converters.</span></span>

<span data-ttu-id="62338-269">La representación del flujo de nodo de las extensiones de marcado como nodos de objeto es el caso incluso si el uso de la extensión de marcado se realizó en forma de atributo en el marcado de texto XAML (que suele ser el caso).</span><span class="sxs-lookup"><span data-stu-id="62338-269">The node stream representation of markup extensions as object nodes is the case even if the markup extension usage was made in attribute form in the XAML text markup (which is often the case).</span></span> <span data-ttu-id="62338-270">Los usos de la extensión de marcado que utilizaron un formulario de elemento de objeto explícito se tratan del mismo modo.</span><span class="sxs-lookup"><span data-stu-id="62338-270">Markup extension usages that used an explicit object element form are treated the same way.</span></span>

<span data-ttu-id="62338-271">Dentro de un nodo de objeto de extensión de marcado, puede haber miembros de esa extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="62338-271">Within a markup extension object node, there may be members of that markup extension.</span></span> <span data-ttu-id="62338-272">La representación del flujo de nodo XAML conserva el uso de esa extensión de marcado, ya sea un uso de parámetro posicional o un uso con parámetros con nombre explícitos.</span><span class="sxs-lookup"><span data-stu-id="62338-272">The XAML node stream representation preserves the usage of that markup extension, whether that be a positional parameter usage or a usage with explicit named parameters.</span></span>

<span data-ttu-id="62338-273">Para un uso de parámetro posicional, el flujo de nodo XAML contiene una propiedad `_PositionalParameters` definida por el lenguaje XAML que graba el uso.</span><span class="sxs-lookup"><span data-stu-id="62338-273">For a positional parameter usage, the XAML node stream contains a XAML language-defined property `_PositionalParameters` that records the usage.</span></span> <span data-ttu-id="62338-274">Esta propiedad es una <xref:System.Collections.Generic.List%601> genérica con una restricción <xref:System.Object> .</span><span class="sxs-lookup"><span data-stu-id="62338-274">This property is a generic <xref:System.Collections.Generic.List%601> with <xref:System.Object> constraint.</span></span> <span data-ttu-id="62338-275">La restricción es un objeto y no una cadena, ya que cabe la posibilidad de que el uso de un parámetro posicional contenga los usos de la extensión de marcado anidados dentro de él.</span><span class="sxs-lookup"><span data-stu-id="62338-275">The constraint is object and not string because conceivably a positional parameter usage could contain nested markup extension usages within it.</span></span> <span data-ttu-id="62338-276">Para acceder a los parámetros posicionales desde el uso, puede iterar en la lista y usar los indizadores para los valores de lista individuales.</span><span class="sxs-lookup"><span data-stu-id="62338-276">To access the positional parameters from the usage, you could iterate through the list and use the indexers for individual list values.</span></span>

<span data-ttu-id="62338-277">Para un uso de parámetro con nombre, cada parámetro con nombre se representa como un nodo de miembro de ese nombre en el flujo de nodos.</span><span class="sxs-lookup"><span data-stu-id="62338-277">For a named parameter usage, each named parameter is represented as a member node of that name in the node stream.</span></span> <span data-ttu-id="62338-278">Los valores de miembro no son necesariamente cadenas, ya que podría haber un uso de una extensión de marcado anidado.</span><span class="sxs-lookup"><span data-stu-id="62338-278">The member values are not necessarily strings, because there could be a nested markup extension usage.</span></span>

<span data-ttu-id="62338-279">Todavía no se invoca`ProvideValue` en el marcado de extensión.</span><span class="sxs-lookup"><span data-stu-id="62338-279">`ProvideValue` from the markup extension is not yet invoked.</span></span> <span data-ttu-id="62338-280">Sin embargo, se invoca si conecta un lector de XAML y el escritor de XAML para que se invoque `WriteEndObject` en el nodo de la extensión de marcado cuando lo examina el flujo de nodo.</span><span class="sxs-lookup"><span data-stu-id="62338-280">However, it is invoked if you connect a XAML reader and XAML writer so that `WriteEndObject` is invoked on the markup extension node when you examine it in the node stream.</span></span> <span data-ttu-id="62338-281">Por esta razón, normalmente necesitará que esté disponible el mismo contexto de esquema XAML que se usaría para formar el gráfico de objetos en la ruta de acceso de carga.</span><span class="sxs-lookup"><span data-stu-id="62338-281">For this reason, you generally need the same XAML schema context available as would be used in order to form the object graph on the load path.</span></span> <span data-ttu-id="62338-282">De lo contrario, el `ProvideValue` de cualquier extensión de marcado puede producir excepciones aquí, ya que no tiene a su disposición los servicios esperados.</span><span class="sxs-lookup"><span data-stu-id="62338-282">Otherwise, `ProvideValue` from any markup extension can throw exceptions here, because it does not have expected services available.</span></span>

## <a name="xaml-and-xml-language-defined-members-in-the-xaml-node-stream"></a><span data-ttu-id="62338-283">Miembros definidos por el lenguaje XAML y XML en el flujo de nodo XAML</span><span class="sxs-lookup"><span data-stu-id="62338-283">XAML and XML Language-Defined Members in the XAML Node Stream</span></span>

<span data-ttu-id="62338-284">Ciertos miembros se introducen en un flujo de nodos XAML debido a las interpretaciones y las convenciones de un lector de XAML, en lugar de a través de una búsqueda o construcción de <xref:System.Xaml.XamlMember> explícitas.</span><span class="sxs-lookup"><span data-stu-id="62338-284">Certain members are introduced to a XAML node stream because of interpretations and conventions of a XAML reader, instead of through an explicit <xref:System.Xaml.XamlMember> lookup or construction.</span></span> <span data-ttu-id="62338-285">A menudo, estos miembros son directivas XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-285">Often, these members are XAML directives.</span></span> <span data-ttu-id="62338-286">En algunos casos, es el hecho de leer el XAML lo que introduce la directiva en el flujo de nodos XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-286">In some cases, it is the act of reading the XAML that introduces the directive into the XAML node stream.</span></span> <span data-ttu-id="62338-287">En otras palabras, el texto XAML de entrada original no especificaba explícitamente la directiva miembro, pero el lector XAML inserta la directiva para satisfacer una convención XAML estructural y la información de informe en el flujo de nodo XAML antes de que se pierda esa información.</span><span class="sxs-lookup"><span data-stu-id="62338-287">In other words, the original input XAML text did not explicitly specify the member directive, but the XAML reader inserts the directive in order to satisfy a structural XAML convention and report information in the XAML node stream before that information is lost.</span></span>

<span data-ttu-id="62338-288">En la lista siguiente se indican todos los casos en los que se espera que un lector XAML introduzca un nodo miembro XAML de directiva y cómo se identifica ese nodo miembro en las implementaciones de servicios XAML de .NET.</span><span class="sxs-lookup"><span data-stu-id="62338-288">The following list notes all cases where a XAML reader is expected to introduce a directive XAML member node, and how that member node is identified in .NET XAML Services implementations.</span></span>

- <span data-ttu-id="62338-289">**Texto de inicialización para un nodo de objeto:** el nombre de este nodo de miembro es `_Initialization`. Representa una directiva XAML y se define en el espacio de nombres XAML del lenguaje XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-289">**Initialization text for an object node:** The name of this member node is `_Initialization`, it represents a XAML directive, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="62338-290">Puede obtener una entidad estática desde <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span><span class="sxs-lookup"><span data-stu-id="62338-290">You can get a static entity for it from <xref:System.Xaml.XamlLanguage.Initialization%2A>.</span></span>

- <span data-ttu-id="62338-291">**Parámetros posicionales para una extensión de marcado:** el nombre de este nodo de miembro es `_PositionalParameters`, y se define en el espacio de nombres XAML del lenguaje XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-291">**Positional parameters for a markup extension:** The name of this member node is `_PositionalParameters`, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="62338-292">Siempre contiene una lista genérica de objetos, cada uno de los cuales es un parámetro posicional separado previamente dividiendo en el carácter delimitador de `,` , tal como se suministra en el XAML de entrada.</span><span class="sxs-lookup"><span data-stu-id="62338-292">It always contains a generic list of objects, each of which is a positional parameter pre-separated by splitting on the `,` delimiter character as supplied in the input XAML.</span></span> <span data-ttu-id="62338-293">Puede obtener una entidad estática para la directiva de parámetros posicionales de <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span><span class="sxs-lookup"><span data-stu-id="62338-293">You can get a static entity for the positional parameters directive from <xref:System.Xaml.XamlLanguage.PositionalParameters%2A>.</span></span>

- <span data-ttu-id="62338-294">**Contenido desconocido:** el nombre de este nodo de miembro es `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="62338-294">**Unknown content:** The name of this member node is `_UnknownContent`.</span></span> <span data-ttu-id="62338-295">En realidad, es una <xref:System.Xaml.XamlDirective>, y se define en el espacio de nombres XAML del lenguaje XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-295">Strictly speaking, it is a <xref:System.Xaml.XamlDirective>, and it is defined in the XAML language XAML namespace.</span></span> <span data-ttu-id="62338-296">Esta directiva se usa como centinela para los casos en que un elemento de objeto XAML incluye contenido en el XAML de origen, pero no puede determinarse ninguna propiedad de contenido en el contexto de esquema XAML que está disponible actualmente.</span><span class="sxs-lookup"><span data-stu-id="62338-296">This directive is used as a sentinel for cases where a XAML object element contains content in the source XAML but no content property can be determined under the currently available XAML schema context.</span></span> <span data-ttu-id="62338-297">Puede detectar este caso en un flujo de nodo XAML buscando los miembros denominados `_UnknownContent`.</span><span class="sxs-lookup"><span data-stu-id="62338-297">You can detect this case in a XAML node stream by checking for members named `_UnknownContent`.</span></span> <span data-ttu-id="62338-298">Si no se realiza ninguna otra acción en un flujo de nodo XAML de ruta de acceso de carga, se produce el valor predeterminado <xref:System.Xaml.XamlObjectWriter> en un intento de `WriteEndObject` cuando encuentra el miembro `_UnknownContent` en cualquier objeto.</span><span class="sxs-lookup"><span data-stu-id="62338-298">If no other action is taken in a load path XAML node stream, the default <xref:System.Xaml.XamlObjectWriter> throws on attempted `WriteEndObject` when it encounters the `_UnknownContent` member on any object.</span></span> <span data-ttu-id="62338-299">El valor predeterminado <xref:System.Xaml.XamlXmlWriter> no se produce y trata el miembro como implícito.</span><span class="sxs-lookup"><span data-stu-id="62338-299">The default <xref:System.Xaml.XamlXmlWriter> does not throw, and treats the member as implicit.</span></span> <span data-ttu-id="62338-300">Puede obtener una entidad estática para `_UnknownContent` desde <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span><span class="sxs-lookup"><span data-stu-id="62338-300">You can get a static entity for `_UnknownContent` from <xref:System.Xaml.XamlLanguage.UnknownContent%2A>.</span></span>

- <span data-ttu-id="62338-301">**Propiedad Collection de una colección:** Aunque el tipo CLR de respaldo de una clase de colección que se usa para XAML normalmente tiene una propiedad con nombre dedicada que contiene los elementos de colección, esa propiedad no es conocida por un sistema de tipos XAML antes de la resolución de tipos de respaldo.</span><span class="sxs-lookup"><span data-stu-id="62338-301">**Collection property of a collection:** Although the backing CLR type of a collection class that is used for XAML usually has a dedicated named property that holds the collection items, that property is not known to a XAML type system prior to backing type resolution.</span></span> <span data-ttu-id="62338-302">En su lugar, el flujo de nodo XAML introduce un marcador de posición `Items` como miembro del tipo XAML de la colección.</span><span class="sxs-lookup"><span data-stu-id="62338-302">Instead, the XAML node stream introduces an `Items` placeholder as a member of the collection XAML type.</span></span> <span data-ttu-id="62338-303">En la implementación de servicios XAML de .NET, el `_Items`nombre de esta directiva o miembro en el flujo de nodo es .</span><span class="sxs-lookup"><span data-stu-id="62338-303">In .NET XAML Services implementation, the name of this directive or member in the node stream is `_Items`.</span></span> <span data-ttu-id="62338-304">Puede obtenerse una constante para esta directiva a partir de <xref:System.Xaml.XamlLanguage.Items%2A>.</span><span class="sxs-lookup"><span data-stu-id="62338-304">A constant for this directive can be obtained from <xref:System.Xaml.XamlLanguage.Items%2A>.</span></span>

    <span data-ttu-id="62338-305">Tenga en cuenta que un flujo de nodo XAML puede contener una propiedad Items con elementos que resultan no ser analizables en función de la resolución de tipos de respaldo y el contexto de esquema XAML.</span><span class="sxs-lookup"><span data-stu-id="62338-305">Note that a XAML node stream might contain an Items property with items that turn out to not be parsable based on the backing type resolution and XAML schema context.</span></span> <span data-ttu-id="62338-306">Por ejemplo,</span><span class="sxs-lookup"><span data-stu-id="62338-306">For example,</span></span>

- <span data-ttu-id="62338-307">**Miembros definidos por XML:** El definido `xml:base`XML `xml:lang` `xml:space` y los miembros se `base` `lang`notifican `space` como directivas XAML denominadas , , y en las implementaciones de servicios XAML de .NET.</span><span class="sxs-lookup"><span data-stu-id="62338-307">**XML-defined members:** The XML-defined `xml:base`, `xml:lang` and `xml:space` members are reported as XAML directives named `base`, `lang`, and `space` in .NET XAML Services implementations.</span></span> <span data-ttu-id="62338-308">Su espacio de nombres es el espacio de nombres XML `http://www.w3.org/XML/1998/namespace`.</span><span class="sxs-lookup"><span data-stu-id="62338-308">The namespace for these is the XML namespace `http://www.w3.org/XML/1998/namespace`.</span></span> <span data-ttu-id="62338-309">Pueden obtenerse constantes para cada uno de ellos a partir de <xref:System.Xaml.XamlLanguage>.</span><span class="sxs-lookup"><span data-stu-id="62338-309">Constants for each of these can be obtained from <xref:System.Xaml.XamlLanguage>.</span></span>

## <a name="node-order"></a><span data-ttu-id="62338-310">Orden de los nodos</span><span class="sxs-lookup"><span data-stu-id="62338-310">Node Order</span></span>

<span data-ttu-id="62338-311">En algunos casos, <xref:System.Xaml.XamlXmlReader> cambia el orden de los nodos XAML en el flujo de nodo XAML, con respecto al orden en que aparecen los nodos si se vieran en el marcado o si se procesaran como XML.</span><span class="sxs-lookup"><span data-stu-id="62338-311">In some cases, <xref:System.Xaml.XamlXmlReader> changes the order of XAML nodes in the XAML node stream, versus the order the nodes appear if viewed in the markup or if processed as XML.</span></span> <span data-ttu-id="62338-312">La finalidad es ordenar los nodos de modo que un <xref:System.Xaml.XamlObjectWriter> pueda procesar el flujo de nodos en modo de solo avance.</span><span class="sxs-lookup"><span data-stu-id="62338-312">This is done in order to order the nodes such that a <xref:System.Xaml.XamlObjectWriter> can process the node stream in a forward-only manner.</span></span>  <span data-ttu-id="62338-313">En los servicios XAML de .NET, el lector XAML reordena los nodos en lugar de dejar esta tarea al escritor XAML, como una optimización del rendimiento para los consumidores de escritores de objetos XAML del flujo de nodos.</span><span class="sxs-lookup"><span data-stu-id="62338-313">In .NET XAML Services, the XAML reader reorders nodes rather than leaving this task to the XAML writer, as a performance optimization for XAML object writer consumers of the node stream.</span></span>

<span data-ttu-id="62338-314">Determinadas directivas están diseñadas específicamente para proporcionar más información para la creación de un objeto a partir de un elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="62338-314">Certain directives are intended specifically to provide more information for the creation of an object from an object element.</span></span> <span data-ttu-id="62338-315">Estas directivas son `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`y `Arguments`.</span><span class="sxs-lookup"><span data-stu-id="62338-315">These directives are: `Initialization`, `PositionalParameters`, `TypeArguments`, `FactoryMethod`, `Arguments`.</span></span> <span data-ttu-id="62338-316">Los lectores XAML de servicios XAML de .NET intentan colocar estas directivas `StartObject`como los primeros miembros en el flujo de nodo después de un objeto, por motivos que se explican en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="62338-316">.NET XAML Services XAML readers attempt to place these directives as the first members in the node stream following an object's `StartObject`, for reasons that are explained in the next section.</span></span>

### <a name="xamlobjectwriter-behavior-and-node-order"></a><span data-ttu-id="62338-317">Comportamiento de XamlObjectWriter y orden de los nodos</span><span class="sxs-lookup"><span data-stu-id="62338-317">XamlObjectWriter Behavior and Node Order</span></span>

<span data-ttu-id="62338-318">El`StartObject` de un <xref:System.Xaml.XamlObjectWriter> no es necesariamente una señal para que el escritor de objetos XAML construya inmediatamente la instancia del objeto.</span><span class="sxs-lookup"><span data-stu-id="62338-318">`StartObject` to a <xref:System.Xaml.XamlObjectWriter> is not necessarily a signal to the XAML object writer to immediately construct the object instance.</span></span> <span data-ttu-id="62338-319">XAML incluye varias características de lenguaje que permiten inicializar un objeto con entrada adicional y no depender por completo de invocar un constructor sin parámetros para generar el objeto inicial y solo entonces establecer propiedades.</span><span class="sxs-lookup"><span data-stu-id="62338-319">XAML includes several language features that make it possible to initialize an object with additional input, and to not rely entirely on invoking a parameterless constructor to produce the initial object, and only then setting properties.</span></span> <span data-ttu-id="62338-320">Estas características incluyen: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; texto de inicialización; [x:TypeArguments](xtypearguments-directive.md); parámetros posicionales de una extensión de marcado; métodos de generador y nodos [x:Arguments](xarguments-directive.md) asociados (XAML 2009).</span><span class="sxs-lookup"><span data-stu-id="62338-320">These features include: <xref:System.Windows.Markup.XamlDeferLoadAttribute>; initialization text; [x:TypeArguments](xtypearguments-directive.md); positional parameters of a markup extension; factory methods and associated [x:Arguments](xarguments-directive.md) nodes (XAML 2009).</span></span> <span data-ttu-id="62338-321">Cada uno de estos casos retrasa la construcción real del objeto y, dado que el flujo de nodo se reordena, el escritor de objetos XAML puede basarse en un comportamiento de construcción efectiva de la instancia siempre que se encuentre un miembro de inicio que no sea específicamente una directiva de construcción para ese tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="62338-321">Each of these cases delays the actual object construction, and because the node stream is reordered, the XAML object writer can rely on a behavior of actually constructing the instance whenever a start member is encountered that is not specifically a construction directive for that object type.</span></span>

### <a name="getobject"></a><span data-ttu-id="62338-322">GetObject</span><span class="sxs-lookup"><span data-stu-id="62338-322">GetObject</span></span>

<span data-ttu-id="62338-323">`GetObject` representa un nodo XAML donde, en lugar de construir un objeto nuevo, un escritor de objetos XAML obtiene el valor de la propiedad que contiene el objeto.</span><span class="sxs-lookup"><span data-stu-id="62338-323">`GetObject` represents a XAML node where rather than constructing a new object, a XAML object writer should instead get the value of the object's containing property.</span></span> <span data-ttu-id="62338-324">Un caso típico en el que se encuentra un nodo `GetObject` en un flujo de nodo XAML es para un objeto de colección o un objeto de diccionario, cuando la propiedad que lo contiene es deliberadamente de solo lectura en el modelo de objeto del tipo de respaldo.</span><span class="sxs-lookup"><span data-stu-id="62338-324">A typical  case where a `GetObject` node is encountered in a XAML node stream is for a collection object or a dictionary object, when the containing property is deliberately read-only in the backing type's object model.</span></span> <span data-ttu-id="62338-325">En este escenario, la colección o el diccionario suelen crearse e inicializarse (normalmente vacíos) mediante la lógica de inicialización de un tipo de propiedad.</span><span class="sxs-lookup"><span data-stu-id="62338-325">In this scenario, the collection or dictionary often is created and initialized (usually empty) by the initialization logic of an owning type.</span></span>

## <a name="see-also"></a><span data-ttu-id="62338-326">Consulte también</span><span class="sxs-lookup"><span data-stu-id="62338-326">See also</span></span>

- <xref:System.Xaml.XamlObjectReader>
- [<span data-ttu-id="62338-327">Servicios XAML</span><span class="sxs-lookup"><span data-stu-id="62338-327">XAML Services</span></span>](index.md)
- [<span data-ttu-id="62338-328">Espacios de nombres XAML</span><span class="sxs-lookup"><span data-stu-id="62338-328">XAML Namespaces</span></span>](namespaces.md)
