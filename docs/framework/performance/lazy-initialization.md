---
title: Inicialización diferida
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- lazy initialization in .NET, introduction
ms.assetid: 56b4ae5c-4745-44ff-ad78-ffe4fcde6b9b
ms.openlocfilehash: 4f2b585dded6e20bb604f623217c6d1f1505c097
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/12/2020
ms.locfileid: "79180563"
---
# <a name="lazy-initialization"></a><span data-ttu-id="c63ce-102">Inicialización diferida</span><span class="sxs-lookup"><span data-stu-id="c63ce-102">Lazy Initialization</span></span>
<span data-ttu-id="c63ce-103">La *inicialización diferida* de un objeto implica que su creación se aplaza hasta que se usa por primera vez.</span><span class="sxs-lookup"><span data-stu-id="c63ce-103">*Lazy initialization* of an object means that its creation is deferred until it is first used.</span></span> <span data-ttu-id="c63ce-104">(Para este tema, los términos *inicialización diferida* y creación de *instancias diferida* son sinónimos.) La inicialización diferida se utiliza principalmente para mejorar el rendimiento, evitar el cálculo despilfarradores y reducir los requisitos de memoria del programa.</span><span class="sxs-lookup"><span data-stu-id="c63ce-104">(For this topic, the terms *lazy initialization* and *lazy instantiation* are synonymous.) Lazy initialization is primarily used to improve performance, avoid wasteful computation, and reduce program memory requirements.</span></span> <span data-ttu-id="c63ce-105">Estos son los escenarios más comunes:</span><span class="sxs-lookup"><span data-stu-id="c63ce-105">These are the most common scenarios:</span></span>  
  
- <span data-ttu-id="c63ce-106">Cuando hay un objeto costoso de crear y es posible que el programa no lo use.</span><span class="sxs-lookup"><span data-stu-id="c63ce-106">When you have an object that is expensive to create, and the program might not use it.</span></span> <span data-ttu-id="c63ce-107">Por ejemplo, supongamos que tiene en memoria un objeto `Customer` con una propiedad `Orders` que contiene una matriz grande de objetos `Order` que, para inicializarse, requieren una conexión de base de datos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-107">For example, assume that you have in memory a `Customer` object that has an `Orders` property that contains a large array of `Order` objects that, to be initialized, requires a database connection.</span></span> <span data-ttu-id="c63ce-108">Si el usuario nunca solicita que se muestre Orders y nunca usa los datos en un cálculo, no hay ninguna razón para usar la memoria del sistema o ciclos de cálculos para crearlo.</span><span class="sxs-lookup"><span data-stu-id="c63ce-108">If the user never asks to display the Orders or use the data in a computation, then there is no reason to use system memory or computing cycles to create it.</span></span> <span data-ttu-id="c63ce-109">Mediante el uso de `Lazy<Orders>` para declarar el objeto `Orders` para la inicialización diferida, puede evitar desperdiciar recursos del sistema si no se usa el objeto.</span><span class="sxs-lookup"><span data-stu-id="c63ce-109">By using `Lazy<Orders>` to declare the `Orders` object for lazy initialization, you can avoid wasting system resources when the object is not used.</span></span>  
  
- <span data-ttu-id="c63ce-110">Cuando hay un objeto costoso de crear y quiere diferir su creación hasta después de que se hayan completado otras operaciones costosas.</span><span class="sxs-lookup"><span data-stu-id="c63ce-110">When you have an object that is expensive to create, and you want to defer its creation until after other expensive operations have been completed.</span></span> <span data-ttu-id="c63ce-111">Por ejemplo, supongamos que el programa carga varias instancias de objeto cuando se inicia, pero solo se necesitan de inmediato algunas de ellas.</span><span class="sxs-lookup"><span data-stu-id="c63ce-111">For example, assume that your program loads several object instances when it starts, but only some of them are required immediately.</span></span> <span data-ttu-id="c63ce-112">Puede mejorar el rendimiento de inicio del programa si difiere la inicialización de los objetos que no son necesarios hasta que se hayan creado los objetos necesarios.</span><span class="sxs-lookup"><span data-stu-id="c63ce-112">You can improve the startup performance of the program by deferring initialization of the objects that are not required until the required objects have been created.</span></span>  
  
 <span data-ttu-id="c63ce-113">Aunque puede escribir su propio código para llevar a cabo la inicialización diferida, recomendamos que use <xref:System.Lazy%601> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="c63ce-113">Although you can write your own code to perform lazy initialization, we recommend that you use <xref:System.Lazy%601> instead.</span></span> <span data-ttu-id="c63ce-114"><xref:System.Lazy%601> y sus tipos relacionados también admiten la seguridad para subprocesos y ofrecen una directiva coherente de propagación de excepciones.</span><span class="sxs-lookup"><span data-stu-id="c63ce-114"><xref:System.Lazy%601> and its related types also support thread-safety and provide a consistent exception propagation policy.</span></span>  
  
 <span data-ttu-id="c63ce-115">En la tabla siguiente se muestran los tipos que .NET Framework versión 4 proporciona para habilitar la inicialización diferida en distintos escenarios.</span><span class="sxs-lookup"><span data-stu-id="c63ce-115">The following table lists the types that the .NET Framework version 4 provides to enable lazy initialization in different scenarios.</span></span>  
  
|<span data-ttu-id="c63ce-116">Tipo</span><span class="sxs-lookup"><span data-stu-id="c63ce-116">Type</span></span>|<span data-ttu-id="c63ce-117">Descripción</span><span class="sxs-lookup"><span data-stu-id="c63ce-117">Description</span></span>|  
|----------|-----------------|  
|<xref:System.Lazy%601>|<span data-ttu-id="c63ce-118">Clase contenedora que proporciona semántica de inicialización diferida para cualquier biblioteca de clases o tipo definido por el usuario.</span><span class="sxs-lookup"><span data-stu-id="c63ce-118">A wrapper class that provides lazy initialization semantics for any class library or user-defined type.</span></span>|  
|<xref:System.Threading.ThreadLocal%601>|<span data-ttu-id="c63ce-119">Se parece a <xref:System.Lazy%601>, con la diferencia de que proporciona semántica de inicialización diferida para cada subproceso local.</span><span class="sxs-lookup"><span data-stu-id="c63ce-119">Resembles <xref:System.Lazy%601> except that it provides lazy initialization semantics on a thread-local basis.</span></span> <span data-ttu-id="c63ce-120">Cada subproceso tiene acceso a su propio valor único.</span><span class="sxs-lookup"><span data-stu-id="c63ce-120">Every thread has access to its own unique value.</span></span>|  
|<xref:System.Threading.LazyInitializer>|<span data-ttu-id="c63ce-121">Proporciona métodos `static` avanzados (`Shared` en Visual Basic) para la inicialización diferida de objetos sin la sobrecarga de una clase.</span><span class="sxs-lookup"><span data-stu-id="c63ce-121">Provides advanced `static` (`Shared` in Visual Basic) methods for lazy initialization of objects without the overhead of a class.</span></span>|  
  
## <a name="basic-lazy-initialization"></a><span data-ttu-id="c63ce-122">Inicialización diferida básica</span><span class="sxs-lookup"><span data-stu-id="c63ce-122">Basic Lazy Initialization</span></span>  
 <span data-ttu-id="c63ce-123">Para definir un tipo con inicialización diferida, como `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` en Visual Basic), como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="c63ce-123">To define a lazy-initialized type, for example, `MyType`, use `Lazy<MyType>` (`Lazy(Of MyType)` in Visual Basic), as shown in the following example.</span></span> <span data-ttu-id="c63ce-124">Si no se pasa ningún delegado en el constructor <xref:System.Lazy%601>, el tipo contenedor se crea mediante <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> cuando se tiene acceso por primera vez a la propiedad de valor.</span><span class="sxs-lookup"><span data-stu-id="c63ce-124">If no delegate is passed in the <xref:System.Lazy%601> constructor, the wrapped type is created by using <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> when the value property is first accessed.</span></span> <span data-ttu-id="c63ce-125">Si el tipo no tiene un constructor sin parámetros, se produce una excepción en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="c63ce-125">If the type does not have a parameterless constructor, a run-time exception is thrown.</span></span>  
  
 <span data-ttu-id="c63ce-126">En el ejemplo siguiente, supongamos que `Orders` es una clase que contiene una matriz de objetos `Order` recuperados de una base de datos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-126">In the following example, assume that `Orders` is a class that contains an array of `Order` objects retrieved from a database.</span></span> <span data-ttu-id="c63ce-127">Un objeto `Customer` contiene una instancia de `Orders`, pero en función de las acciones del usuario, los datos del objeto `Orders` podrían no ser necesarios.</span><span class="sxs-lookup"><span data-stu-id="c63ce-127">A `Customer` object contains an instance of `Orders`, but depending on user actions, the data from the `Orders` object might not be required.</span></span>  
  
 [!code-csharp[Lazy#1](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#1)]
 [!code-vb[Lazy#1](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#1)]  
  
 <span data-ttu-id="c63ce-128">También se puede pasar un delegado en el constructor <xref:System.Lazy%601> que invoca una sobrecarga de constructor específica en el tipo ajustado en tiempo de creación y realizar los pasos de inicialización que se requieran, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="c63ce-128">You can also pass a delegate in the <xref:System.Lazy%601> constructor that invokes a specific constructor overload on the wrapped type at creation time, and perform any other initialization steps that are required, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#2](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#2)]
 [!code-vb[Lazy#2](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#2)]  
  
 <span data-ttu-id="c63ce-129">Una vez que se ha creado el objeto diferido, no se crea ninguna instancia de `Orders` mientras no se tenga acceso por primera vez a la propiedad <xref:System.Lazy%601.Value%2A> de la variable Lazy.</span><span class="sxs-lookup"><span data-stu-id="c63ce-129">After the Lazy object is created, no instance of `Orders` is created until the <xref:System.Lazy%601.Value%2A> property of the Lazy variable is accessed for the first time.</span></span> <span data-ttu-id="c63ce-130">En el primer acceso, el tipo encapsulado se crea y se devuelve, y se almacena para cualquier acceso futuro.</span><span class="sxs-lookup"><span data-stu-id="c63ce-130">On first access, the wrapped type is created and returned, and stored for any future access.</span></span>  
  
 [!code-csharp[Lazy#3](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#3)]
 [!code-vb[Lazy#3](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#3)]  
  
 <span data-ttu-id="c63ce-131">Un objeto <xref:System.Lazy%601> siempre devuelve el mismo objeto o valor con el que se ha inicializado.</span><span class="sxs-lookup"><span data-stu-id="c63ce-131">A <xref:System.Lazy%601> object always returns the same object or value that it was initialized with.</span></span> <span data-ttu-id="c63ce-132">Por lo tanto, la propiedad <xref:System.Lazy%601.Value%2A> es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="c63ce-132">Therefore, the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="c63ce-133">Si <xref:System.Lazy%601.Value%2A> almacena un tipo de referencia, no se le puede asignar un nuevo objeto.</span><span class="sxs-lookup"><span data-stu-id="c63ce-133">If <xref:System.Lazy%601.Value%2A> stores a reference type, you cannot assign a new object to it.</span></span> <span data-ttu-id="c63ce-134">(Sin embargo, puede cambiar el valor de sus propiedades y campos públicos configurables.) Si <xref:System.Lazy%601.Value%2A> almacena un tipo de valor, no puede modificar su valor.</span><span class="sxs-lookup"><span data-stu-id="c63ce-134">(However, you can change the value of its settable public fields and properties.) If <xref:System.Lazy%601.Value%2A> stores a value type, you cannot modify its value.</span></span> <span data-ttu-id="c63ce-135">Aun así, puede crear una variable si invoca de nuevo el constructor de la variable con argumentos nuevos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-135">Nevertheless, you can create a new variable by invoking the variable constructor again by using new arguments.</span></span>  
  
 [!code-csharp[Lazy#4](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#4)]
 [!code-vb[Lazy#4](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#4)]  
  
 <span data-ttu-id="c63ce-136">La nueva instancia diferida, al igual que la anterior, no crea instancias de `Orders` mientras no se tenga acceso por primera vez a su propiedad <xref:System.Lazy%601.Value%2A>.</span><span class="sxs-lookup"><span data-stu-id="c63ce-136">The new lazy instance, like the earlier one, does not instantiate `Orders` until its <xref:System.Lazy%601.Value%2A> property is first accessed.</span></span>  
  
### <a name="thread-safe-initialization"></a><span data-ttu-id="c63ce-137">Inicialización segura para subprocesos</span><span class="sxs-lookup"><span data-stu-id="c63ce-137">Thread-Safe Initialization</span></span>  
 <span data-ttu-id="c63ce-138">De forma predeterminada, los objetos <xref:System.Lazy%601> son seguros para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-138">By default, <xref:System.Lazy%601> objects are thread-safe.</span></span> <span data-ttu-id="c63ce-139">Es decir, si el constructor no especifica el tipo de seguridad para subprocesos, los objetos <xref:System.Lazy%601> que crea son seguros para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-139">That is, if the constructor does not specify the kind of thread safety, the <xref:System.Lazy%601> objects it creates are thread-safe.</span></span> <span data-ttu-id="c63ce-140">En escenarios multiproceso, el primer subproceso que tiene acceso a la propiedad <xref:System.Lazy%601.Value%2A> de un objeto <xref:System.Lazy%601> seguro para subprocesos lo inicializa para todos los accesos siguientes en todos los subprocesos, y todos los subprocesos comparten los mismos datos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-140">In multi-threaded scenarios, the first thread to access the <xref:System.Lazy%601.Value%2A> property of a thread-safe <xref:System.Lazy%601> object initializes it for all subsequent accesses on all threads, and all threads share the same data.</span></span> <span data-ttu-id="c63ce-141">Por lo tanto, no importa qué subproceso inicializa el objeto y las condiciones de carrera son benignas.</span><span class="sxs-lookup"><span data-stu-id="c63ce-141">Therefore, it does not matter which thread initializes the object, and race conditions are benign.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c63ce-142">Puede ampliar esta coherencia a las condiciones de error mediante el uso del almacenamiento en caché de excepciones.</span><span class="sxs-lookup"><span data-stu-id="c63ce-142">You can extend this consistency to error conditions by using exception caching.</span></span> <span data-ttu-id="c63ce-143">Para obtener más información, vea la próxima sección titulada [Excepciones en objetos diferidos](lazy-initialization.md#ExceptionsInLazyObjects).</span><span class="sxs-lookup"><span data-stu-id="c63ce-143">For more information, see the next section, [Exceptions in Lazy Objects](lazy-initialization.md#ExceptionsInLazyObjects).</span></span>  
  
 <span data-ttu-id="c63ce-144">En el ejemplo siguiente se muestra que la instancia `Lazy<int>` tiene el mismo valor para tres subprocesos independientes.</span><span class="sxs-lookup"><span data-stu-id="c63ce-144">The following example shows that the same `Lazy<int>` instance has the same value for three separate threads.</span></span>  
  
 [!code-csharp[Lazy#8](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#8)]
 [!code-vb[Lazy#8](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#8)]  
  
 <span data-ttu-id="c63ce-145">Si necesita datos independientes en cada subproceso, use el tipo <xref:System.Threading.ThreadLocal%601>, como se describe más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="c63ce-145">If you require separate data on each thread, use the <xref:System.Threading.ThreadLocal%601> type, as described later in this topic.</span></span>  
  
 <span data-ttu-id="c63ce-146">Algunos constructores <xref:System.Lazy%601> tienen un parámetro booleano denominado `isThreadSafe` que se usa para especificar si se obtendrá acceso a la propiedad <xref:System.Lazy%601.Value%2A> desde varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-146">Some <xref:System.Lazy%601> constructors have a Boolean parameter named `isThreadSafe` that is used to specify whether the <xref:System.Lazy%601.Value%2A> property will be accessed from multiple threads.</span></span> <span data-ttu-id="c63ce-147">Si piensa tener acceso a la propiedad desde un solo subproceso, pase `false` para obtener una pequeña mejora en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="c63ce-147">If you intend to access the property from just one thread, pass in `false` to obtain a modest performance benefit.</span></span> <span data-ttu-id="c63ce-148">Si piensa tener acceso a la propiedad desde varios subprocesos, pase `true` para indicarle a la instancia <xref:System.Lazy%601> que controle correctamente las condiciones de carrera en las que un subproceso produce una excepción durante la inicialización.</span><span class="sxs-lookup"><span data-stu-id="c63ce-148">If you intend to access the property from multiple threads, pass in `true` to instruct the <xref:System.Lazy%601> instance to correctly handle race conditions in which one thread throws an exception at initialization time.</span></span>  
  
 <span data-ttu-id="c63ce-149">Algunos constructores <xref:System.Lazy%601> tienen un parámetro <xref:System.Threading.LazyThreadSafetyMode> denominado `mode`.</span><span class="sxs-lookup"><span data-stu-id="c63ce-149">Some <xref:System.Lazy%601> constructors have a <xref:System.Threading.LazyThreadSafetyMode> parameter named `mode`.</span></span> <span data-ttu-id="c63ce-150">Estos constructores proporcionan un modo adicional de seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-150">These constructors provide an additional thread safety mode.</span></span> <span data-ttu-id="c63ce-151">En la tabla siguiente se muestra la manera en que la seguridad para subprocesos de un objeto <xref:System.Lazy%601> se ve afectada por los parámetros del constructor que especifican la seguridad para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-151">The following table shows how the thread safety of a <xref:System.Lazy%601> object is affected by constructor parameters that specify thread safety.</span></span> <span data-ttu-id="c63ce-152">Cada constructor tiene como máximo un parámetro de este tipo.</span><span class="sxs-lookup"><span data-stu-id="c63ce-152">Each constructor has at most one such parameter.</span></span>  
  
|<span data-ttu-id="c63ce-153">Seguridad para subprocesos del objeto</span><span class="sxs-lookup"><span data-stu-id="c63ce-153">Thread safety of the object</span></span>|<span data-ttu-id="c63ce-154">`LazyThreadSafetyMode``mode` parámetro</span><span class="sxs-lookup"><span data-stu-id="c63ce-154">`LazyThreadSafetyMode` `mode` parameter</span></span>|<span data-ttu-id="c63ce-155">Parámetro booleano `isThreadSafe`</span><span class="sxs-lookup"><span data-stu-id="c63ce-155">Boolean `isThreadSafe` parameter</span></span>|<span data-ttu-id="c63ce-156">Sin parámetros de seguridad para subprocesos</span><span class="sxs-lookup"><span data-stu-id="c63ce-156">No thread safety parameters</span></span>|  
|---------------------------------|---------------------------------------------|--------------------------------------|---------------------------------|  
|<span data-ttu-id="c63ce-157">Totalmente seguro para subprocesos; solo intenta inicializar el valor un subproceso de cada vez.</span><span class="sxs-lookup"><span data-stu-id="c63ce-157">Fully thread-safe; only one thread at a time tries to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|<span data-ttu-id="c63ce-158">Sí.</span><span class="sxs-lookup"><span data-stu-id="c63ce-158">Yes.</span></span>|  
|<span data-ttu-id="c63ce-159">No es seguro para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-159">Not thread-safe.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|<span data-ttu-id="c63ce-160">No aplicable.</span><span class="sxs-lookup"><span data-stu-id="c63ce-160">Not applicable.</span></span>|  
|<span data-ttu-id="c63ce-161">Totalmente seguro para subprocesos; los subprocesos se apresuran a inicializar el valor.</span><span class="sxs-lookup"><span data-stu-id="c63ce-161">Fully thread-safe; threads race to initialize the value.</span></span>|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|<span data-ttu-id="c63ce-162">No aplicable.</span><span class="sxs-lookup"><span data-stu-id="c63ce-162">Not applicable.</span></span>|<span data-ttu-id="c63ce-163">No aplicable.</span><span class="sxs-lookup"><span data-stu-id="c63ce-163">Not applicable.</span></span>|  
  
 <span data-ttu-id="c63ce-164">Como se muestra en la tabla, especificar <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> para el parámetro `mode` equivale a especificar `true` para el parámetro `isThreadSafe`, y especificar <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> equivale a especificar `false`.</span><span class="sxs-lookup"><span data-stu-id="c63ce-164">As the table shows, specifying <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> for the `mode` parameter is the same as specifying `true` for the `isThreadSafe` parameter, and specifying <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> is the same as specifying `false`.</span></span>  
  
 <span data-ttu-id="c63ce-165">Si se especifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, varios subprocesos pueden intentar inicializar la instancia <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="c63ce-165">Specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> allows multiple threads to attempt to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="c63ce-166">Solo un subproceso puede ganar esta carrera, y los demás subprocesos recibirán el valor que haya inicializado el subproceso ganador.</span><span class="sxs-lookup"><span data-stu-id="c63ce-166">Only one thread can win this race, and all the other threads receive the value that was initialized by the successful thread.</span></span> <span data-ttu-id="c63ce-167">Si se produce una excepción en un subproceso durante la inicialización, dicho subproceso no recibe el valor establecido por el subproceso ganador.</span><span class="sxs-lookup"><span data-stu-id="c63ce-167">If an exception is thrown on a thread during initialization, that thread does not receive the value set by the successful thread.</span></span> <span data-ttu-id="c63ce-168">Las excepciones no se almacenan en caché, por lo que un intento posterior para tener acceso a la propiedad <xref:System.Lazy%601.Value%2A> puede dar lugar a un inicialización correcta.</span><span class="sxs-lookup"><span data-stu-id="c63ce-168">Exceptions are not cached, so a subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property can result in successful initialization.</span></span> <span data-ttu-id="c63ce-169">Esto difiere de la manera en que se tratan las excepciones en otros modos, como se describe en la sección siguiente.</span><span class="sxs-lookup"><span data-stu-id="c63ce-169">This differs from the way exceptions are treated in other modes, which is described in the following section.</span></span> <span data-ttu-id="c63ce-170">Para obtener más información, vea la enumeración <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="c63ce-170">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
<a name="ExceptionsInLazyObjects"></a>
## <a name="exceptions-in-lazy-objects"></a><span data-ttu-id="c63ce-171">Excepciones en objetos diferidos</span><span class="sxs-lookup"><span data-stu-id="c63ce-171">Exceptions in Lazy Objects</span></span>  
 <span data-ttu-id="c63ce-172">Como ya se ha indicado, un objeto <xref:System.Lazy%601> siempre devuelve el mismo objeto o valor con el que se ha inicializado y, por tanto, la propiedad <xref:System.Lazy%601.Value%2A> es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="c63ce-172">As stated earlier, a <xref:System.Lazy%601> object always returns the same object or value that it was initialized with, and therefore the <xref:System.Lazy%601.Value%2A> property is read-only.</span></span> <span data-ttu-id="c63ce-173">Si habilita el almacenamiento en caché de excepciones, esta inmutabilidad también se aplica al comportamiento de las excepciones.</span><span class="sxs-lookup"><span data-stu-id="c63ce-173">If you enable exception caching, this immutability also extends to exception behavior.</span></span> <span data-ttu-id="c63ce-174">Si un objeto inicializado diferido tiene habilitado el almacenamiento en caché <xref:System.Lazy%601.Value%2A> de excepciones y produce una excepción de su <xref:System.Lazy%601.Value%2A> método de inicialización cuando se tiene acceso a la propiedad por primera vez, se produce la misma excepción en cada intento posterior de tener acceso a la propiedad.</span><span class="sxs-lookup"><span data-stu-id="c63ce-174">If a lazy-initialized object has exception caching enabled and throws an exception from its initialization method when the <xref:System.Lazy%601.Value%2A> property is first accessed, that same exception is thrown on every subsequent attempt to access the <xref:System.Lazy%601.Value%2A> property.</span></span> <span data-ttu-id="c63ce-175">En otras palabras, el constructor del tipo encapsulado nunca se vuelve a invocar, ni siquiera en escenarios multiproceso.</span><span class="sxs-lookup"><span data-stu-id="c63ce-175">In other words, the constructor of the wrapped type is never re-invoked, even in multithreaded scenarios.</span></span> <span data-ttu-id="c63ce-176">Por lo tanto, el objeto <xref:System.Lazy%601> no puede producir una excepción en un acceso y devolver un valor en un acceso posterior.</span><span class="sxs-lookup"><span data-stu-id="c63ce-176">Therefore, the <xref:System.Lazy%601> object cannot throw an exception on one access and return a value on a subsequent access.</span></span>  
  
 <span data-ttu-id="c63ce-177">El almacenamiento en caché de excepciones se habilita cuando se usa cualquier constructor <xref:System.Lazy%601?displayProperty=nameWithType> que toma un método de inicialización (un parámetro `valueFactory`); por ejemplo, se habilita cuando se usa el constructor `Lazy(T)(Func(T))`.</span><span class="sxs-lookup"><span data-stu-id="c63ce-177">Exception caching is enabled when you use any <xref:System.Lazy%601?displayProperty=nameWithType> constructor that takes an initialization method (`valueFactory` parameter); for example, it is enabled when you use the `Lazy(T)(Func(T))`constructor.</span></span> <span data-ttu-id="c63ce-178">Si el constructor también toma un valor <xref:System.Threading.LazyThreadSafetyMode> (un parámetro `mode`), especifique <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> o <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c63ce-178">If the constructor also takes a <xref:System.Threading.LazyThreadSafetyMode> value (`mode` parameter), specify <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> or <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c63ce-179">Al especificar un método de inicialización, se permite el almacenamiento en caché de excepciones para estos dos modos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-179">Specifying an initialization method enables exception caching for these two modes.</span></span> <span data-ttu-id="c63ce-180">El método de inicialización puede ser muy simple.</span><span class="sxs-lookup"><span data-stu-id="c63ce-180">The initialization method can be very simple.</span></span> <span data-ttu-id="c63ce-181">Por ejemplo, podría llamar al `T`constructor `new Lazy<Contents>(() => new Contents(), mode)` sin parámetros para: en C- o `New Lazy(Of Contents)(Function() New Contents())` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="c63ce-181">For example, it might call the parameterless constructor for `T`: `new Lazy<Contents>(() => new Contents(), mode)` in C#, or `New Lazy(Of Contents)(Function() New Contents())` in Visual Basic.</span></span> <span data-ttu-id="c63ce-182">Si usa un constructor <xref:System.Lazy%601?displayProperty=nameWithType> que no especifica un método de inicialización, las excepciones que inicie el constructor sin parámetros para `T` no se almacenarán en caché.</span><span class="sxs-lookup"><span data-stu-id="c63ce-182">If you use a <xref:System.Lazy%601?displayProperty=nameWithType> constructor that does not specify an initialization method, exceptions that are thrown by the parameterless constructor for `T` are not cached.</span></span> <span data-ttu-id="c63ce-183">Para obtener más información, vea la enumeración <xref:System.Threading.LazyThreadSafetyMode>.</span><span class="sxs-lookup"><span data-stu-id="c63ce-183">For more information, see the <xref:System.Threading.LazyThreadSafetyMode> enumeration.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="c63ce-184">Si crea un objeto <xref:System.Lazy%601> con el parámetro de constructor `isThreadSafe` establecido en `false` o el parámetro de constructor `mode` establecido en <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, debe tener acceso al objeto <xref:System.Lazy%601> desde un subproceso o proporcionar su propia sincronización.</span><span class="sxs-lookup"><span data-stu-id="c63ce-184">If you create a <xref:System.Lazy%601> object with the `isThreadSafe` constructor parameter set to `false` or the `mode` constructor parameter set to <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, you must access the <xref:System.Lazy%601> object from a single thread or provide your own synchronization.</span></span> <span data-ttu-id="c63ce-185">Esto se aplica a todos los aspectos del objeto, incluido el almacenamiento en caché de excepciones.</span><span class="sxs-lookup"><span data-stu-id="c63ce-185">This applies to all aspects of the object, including exception caching.</span></span>  
  
 <span data-ttu-id="c63ce-186">Como ya se ha indicado en la sección anterior, los objetos <xref:System.Lazy%601> creados al especificar <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> tratan las excepciones de forma diferente.</span><span class="sxs-lookup"><span data-stu-id="c63ce-186">As noted in the previous section, <xref:System.Lazy%601> objects created by specifying <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> treat exceptions differently.</span></span> <span data-ttu-id="c63ce-187">Con <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, varios subprocesos pueden competir para inicializar la instancia <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="c63ce-187">With <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>, multiple threads can compete to initialize the <xref:System.Lazy%601> instance.</span></span> <span data-ttu-id="c63ce-188">En este caso, las excepciones no se almacenan en caché y los intentos para obtener acceso a la propiedad <xref:System.Lazy%601.Value%2A> pueden continuar hasta que se complete la inicialización.</span><span class="sxs-lookup"><span data-stu-id="c63ce-188">In this case, exceptions are not cached, and attempts to access the <xref:System.Lazy%601.Value%2A> property can continue until initialization is successful.</span></span>  
  
 <span data-ttu-id="c63ce-189">En la tabla siguiente se resume la forma en que los constructores <xref:System.Lazy%601> controlan el almacenamiento en caché de excepciones.</span><span class="sxs-lookup"><span data-stu-id="c63ce-189">The following table summarizes the way the <xref:System.Lazy%601> constructors control exception caching.</span></span>  
  
|<span data-ttu-id="c63ce-190">Constructor</span><span class="sxs-lookup"><span data-stu-id="c63ce-190">Constructor</span></span>|<span data-ttu-id="c63ce-191">Modo de seguridad para subprocesos</span><span class="sxs-lookup"><span data-stu-id="c63ce-191">Thread safety mode</span></span>|<span data-ttu-id="c63ce-192">Usa método de inicialización</span><span class="sxs-lookup"><span data-stu-id="c63ce-192">Uses initialization method</span></span>|<span data-ttu-id="c63ce-193">Las excepciones se almacenan en caché</span><span class="sxs-lookup"><span data-stu-id="c63ce-193">Exceptions are cached</span></span>|  
|-----------------|------------------------|--------------------------------|---------------------------|  
|<span data-ttu-id="c63ce-194">Lazy(T)()</span><span class="sxs-lookup"><span data-stu-id="c63ce-194">Lazy(T)()</span></span>|<span data-ttu-id="c63ce-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="c63ce-195">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="c63ce-196">Sin </span><span class="sxs-lookup"><span data-stu-id="c63ce-196">No</span></span>|<span data-ttu-id="c63ce-197">Sin </span><span class="sxs-lookup"><span data-stu-id="c63ce-197">No</span></span>|  
|<span data-ttu-id="c63ce-198">Lazy(T)(Func(T))</span><span class="sxs-lookup"><span data-stu-id="c63ce-198">Lazy(T)(Func(T))</span></span>|<span data-ttu-id="c63ce-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span><span class="sxs-lookup"><span data-stu-id="c63ce-199">(<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>)</span></span>|<span data-ttu-id="c63ce-200">Sí</span><span class="sxs-lookup"><span data-stu-id="c63ce-200">Yes</span></span>|<span data-ttu-id="c63ce-201">Sí</span><span class="sxs-lookup"><span data-stu-id="c63ce-201">Yes</span></span>|  
|<span data-ttu-id="c63ce-202">Lazy(T)(Boolean)</span><span class="sxs-lookup"><span data-stu-id="c63ce-202">Lazy(T)(Boolean)</span></span>|<span data-ttu-id="c63ce-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) o `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="c63ce-203">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="c63ce-204">Sin </span><span class="sxs-lookup"><span data-stu-id="c63ce-204">No</span></span>|<span data-ttu-id="c63ce-205">Sin </span><span class="sxs-lookup"><span data-stu-id="c63ce-205">No</span></span>|  
|<span data-ttu-id="c63ce-206">Lazy(T)(Func(T), Boolean)</span><span class="sxs-lookup"><span data-stu-id="c63ce-206">Lazy(T)(Func(T), Boolean)</span></span>|<span data-ttu-id="c63ce-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) o `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span><span class="sxs-lookup"><span data-stu-id="c63ce-207">`True` (<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>) or `false` (<xref:System.Threading.LazyThreadSafetyMode.None>)</span></span>|<span data-ttu-id="c63ce-208">Sí</span><span class="sxs-lookup"><span data-stu-id="c63ce-208">Yes</span></span>|<span data-ttu-id="c63ce-209">Sí</span><span class="sxs-lookup"><span data-stu-id="c63ce-209">Yes</span></span>|  
|<span data-ttu-id="c63ce-210">Lazy(T)(LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="c63ce-210">Lazy(T)(LazyThreadSafetyMode)</span></span>|<span data-ttu-id="c63ce-211">Especificado por el usuario</span><span class="sxs-lookup"><span data-stu-id="c63ce-211">User-specified</span></span>|<span data-ttu-id="c63ce-212">Sin </span><span class="sxs-lookup"><span data-stu-id="c63ce-212">No</span></span>|<span data-ttu-id="c63ce-213">Sin </span><span class="sxs-lookup"><span data-stu-id="c63ce-213">No</span></span>|  
|<span data-ttu-id="c63ce-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span><span class="sxs-lookup"><span data-stu-id="c63ce-214">Lazy(T)(Func(T), LazyThreadSafetyMode)</span></span>|<span data-ttu-id="c63ce-215">Especificado por el usuario</span><span class="sxs-lookup"><span data-stu-id="c63ce-215">User-specified</span></span>|<span data-ttu-id="c63ce-216">Sí</span><span class="sxs-lookup"><span data-stu-id="c63ce-216">Yes</span></span>|<span data-ttu-id="c63ce-217">No si el usuario especifica <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; en caso contrario, sí.</span><span class="sxs-lookup"><span data-stu-id="c63ce-217">No if user specifies <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>; otherwise, yes.</span></span>|  
  
## <a name="implementing-a-lazy-initialized-property"></a><span data-ttu-id="c63ce-218">Implementar una propiedad con inicialización diferida</span><span class="sxs-lookup"><span data-stu-id="c63ce-218">Implementing a Lazy-Initialized Property</span></span>  
 <span data-ttu-id="c63ce-219">Para implementar una propiedad pública mediante la inicialización diferida, defina el campo de respaldo de la propiedad como <xref:System.Lazy%601> y devuelva la propiedad <xref:System.Lazy%601.Value%2A> desde el descriptor de acceso `get` de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="c63ce-219">To implement a public property by using lazy initialization, define the backing field of the property as a <xref:System.Lazy%601>, and return the <xref:System.Lazy%601.Value%2A> property from the `get` accessor of the property.</span></span>  
  
 [!code-csharp[Lazy#5](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#5)]
 [!code-vb[Lazy#5](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#5)]  
  
 <span data-ttu-id="c63ce-220">La propiedad <xref:System.Lazy%601.Value%2A> es de solo lectura; por lo tanto, la propiedad que la expone no tiene ningún descriptor de acceso `set`.</span><span class="sxs-lookup"><span data-stu-id="c63ce-220">The <xref:System.Lazy%601.Value%2A> property is read-only; therefore, the property that exposes it has no `set` accessor.</span></span> <span data-ttu-id="c63ce-221">Si necesita una propiedad de lectura/escritura respaldada por un objeto <xref:System.Lazy%601>, el descriptor de acceso `set` debe crear un objeto <xref:System.Lazy%601> y asignarlo a la memoria auxiliar.</span><span class="sxs-lookup"><span data-stu-id="c63ce-221">If you require a read/write property backed by a <xref:System.Lazy%601> object, the `set` accessor must create a new <xref:System.Lazy%601> object and assign it to the backing store.</span></span> <span data-ttu-id="c63ce-222">El descriptor de acceso `set` debe crear una expresión lambda que devuelva el nuevo valor de propiedad que se ha pasado al descriptor de acceso `set` y pasar dicha expresión lambda al constructor para el nuevo objeto <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="c63ce-222">The `set` accessor must create a lambda expression that returns the new property value that was passed to the `set` accessor, and pass that lambda expression to the constructor for the new <xref:System.Lazy%601> object.</span></span> <span data-ttu-id="c63ce-223">El siguiente acceso de la propiedad <xref:System.Lazy%601.Value%2A> provocará la inicialización del nuevo objeto <xref:System.Lazy%601>, y su propiedad <xref:System.Lazy%601.Value%2A> devolverá a partir de entonces el nuevo valor que se ha asignado a la propiedad.</span><span class="sxs-lookup"><span data-stu-id="c63ce-223">The next access of the <xref:System.Lazy%601.Value%2A> property will cause initialization of the new <xref:System.Lazy%601>, and its <xref:System.Lazy%601.Value%2A> property will thereafter return the new value that was assigned to the property.</span></span> <span data-ttu-id="c63ce-224">El objetivo de este complicado proceso consiste en conservar las protecciones multiproceso integradas en <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="c63ce-224">The reason for this convoluted arrangement is to preserve the multithreading protections built into <xref:System.Lazy%601>.</span></span> <span data-ttu-id="c63ce-225">De lo contrario, los descriptores de acceso de propiedad tendrían que almacenar en caché el primer valor devuelto por la propiedad <xref:System.Lazy%601.Value%2A> y modificar solo el valor almacenado en caché, y usted tendría que escribir su propio código seguro para subprocesos para hacerlo.</span><span class="sxs-lookup"><span data-stu-id="c63ce-225">Otherwise, the property accessors would have to cache the first value returned by the <xref:System.Lazy%601.Value%2A> property and only modify the cached value, and you would have to write your own thread-safe code to do that.</span></span> <span data-ttu-id="c63ce-226">Debido a las inicializaciones adicionales que requiere una propiedad de lectura/escritura respaldada por un objeto <xref:System.Lazy%601>, el rendimiento podría no ser aceptable.</span><span class="sxs-lookup"><span data-stu-id="c63ce-226">Because of the additional initializations required by a read/write property backed by a <xref:System.Lazy%601> object, the performance might not be acceptable.</span></span> <span data-ttu-id="c63ce-227">Además, en función del escenario, podría ser necesaria una coordinación adicional para evitar condiciones de carrera entre los establecedores y los captadores.</span><span class="sxs-lookup"><span data-stu-id="c63ce-227">Furthermore, depending on the specific scenario, additional coordination might be required to avoid race conditions between setters and getters.</span></span>  
  
## <a name="thread-local-lazy-initialization"></a><span data-ttu-id="c63ce-228">Inicialización diferida local de subprocesos</span><span class="sxs-lookup"><span data-stu-id="c63ce-228">Thread-Local Lazy Initialization</span></span>  
 <span data-ttu-id="c63ce-229">En algunos escenarios multiproceso, podría interesarle asignarle a cada subproceso sus propios datos privados.</span><span class="sxs-lookup"><span data-stu-id="c63ce-229">In some multithreaded scenarios, you might want to give each thread its own private data.</span></span> <span data-ttu-id="c63ce-230">Estos datos se denominan *datos locales de subproceso*.</span><span class="sxs-lookup"><span data-stu-id="c63ce-230">Such data is called *thread-local data*.</span></span> <span data-ttu-id="c63ce-231">En .NET Framework versión 3.5 y anteriores, se podía aplicar el atributo `ThreadStatic` a una variable estática para convertirla en una variable local de subproceso.</span><span class="sxs-lookup"><span data-stu-id="c63ce-231">In the .NET Framework version 3.5 and earlier, you could apply the `ThreadStatic` attribute to a static variable to make it thread-local.</span></span> <span data-ttu-id="c63ce-232">Pero el uso del atributo `ThreadStatic` puede producir pequeños errores.</span><span class="sxs-lookup"><span data-stu-id="c63ce-232">However, using the `ThreadStatic` attribute can lead to subtle errors.</span></span> <span data-ttu-id="c63ce-233">Por ejemplo, incluso las instrucciones de inicialización básicas harán que la variable solo se inicialice en el primer subproceso que tenga acceso a ella, tal como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="c63ce-233">For example, even basic initialization statements will cause the variable to be initialized only on the first thread that accesses it, as shown in the following example.</span></span>  
  
 [!code-csharp[Lazy#6](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#6)]
 [!code-vb[Lazy#6](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#6)]  
  
 <span data-ttu-id="c63ce-234">En todos los demás subprocesos, la variable se inicializará mediante su valor predeterminado (cero).</span><span class="sxs-lookup"><span data-stu-id="c63ce-234">On all other threads, the variable will be initialized by using its default value (zero).</span></span> <span data-ttu-id="c63ce-235">Como alternativa en .NET Framework versión 4, puede usar el tipo <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> para crear una variable local de subproceso basada en instancias que se inicialice en todos los subprocesos mediante el delegado <xref:System.Action%601> que proporcione.</span><span class="sxs-lookup"><span data-stu-id="c63ce-235">As an alternative in the .NET Framework version 4, you can use the <xref:System.Threading.ThreadLocal%601?displayProperty=nameWithType> type to create an instance-based, thread-local variable that is initialized on all threads by the <xref:System.Action%601> delegate that you provide.</span></span> <span data-ttu-id="c63ce-236">En el ejemplo siguiente, todos los subprocesos que tienen acceso a `counter` tendrán 1 como valor inicial.</span><span class="sxs-lookup"><span data-stu-id="c63ce-236">In the following example, all threads that access `counter` will see its starting value as 1.</span></span>  
  
 [!code-csharp[Lazy#7](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#7)]
 [!code-vb[Lazy#7](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#7)]  
  
 <span data-ttu-id="c63ce-237"><xref:System.Threading.ThreadLocal%601> encapsula el objeto de la misma manera que <xref:System.Lazy%601>, pero con estas diferencias básicas:</span><span class="sxs-lookup"><span data-stu-id="c63ce-237"><xref:System.Threading.ThreadLocal%601> wraps its object in much the same way as <xref:System.Lazy%601>, with these essential differences:</span></span>  
  
- <span data-ttu-id="c63ce-238">Cada subproceso inicializa la variable local de subproceso mediante sus propios datos privados, que no son accesibles desde otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-238">Each thread initializes the thread-local variable by using its own private data that is not accessible from other threads.</span></span>  
  
- <span data-ttu-id="c63ce-239">La propiedad <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> es de lectura y escritura y se puede modificar todas las veces que se quiera.</span><span class="sxs-lookup"><span data-stu-id="c63ce-239">The <xref:System.Threading.ThreadLocal%601.Value%2A?displayProperty=nameWithType> property is read-write, and can be modified any number of times.</span></span> <span data-ttu-id="c63ce-240">Esto puede afectar a la propagación de excepciones; por ejemplo, una operación `get` puede producir una excepción, pero la siguiente puede inicializar correctamente el valor.</span><span class="sxs-lookup"><span data-stu-id="c63ce-240">This can affect exception propagation, for example, one `get` operation can raise an exception but the next one can successfully initialize the value.</span></span>  
  
- <span data-ttu-id="c63ce-241">Si no se proporciona ningún delegado de inicialización, <xref:System.Threading.ThreadLocal%601> inicializará su tipo encapsulado mediante el valor predeterminado del tipo.</span><span class="sxs-lookup"><span data-stu-id="c63ce-241">If no initialization delegate is provided, <xref:System.Threading.ThreadLocal%601> will initialize its wrapped type by using the default value of the type.</span></span> <span data-ttu-id="c63ce-242">En este sentido, <xref:System.Threading.ThreadLocal%601> es coherente con el atributo <xref:System.ThreadStaticAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c63ce-242">In this regard, <xref:System.Threading.ThreadLocal%601> is consistent with the <xref:System.ThreadStaticAttribute> attribute.</span></span>  
  
 <span data-ttu-id="c63ce-243">En el ejemplo siguiente se muestra que cada subproceso que tiene acceso a la instancia `ThreadLocal<int>` obtiene su propia copia única de los datos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-243">The following example demonstrates that every thread that accesses the `ThreadLocal<int>` instance gets its own unique copy of the data.</span></span>  
  
 [!code-csharp[Lazy#9](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#9)]
 [!code-vb[Lazy#9](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#9)]  
  
## <a name="thread-local-variables-in-parallelfor-and-foreach"></a><span data-ttu-id="c63ce-244">Variables locales de subproceso en Parallel.For y ForEach</span><span class="sxs-lookup"><span data-stu-id="c63ce-244">Thread-Local Variables in Parallel.For and ForEach</span></span>  
 <span data-ttu-id="c63ce-245">Cuando se usa el método <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> o <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> para iterar en los orígenes de datos en paralelo, puede usar las sobrecargas que tienen compatibilidad integrada con datos locales de subproceso.</span><span class="sxs-lookup"><span data-stu-id="c63ce-245">When you use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method or <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method to iterate over data sources in parallel, you can use the overloads that have built-in support for thread-local data.</span></span> <span data-ttu-id="c63ce-246">En estos métodos, la localidad del subproceso se logra mediante el uso de delegados locales para crear los datos, obtener acceso a ellos y limpiarlos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-246">In these methods, the thread-locality is achieved by using local delegates to create, access, and clean up the data.</span></span> <span data-ttu-id="c63ce-247">Para obtener más información, vea [Cómo: Escribir un bucle Parallel.For con variables locales de subproceso](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) y [How to: Write a Parallel.ForEach Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md) (Cómo: Escribir un bucle Parallel.ForEach con variables locales de partición).</span><span class="sxs-lookup"><span data-stu-id="c63ce-247">For more information, see [How to: Write a Parallel.For Loop with Thread-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md) and [How to: Write a Parallel.ForEach Loop with Partition-Local Variables](../../standard/parallel-programming/how-to-write-a-parallel-foreach-loop-with-partition-local-variables.md).</span></span>  
  
## <a name="using-lazy-initialization-for-low-overhead-scenarios"></a><span data-ttu-id="c63ce-248">Usar la inicialización diferida para escenarios con poca sobrecarga</span><span class="sxs-lookup"><span data-stu-id="c63ce-248">Using Lazy Initialization for Low-Overhead Scenarios</span></span>  
 <span data-ttu-id="c63ce-249">En los escenarios en los que tiene que inicializar de forma diferida un gran número de objetos, podría decidir que el proceso de encapsular cada objeto en un objeto <xref:System.Lazy%601> requiere demasiada memoria o demasiados recursos informáticos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-249">In scenarios where you have to lazy-initialize a large number of objects, you might decide that wrapping each object in a <xref:System.Lazy%601> requires too much memory or too many computing resources.</span></span> <span data-ttu-id="c63ce-250">O bien, es posible que tenga requisitos estrictos sobre cómo se expone la inicialización diferida.</span><span class="sxs-lookup"><span data-stu-id="c63ce-250">Or, you might have stringent requirements about how lazy initialization is exposed.</span></span> <span data-ttu-id="c63ce-251">En tales casos, puede usar los métodos `static` (`Shared` en Visual Basic) de la clase <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> para inicializar de forma diferida cada objeto sin encapsularlo en una instancia de <xref:System.Lazy%601>.</span><span class="sxs-lookup"><span data-stu-id="c63ce-251">In such cases, you can use the `static` (`Shared` in Visual Basic) methods of the <xref:System.Threading.LazyInitializer?displayProperty=nameWithType> class to lazy-initialize each object without wrapping it in an instance of <xref:System.Lazy%601>.</span></span>  
  
 <span data-ttu-id="c63ce-252">En el ejemplo siguiente se da por supuesto que, en lugar de encapsular todo un objeto `Orders` en un objeto <xref:System.Lazy%601>, solo se inicializan de forma diferida los objetos `Order` individuales si son necesarios.</span><span class="sxs-lookup"><span data-stu-id="c63ce-252">In the following example, assume that, instead of wrapping an entire `Orders` object in one <xref:System.Lazy%601> object, you have lazy-initialized individual `Order` objects only if they are required.</span></span>  
  
 [!code-csharp[Lazy#10](../../../samples/snippets/csharp/VS_Snippets_Misc/lazy/cs/cs_lazycodefile.cs#10)]
 [!code-vb[Lazy#10](../../../samples/snippets/visualbasic/VS_Snippets_Misc/lazy/vb/lazy_vb.vb#10)]  
  
 <span data-ttu-id="c63ce-253">En este ejemplo, observe que el procedimiento de inicialización se invoca en cada iteración del bucle.</span><span class="sxs-lookup"><span data-stu-id="c63ce-253">In this example, notice that the initialization procedure is invoked on every iteration of the loop.</span></span> <span data-ttu-id="c63ce-254">En escenarios multiproceso, el primer subproceso que invoca el procedimiento de inicialización es aquel cuyo valor ven todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c63ce-254">In multi-threaded scenarios, the first thread to invoke the initialization procedure is the one whose value is seen by all threads.</span></span> <span data-ttu-id="c63ce-255">Los subprocesos posteriores también invocan el procedimiento de inicialización, pero sus resultados no se usan.</span><span class="sxs-lookup"><span data-stu-id="c63ce-255">Later threads also invoke the initialization procedure, but their results are not used.</span></span> <span data-ttu-id="c63ce-256">Si este tipo de condición de carrera potencial no es aceptable, use la sobrecarga de <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> que toma un argumento booleano y un objeto de sincronización.</span><span class="sxs-lookup"><span data-stu-id="c63ce-256">If this kind of potential race condition is not acceptable, use the overload of <xref:System.Threading.LazyInitializer.EnsureInitialized%2A?displayProperty=nameWithType> that takes a Boolean argument and a synchronization object.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="c63ce-257">Consulte también</span><span class="sxs-lookup"><span data-stu-id="c63ce-257">See also</span></span>

- [<span data-ttu-id="c63ce-258">Conceptos básicos de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="c63ce-258">Managed Threading Basics</span></span>](../../standard/threading/managed-threading-basics.md)
- [<span data-ttu-id="c63ce-259">Roscas y roscado</span><span class="sxs-lookup"><span data-stu-id="c63ce-259">Threads and Threading</span></span>](../../standard/threading/threads-and-threading.md)
- [<span data-ttu-id="c63ce-260">Biblioteca de procesamiento paralelo basado en tareas (TPL)</span><span class="sxs-lookup"><span data-stu-id="c63ce-260">Task Parallel Library (TPL)</span></span>](../../standard/parallel-programming/task-parallel-library-tpl.md)
- [<span data-ttu-id="c63ce-261">Cómo: Realizar la inicialización diferida de objetos</span><span class="sxs-lookup"><span data-stu-id="c63ce-261">How to: Perform Lazy Initialization of Objects</span></span>](how-to-perform-lazy-initialization-of-objects.md)
