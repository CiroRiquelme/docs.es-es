---
title: Implementación del patrón de interruptor
description: Aprenda a implementar el patrón de interruptor como un sistema complementario en los reintentos HTTP.
ms.date: 03/03/2020
ms.openlocfilehash: bebe0b4a622db928175f78f8d3e303d3d7adf170
ms.sourcegitcommit: e3cbf26d67f7e9286c7108a2752804050762d02d
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 04/09/2020
ms.locfileid: "80988890"
---
# <a name="implement-the-circuit-breaker-pattern"></a><span data-ttu-id="cb3a0-103">Implementación del patrón de interruptor</span><span class="sxs-lookup"><span data-stu-id="cb3a0-103">Implement the Circuit Breaker pattern</span></span>

<span data-ttu-id="cb3a0-104">Tal y como se indicó anteriormente, debe controlar los errores que pueden comportar un tiempo variable de recuperación, como puede suceder al intentar conectarse a un recurso o servicio remoto.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-104">As noted earlier, you should handle faults that might take a variable amount of time to recover from, as might happen when you try to connect to a remote service or resource.</span></span> <span data-ttu-id="cb3a0-105">Controlar este tipo de error puede mejorar la estabilidad y la resistencia de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-105">Handling this type of fault can improve the stability and resiliency of an application.</span></span>

<span data-ttu-id="cb3a0-106">En un entorno distribuido, las llamadas a servicios y recursos remotos pueden producir errores causados por errores transitorios, como tiempos de espera y conexiones de red lentas, o si los recursos responden de forma lenta o no están disponibles temporalmente.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-106">In a distributed environment, calls to remote resources and services can fail due to transient faults, such as slow network connections and timeouts, or if resources are responding slowly or are temporarily unavailable.</span></span> <span data-ttu-id="cb3a0-107">Estos errores suelen corregirse solos pasado un tiempo, y una aplicación en la nube sólida debería estar preparada para controlarlos mediante el uso de una estrategia como el "Patrón de reintento".</span><span class="sxs-lookup"><span data-stu-id="cb3a0-107">These faults typically correct themselves after a short time, and a robust cloud application should be prepared to handle them by using a strategy like the "Retry pattern".</span></span>

<span data-ttu-id="cb3a0-108">Pero también puede haber situaciones en que los errores se deban a eventos imprevistos que pueden tardar mucho más tiempo en corregirse.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-108">However, there can also be situations where faults are due to unanticipated events that might take much longer to fix.</span></span> <span data-ttu-id="cb3a0-109">La gravedad de estos errores puede ir desde una pérdida parcial de conectividad hasta el fallo total del servicio.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-109">These faults can range in severity from a partial loss of connectivity to the complete failure of a service.</span></span> <span data-ttu-id="cb3a0-110">En estas situaciones, no tiene sentido que una aplicación reintente continuamente una operación que es probable que no se lleve a cabo correctamente.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-110">In these situations, it might be pointless for an application to continually retry an operation that's unlikely to succeed.</span></span>

<span data-ttu-id="cb3a0-111">Lo que debe hacer la aplicación es codificarse para aceptar que la operación ha fallado y controlar el error en consecuencia.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-111">Instead, the application should be coded to accept that the operation has failed and handle the failure accordingly.</span></span>

<span data-ttu-id="cb3a0-112">El uso de los reintentos HTTP de forma descuidada podría crear ataques por denegación de servicio ([DoS](https://en.wikipedia.org/wiki/Denial-of-service_attack)) dentro de su propio software.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-112">Using Http retries carelessly could result in creating a Denial of Service ([DoS](https://en.wikipedia.org/wiki/Denial-of-service_attack)) attack within your own software.</span></span> <span data-ttu-id="cb3a0-113">Cuando se produce un error en un microservicio o se ejecuta lentamente, es posible que varios clientes reintenten solicitudes con error de forma repetida.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-113">As a microservice fails or performs slowly, multiple clients might repeatedly retry failed requests.</span></span> <span data-ttu-id="cb3a0-114">Eso genera un riesgo peligroso de que el tráfico destinado al servicio con errores aumente de manera exponencial.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-114">That creates a dangerous risk of exponentially increasing traffic targeted at the failing service.</span></span>

<span data-ttu-id="cb3a0-115">Por tanto, se necesita algún tipo de barrera de defensa para que se detengan las solicitudes excesivas cuando ya no tiene sentido seguir intentándolo.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-115">Therefore, you need some kind of defense barrier so that excessive requests stop when it isn't worth to keep trying.</span></span> <span data-ttu-id="cb3a0-116">Esa barrera de defensa es precisamente el interruptor.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-116">That defense barrier is precisely the circuit breaker.</span></span>

<span data-ttu-id="cb3a0-117">El patrón de interruptor tiene una finalidad distinta a la del "patrón de reintento".</span><span class="sxs-lookup"><span data-stu-id="cb3a0-117">The Circuit Breaker pattern has a different purpose than the "Retry pattern".</span></span> <span data-ttu-id="cb3a0-118">El "patrón de reintento" permite que una aplicación reintente una operación con la expectativa de que finalmente se realice correctamente.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-118">The "Retry pattern" enables an application to retry an operation in the expectation that the operation will eventually succeed.</span></span> <span data-ttu-id="cb3a0-119">El patrón de interruptor impide que una aplicación realice una operación que es probable que falle.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-119">The Circuit Breaker pattern prevents an application from performing an operation that's likely to fail.</span></span> <span data-ttu-id="cb3a0-120">Una aplicación puede combinar estos dos patrones.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-120">An application can combine these two patterns.</span></span> <span data-ttu-id="cb3a0-121">Pero la lógica de reintento debe ser sensible a las excepciones devueltas por el interruptor, y debe dejar de intentar repetir la operación si el interruptor indica que un error no es transitorio.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-121">However, the retry logic should be sensitive to any exception returned by the circuit breaker, and it should abandon retry attempts if the circuit breaker indicates that a fault is not transient.</span></span>

## <a name="implement-circuit-breaker-pattern-with-ihttpclientfactory-and-polly"></a><span data-ttu-id="cb3a0-122">Implementación de un patrón de interruptor con `IHttpClientFactory` y Polly</span><span class="sxs-lookup"><span data-stu-id="cb3a0-122">Implement Circuit Breaker pattern with `IHttpClientFactory` and Polly</span></span>

<span data-ttu-id="cb3a0-123">Como sucede al implementar los reintentos, el enfoque recomendado para los interruptores es aprovechar las bibliotecas .NET de eficacia probada como Polly y su integración nativa con `IHttpClientFactory`.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-123">As when implementing retries, the recommended approach for circuit breakers is to take advantage of proven .NET libraries like Polly and its native integration with `IHttpClientFactory`.</span></span>

<span data-ttu-id="cb3a0-124">Agregar una directiva de interruptor a la canalización de software intermedio saliente de `IHttpClientFactory` es tan sencillo como agregar un único fragmento de código incremental a lo que ya tiene cuando se usa `IHttpClientFactory`.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-124">Adding a circuit breaker policy into your `IHttpClientFactory` outgoing middleware pipeline is as simple as adding a single incremental piece of code to what you already have when using `IHttpClientFactory`.</span></span>

<span data-ttu-id="cb3a0-125">En este caso, lo único que se agrega al código que se usa para los reintentos de llamada HTTP es el código en el que se agrega la directiva de interruptor a la lista de directivas que se van a usar, como se muestra en el código incremental siguiente, parte del método ConfigureServices().</span><span class="sxs-lookup"><span data-stu-id="cb3a0-125">The only addition here to the code used for HTTP call retries is the code where you add the Circuit Breaker policy to the list of policies to use, as shown in the following incremental code, part of the ConfigureServices() method.</span></span>

```csharp
//ConfigureServices()  - Startup.cs
services.AddHttpClient<IBasketService, BasketService>()
        .SetHandlerLifetime(TimeSpan.FromMinutes(5))  //Sample. Default lifetime is 2 minutes
        .AddHttpMessageHandler<HttpClientAuthorizationDelegatingHandler>()
        .AddPolicyHandler(GetRetryPolicy())
        .AddPolicyHandler(GetCircuitBreakerPolicy());
```

<span data-ttu-id="cb3a0-126">El método `AddPolicyHandler()` es el que agrega las directivas a los objetos `HttpClient` que se van a usar.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-126">The `AddPolicyHandler()` method is what adds policies to the `HttpClient` objects you'll use.</span></span> <span data-ttu-id="cb3a0-127">En este caso, se agrega una directiva de Polly para un interruptor.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-127">In this case, it's adding a Polly policy for a circuit breaker.</span></span>

<span data-ttu-id="cb3a0-128">Para tener un enfoque más modular, la directiva de interruptor se define en un método independiente denominado `GetCircuitBreakerPolicy()`, como se muestra en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="cb3a0-128">To have a more modular approach, the Circuit Breaker Policy is defined in a separate method called `GetCircuitBreakerPolicy()`, as shown in the following code:</span></span>

```csharp
static IAsyncPolicy<HttpResponseMessage> GetCircuitBreakerPolicy()
{
    return HttpPolicyExtensions
        .HandleTransientHttpError()
        .CircuitBreakerAsync(5, TimeSpan.FromSeconds(30));
}
```

<span data-ttu-id="cb3a0-129">En el ejemplo de código anterior, la directiva de interruptor se configura para que interrumpa o abra el circuito cuando se hayan producido cinco fallos consecutivos al reintentar las solicitudes HTTP.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-129">In the code example above, the circuit breaker policy is configured so it breaks or opens the circuit when there have been five consecutive faults when retrying the Http requests.</span></span> <span data-ttu-id="cb3a0-130">Cuando esto ocurre, el circuito se interrumpirá durante 30 segundos. En ese período, las llamadas no se podrán realizar debido al interruptor del circuito.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-130">When that happens, the circuit will break for 30 seconds: in that period, calls will be failed immediately by the circuit-breaker rather than actually be placed.</span></span>  <span data-ttu-id="cb3a0-131">La directiva interpreta automáticamente las [excepciones relevantes y los códigos de estado HTTP](/aspnet/core/fundamentals/http-requests#handle-transient-faults) como errores.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-131">The policy automatically interprets [relevant exceptions and HTTP status codes](/aspnet/core/fundamentals/http-requests#handle-transient-faults) as faults.</span></span>  

<span data-ttu-id="cb3a0-132">Los interruptores también se deben usar para redirigir las solicitudes a una infraestructura de reserva siempre que haya tenido problemas en un recurso concreto implementado en otro entorno que no sea el de la aplicación cliente o del servicio que realiza la llamada HTTP.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-132">Circuit breakers should also be used to redirect requests to a fallback infrastructure if you had issues in a particular resource that's deployed in a different environment than the client application or service that's performing the HTTP call.</span></span> <span data-ttu-id="cb3a0-133">De este modo, si se produce una interrupción en el centro de datos que afecta solo a los microservicios de back-end, pero no a las aplicaciones cliente, estas aplicaciones pueden redirigir a los servicios de reserva.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-133">That way, if there's an outage in the datacenter that impacts only your backend microservices but not your client applications, the client applications can redirect to the fallback services.</span></span> <span data-ttu-id="cb3a0-134">Polly está creando una directiva nueva para automatizar este escenario de [directiva de conmutación por error](https://github.com/App-vNext/Polly/wiki/Polly-Roadmap#failover-policy).</span><span class="sxs-lookup"><span data-stu-id="cb3a0-134">Polly is planning a new policy to automate this [failover policy](https://github.com/App-vNext/Polly/wiki/Polly-Roadmap#failover-policy) scenario.</span></span>

<span data-ttu-id="cb3a0-135">Todas estas características sirven para los casos en los que se administra la conmutación por error desde el código .NET, y no cuando Azure lo hace de forma automática, con la transparencia de ubicación.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-135">All those features are for cases where you're managing the failover from within the .NET code, as opposed to having it managed automatically for you by Azure, with location transparency.</span></span>

<span data-ttu-id="cb3a0-136">Desde un punto de vista del uso, al utilizar HttpClient no hay necesidad de agregar nada nuevo aquí porque el código es el mismo que cuando se usa `HttpClient` con `IHttpClientFactory`, como se mostró en las secciones anteriores.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-136">From a usage point of view, when using HttpClient, there’s no need to add anything new here because the code is the same than when using `HttpClient` with `IHttpClientFactory`, as shown in previous sections.</span></span>

## <a name="test-http-retries-and-circuit-breakers-in-eshoponcontainers"></a><span data-ttu-id="cb3a0-137">Prueba de reintentos HTTP e interruptores en eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="cb3a0-137">Test Http retries and circuit breakers in eShopOnContainers</span></span>

<span data-ttu-id="cb3a0-138">Cada vez que inicie la solución eShopOnContainers en un host Docker, debe iniciar varios contenedores.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-138">Whenever you start the eShopOnContainers solution in a Docker host, it needs to start multiple containers.</span></span> <span data-ttu-id="cb3a0-139">Algunos de los contenedores tardan más en iniciarse e inicializarse, como el contenedor de SQL Server.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-139">Some of the containers are slower to start and initialize, like the SQL Server container.</span></span> <span data-ttu-id="cb3a0-140">Esto sucede especialmente la primera vez que implementa la aplicación eShopOnContainers en Docker, porque las imágenes y la base de datos se tienen que configurar.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-140">This is especially true the first time you deploy the eShopOnContainers application into Docker because it needs to set up the images and the database.</span></span> <span data-ttu-id="cb3a0-141">El hecho de que algunos contenedores se inicien más lentamente que otros puede provocar que el resto de servicios lancen inicialmente excepciones HTTP, aunque configure las dependencias entre contenedores en el nivel de Docker Compose, como se ha explicado en las secciones anteriores.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-141">The fact that some containers start slower than others can cause the rest of the services to initially throw HTTP exceptions, even if you set dependencies between containers at the docker-compose level, as explained in previous sections.</span></span> <span data-ttu-id="cb3a0-142">Las dependencias de Docker Compose entre contenedores solo se dan en el nivel de proceso.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-142">Those docker-compose dependencies between containers are just at the process level.</span></span> <span data-ttu-id="cb3a0-143">El proceso de punto de entrada del contenedor se puede iniciar, pero podría ser que SQL Server no estuviera listo para las consultas.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-143">The container's entry point process might be started, but SQL Server might not be ready for queries.</span></span> <span data-ttu-id="cb3a0-144">El resultado puede ser una cascada de errores y la aplicación puede obtener una excepción al intentar utilizar dicho contenedor.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-144">The result can be a cascade of errors, and the application can get an exception when trying to consume that particular container.</span></span>

<span data-ttu-id="cb3a0-145">Este tipo de error también puede darse en el inicio, cuando la aplicación se está implementando en la nube.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-145">You might also see this type of error on startup when the application is deploying to the cloud.</span></span> <span data-ttu-id="cb3a0-146">En ese caso, podría ser que los orquestadores movieran los contenedores de un nodo o máquina virtual a otro (iniciando así nuevas instancias) al repartir equitativamente los contenedores entre los nodos de clúster.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-146">In that case, orchestrators might be moving containers from one node or VM to another (that is, starting new instances) when balancing the number of containers across the cluster's nodes.</span></span>

<span data-ttu-id="cb3a0-147">La forma en que estos problemas se solucionan al iniciar todos los contenedores en "eShopOnContainers" es mediante el patrón de reintento mostrado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-147">The way 'eShopOnContainers' solves those issues when starting all the containers is by using the Retry pattern illustrated earlier.</span></span>

### <a name="test-the-circuit-breaker-in-eshoponcontainers"></a><span data-ttu-id="cb3a0-148">Prueba del interruptor en eShopOnContainers</span><span class="sxs-lookup"><span data-stu-id="cb3a0-148">Test the circuit breaker in eShopOnContainers</span></span>

<span data-ttu-id="cb3a0-149">Hay varias formas de interrumpir y abrir el circuito, y probarlo con eShopOnContainers.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-149">There are a few ways you can break/open the circuit and test it with eShopOnContainers.</span></span>

<span data-ttu-id="cb3a0-150">Una opción es reducir el número permitido de reintentos a 1 en la directiva del interruptor y volver a implementar la solución completa en Docker.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-150">One option is to lower the allowed number of retries to 1 in the circuit breaker policy and redeploy the whole solution into Docker.</span></span> <span data-ttu-id="cb3a0-151">Con un solo reintento, hay una gran probabilidad de que una solicitud HTTP falle durante la implementación, el interruptor se abra y se produzca un error.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-151">With a single retry, there's a good chance that an HTTP request will fail during deployment, the circuit breaker will open, and you get an error.</span></span>

<span data-ttu-id="cb3a0-152">Otra opción consiste en usar middleware personalizado que se implemente en el microservicio **Basket**.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-152">Another option is to use custom middleware that's implemented in the **Basket** microservice.</span></span> <span data-ttu-id="cb3a0-153">Al habilitar este middleware, detecta todas las solicitudes HTTP y devuelve el código de estado 500.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-153">When this middleware is enabled, it catches all HTTP requests and returns status code 500.</span></span> <span data-ttu-id="cb3a0-154">Para habilitar el middleware, envíe una solicitud GET al URI que falla, de forma similar a esta:</span><span class="sxs-lookup"><span data-stu-id="cb3a0-154">You can enable the middleware by making a GET request to the failing URI, like the following:</span></span>

- `GET http://localhost:5103/failing`\
  <span data-ttu-id="cb3a0-155">Esta solicitud devuelve el estado actual del middleware.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-155">This request returns the current state of the middleware.</span></span> <span data-ttu-id="cb3a0-156">Si el middleware está habilitado, la solicitud devuelve el código de estado 500.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-156">If the middleware is enabled, the request return status code 500.</span></span> <span data-ttu-id="cb3a0-157">Si el middleware está deshabilitado, no se emite ninguna respuesta.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-157">If the middleware is disabled, there's no response.</span></span>

- `GET http://localhost:5103/failing?enable`\
  <span data-ttu-id="cb3a0-158">Esta solicitud habilita el middleware.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-158">This request enables the middleware.</span></span>

- `GET http://localhost:5103/failing?disable`\
  <span data-ttu-id="cb3a0-159">Esta solicitud deshabilita el middleware.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-159">This request disables the middleware.</span></span>

<span data-ttu-id="cb3a0-160">Por ejemplo, cuando la aplicación se está ejecutando, puede habilitar el middleware realizando una solicitud con el siguiente URI en cualquier explorador.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-160">For instance, once the application is running, you can enable the middleware by making a request using the following URI in any browser.</span></span> <span data-ttu-id="cb3a0-161">Tenga en cuenta que el microservicio de ordenación utiliza el puerto 5103.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-161">Note that the ordering microservice uses port 5103.</span></span>

`http://localhost:5103/failing?enable`

<span data-ttu-id="cb3a0-162">Después, puede comprobar el estado mediante el URI `http://localhost:5103/failing`, como se muestra en la Figura 8-5.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-162">You can then check the status using the URI `http://localhost:5103/failing`, as shown in Figure 8-5.</span></span>

![Captura de pantalla de la comprobación del estado de una simulación de middleware con errores.](./media/implement-circuit-breaker-pattern/failing-middleware-simulation.png)

<span data-ttu-id="cb3a0-164">**Figura 8-5**.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-164">**Figure 8-5**.</span></span> <span data-ttu-id="cb3a0-165">Comprobación del estado del middleware ASP.NET "con errores": en este caso, deshabilitado.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-165">Checking the state of the "Failing" ASP.NET middleware – In this case, disabled.</span></span>

<span data-ttu-id="cb3a0-166">En este punto, el microservicio de la cesta responde con el código de estado 500 siempre que su llamada lo invoque.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-166">At this point, the Basket microservice responds with status code 500 whenever you call invoke it.</span></span>

<span data-ttu-id="cb3a0-167">Cuando se esté ejecutando el middleware, puede intentar realizar un pedido desde la aplicación web MVC.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-167">Once the middleware is running, you can try making an order from the MVC web application.</span></span> <span data-ttu-id="cb3a0-168">Como se produce un error en las solicitudes, el circuito se abre.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-168">Because the requests fail, the circuit will open.</span></span>

<span data-ttu-id="cb3a0-169">En el ejemplo siguiente, la aplicación web MVC presenta un bloque catch en la lógica para realizar un pedido.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-169">In the following example, you can see that the MVC web application has a catch block in the logic for placing an order.</span></span>  <span data-ttu-id="cb3a0-170">Si el código detecta una excepción de circuito abierto, muestra un mensaje descriptivo al usuario en que se le indica que espere.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-170">If the code catches an open-circuit exception, it shows the user a friendly message telling them to wait.</span></span>

```csharp
public class CartController : Controller
{
    //…
    public async Task<IActionResult> Index()
    {
        try
        {
            var user = _appUserParser.Parse(HttpContext.User);
            //Http requests using the Typed Client (Service Agent)
            var vm = await _basketSvc.GetBasket(user);
            return View(vm);
        }
        catch (BrokenCircuitException)
        {
            // Catches error when Basket.api is in circuit-opened mode
            HandleBrokenCircuitException();
        }
        return View();
    }

    private void HandleBrokenCircuitException()
    {
        TempData["BasketInoperativeMsg"] = "Basket Service is inoperative, please try later on. (Business message due to Circuit-Breaker)";
    }
}
```

<span data-ttu-id="cb3a0-171">Aquí tiene un resumen.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-171">Here's a summary.</span></span> <span data-ttu-id="cb3a0-172">La directiva de reintentos intenta realizar la solicitud HTTP varias veces y obtiene errores HTTP.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-172">The Retry policy tries several times to make the HTTP request and gets HTTP errors.</span></span> <span data-ttu-id="cb3a0-173">Cuando el número de reintentos alcanza el número máximo establecido para la directiva del interruptor (en este caso, 5), la aplicación genera una excepción BrokenCircuitException.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-173">When the number of retries reaches the maximum number set for the Circuit Breaker policy (in this case, 5), the application throws a BrokenCircuitException.</span></span> <span data-ttu-id="cb3a0-174">El resultado es un mensaje descriptivo, como el que se muestra en la Figura 8-6.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-174">The result is a friendly message, as shown in Figure 8-6.</span></span>

![Captura de pantalla de la aplicación web MVC con el error de servicio de cesta no operativo.](./media/implement-circuit-breaker-pattern/basket-service-inoperative.png)

<span data-ttu-id="cb3a0-176">**Figura 8-6**.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-176">**Figure 8-6**.</span></span> <span data-ttu-id="cb3a0-177">Interruptor que devuelve un error en la interfaz de usuario</span><span class="sxs-lookup"><span data-stu-id="cb3a0-177">Circuit breaker returning an error to the UI</span></span>

<span data-ttu-id="cb3a0-178">Puede implementar otra lógica que indique cuándo se debe abrir o interrumpir el circuito.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-178">You can implement different logic for when to open/break the circuit.</span></span> <span data-ttu-id="cb3a0-179">También puede probar una solicitud HTTP en un microservicio de back-end distinto si se dispone de un centro de datos de reserva o un sistema back-end redundante.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-179">Or you can try an HTTP request against a different back-end microservice if there's a fallback datacenter or redundant back-end system.</span></span>

<span data-ttu-id="cb3a0-180">Por último, otra posibilidad para `CircuitBreakerPolicy` consiste en usar `Isolate` (que fuerza y mantiene la apertura del circuito) y `Reset` (que lo cierra de nuevo).</span><span class="sxs-lookup"><span data-stu-id="cb3a0-180">Finally, another possibility for the `CircuitBreakerPolicy` is to use `Isolate` (which forces open and holds open the circuit) and `Reset` (which closes it again).</span></span> <span data-ttu-id="cb3a0-181">Estas características se pueden utilizar para crear un punto de conexión HTTP de utilidad que invoque Aislar y Restablecer directamente en la directiva.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-181">These could be used to build a utility HTTP endpoint that invokes Isolate and Reset directly on the policy.</span></span>  <span data-ttu-id="cb3a0-182">Este tipo de punto de conexión HTTP, protegido adecuadamente, también se puede usar en el entorno de producción para aislar temporalmente un sistema de nivel inferior, como cuando quiere actualizarlo.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-182">Such an HTTP endpoint could also be used, suitably secured, in production for temporarily isolating a downstream system, such as when you want to upgrade it.</span></span> <span data-ttu-id="cb3a0-183">También puede activar el circuito manualmente para proteger un sistema de nivel inferior que le parezca que está fallando.</span><span class="sxs-lookup"><span data-stu-id="cb3a0-183">Or it could trip the circuit manually to protect a downstream system you suspect to be faulting.</span></span>

## <a name="additional-resources"></a><span data-ttu-id="cb3a0-184">Recursos adicionales</span><span class="sxs-lookup"><span data-stu-id="cb3a0-184">Additional resources</span></span>

- <span data-ttu-id="cb3a0-185">**Circuit Breaker pattern (Patrón de interruptor)** </span><span class="sxs-lookup"><span data-stu-id="cb3a0-185">**Circuit Breaker pattern**</span></span>\
  [https://docs.microsoft.com/azure/architecture/patterns/circuit-breaker](/azure/architecture/patterns/circuit-breaker)

>[!div class="step-by-step"]
><span data-ttu-id="cb3a0-186">[Anterior](implement-http-call-retries-exponential-backoff-polly.md)
>[Siguiente](monitor-app-health.md)</span><span class="sxs-lookup"><span data-stu-id="cb3a0-186">[Previous](implement-http-call-retries-exponential-backoff-polly.md)
[Next](monitor-app-health.md)</span></span>
