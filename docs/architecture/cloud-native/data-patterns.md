---
title: Patrones de datos nativos en la nube
description: Diseño de aplicaciones .NET nativas en la nube para Azure | Patrones de datos nativos de la nube
ms.date: 06/30/2019
ms.openlocfilehash: 9e90409b0b633796b452cfcfecb3896e79002d4d
ms.sourcegitcommit: 30a558d23e3ac5a52071121a52c305c85fe15726
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/25/2019
ms.locfileid: "75337423"
---
# <a name="cloud-native-data-patterns"></a><span data-ttu-id="aba93-103">Patrones de datos nativos en la nube</span><span class="sxs-lookup"><span data-stu-id="aba93-103">Cloud-native data patterns</span></span>

[!INCLUDE [book-preview](../../../includes/book-preview.md)]

<span data-ttu-id="aba93-104">Aunque los datos descentralizados pueden mejorar el rendimiento, la escalabilidad y el ahorro de costos, también presenta muchos desafíos.</span><span class="sxs-lookup"><span data-stu-id="aba93-104">While decentralized data can lead to improved performance, scalability, and cost savings, it also presents many challenges.</span></span> <span data-ttu-id="aba93-105">La consulta de datos entre microservicios es compleja.</span><span class="sxs-lookup"><span data-stu-id="aba93-105">Querying for data across microservices is complex.</span></span> <span data-ttu-id="aba93-106">Una transacción que abarca microservicios debe administrarse mediante programación, ya que las transacciones distribuidas no se admiten en aplicaciones nativas de la nube.</span><span class="sxs-lookup"><span data-stu-id="aba93-106">A transaction that spans microservices must be managed programmatically as distributed transactions aren't supported in cloud-native applications.</span></span> <span data-ttu-id="aba93-107">Puede pasar de un mundo de *coherencia inmediata* a la *coherencia final*.</span><span class="sxs-lookup"><span data-stu-id="aba93-107">You  move from a world of *immediate consistency* to *eventual consistency*.</span></span>

<span data-ttu-id="aba93-108">Ahora trataremos estos desafíos.</span><span class="sxs-lookup"><span data-stu-id="aba93-108">We discuss these challenges now.</span></span>

## <a name="cross-service-queries"></a><span data-ttu-id="aba93-109">Consultas entre servicios</span><span class="sxs-lookup"><span data-stu-id="aba93-109">Cross-service queries</span></span>

<span data-ttu-id="aba93-110">¿Cómo consulta una aplicación los datos que se distribuyen entre muchos microservicios independientes?</span><span class="sxs-lookup"><span data-stu-id="aba93-110">How does an application query data that is spread across many independent microservices?</span></span>

<span data-ttu-id="aba93-111">En la figura 5-4 se muestra este escenario.</span><span class="sxs-lookup"><span data-stu-id="aba93-111">Figure 5-4 shows this scenario.</span></span>

![Consultas entre microservicios](./media/cross-service-query.png)

<span data-ttu-id="aba93-113">**Figura 5-4**.</span><span class="sxs-lookup"><span data-stu-id="aba93-113">**Figure 5-4**.</span></span> <span data-ttu-id="aba93-114">Consultas entre microservicios</span><span class="sxs-lookup"><span data-stu-id="aba93-114">Querying across microservices</span></span>

<span data-ttu-id="aba93-115">Observe cómo en la figura anterior vemos un microservicio de cesta de la compra que agrega un artículo al carro de la compra de un usuario.</span><span class="sxs-lookup"><span data-stu-id="aba93-115">Note how in the previous figure we see a shopping basket microservice that adds an item to a user's shopping cart.</span></span> <span data-ttu-id="aba93-116">Aunque el almacén de datos de la cesta de la compra contiene una tabla basket y lineItem, no contiene datos de productos o de precios, ya que estos elementos se encuentran en los microservicios de productos y precios.</span><span class="sxs-lookup"><span data-stu-id="aba93-116">While the shopping basket's data store contains a basket and lineItem table, it doesn't contain product or pricing data as those items are found in the product and price microservices.</span></span> <span data-ttu-id="aba93-117">Para agregar un elemento, el microservicio de cesta de la compra necesita datos de productos y datos de precios.</span><span class="sxs-lookup"><span data-stu-id="aba93-117">To add an item, the shopping basket microservice needs product data and pricing data.</span></span> <span data-ttu-id="aba93-118">¿Cuáles son las opciones para obtener los datos de precios y productos?</span><span class="sxs-lookup"><span data-stu-id="aba93-118">What are options to obtain the product and pricing data?</span></span>

<span data-ttu-id="aba93-119">En la figura 5-5 se muestra el microservicio de cesta de la compra que realiza una llamada HTTP directa al catálogo de productos y a los microservicios de precios.</span><span class="sxs-lookup"><span data-stu-id="aba93-119">Figure 5-5 shows the shopping basket microservice making a direct HTTP call to both the product catalog and pricing microservices.</span></span>

![Comunicación http directa](./media/direct-http-communication.png)

<span data-ttu-id="aba93-121">**Figura 5-5**.</span><span class="sxs-lookup"><span data-stu-id="aba93-121">**Figure 5-5**.</span></span> <span data-ttu-id="aba93-122">Comunicación HTTP directa</span><span class="sxs-lookup"><span data-stu-id="aba93-122">Direct HTTP communication</span></span>

<span data-ttu-id="aba93-123">Aunque es factible implementar, en el capítulo 4 se explicó cómo las llamadas HTTP directas a través de microservicios acoplan el sistema y no se considera una buena práctica.</span><span class="sxs-lookup"><span data-stu-id="aba93-123">While feasible to implement, in chapter 4 we discussed how direct HTTP calls across microservices couple the system and aren't considered a good practice.</span></span>

<span data-ttu-id="aba93-124">Podríamos implementar un microservicio del agregador que se muestra en la figura 5-6.</span><span class="sxs-lookup"><span data-stu-id="aba93-124">We could implement an aggregator microservice shown in Figure 5-6.</span></span>

![Microservicio del agregador](./media/aggregator-microservice.png)

<span data-ttu-id="aba93-126">**Figura 5-6**.</span><span class="sxs-lookup"><span data-stu-id="aba93-126">**Figure 5-6.**</span></span> <span data-ttu-id="aba93-127">Microservicio del agregador</span><span class="sxs-lookup"><span data-stu-id="aba93-127">Aggregator microservice</span></span>

<span data-ttu-id="aba93-128">Aunque este enfoque encapsula el flujo de trabajo de la operación empresarial en un microservicio individual, agrega complejidad y sigue produciendo llamadas HTTP directas.</span><span class="sxs-lookup"><span data-stu-id="aba93-128">While this approach encapsulates the business operation workflow in an individual microservice, it adds complexity and still results in direct HTTP calls.</span></span>

<span data-ttu-id="aba93-129">Un enfoque común para ejecutar consultas entre servicios usa el patrón de [vista materializada](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), que se muestra en la figura 5-7.</span><span class="sxs-lookup"><span data-stu-id="aba93-129">A common approach for executing cross-service queries uses the [Materialized View Pattern](https://docs.microsoft.com/azure/architecture/patterns/materialized-view), shown in Figure 5-7.</span></span>

![Patrón de vista materializada](./media/materialized-view-pattern.png)

<span data-ttu-id="aba93-131">**Figure5-7**.</span><span class="sxs-lookup"><span data-stu-id="aba93-131">**Figure5-7**.</span></span> <span data-ttu-id="aba93-132">Patrón de vista materializada</span><span class="sxs-lookup"><span data-stu-id="aba93-132">Materialized View Pattern</span></span>

<span data-ttu-id="aba93-133">Con este patrón, se coloca directamente una tabla local (conocida como *modelo de lectura*) en el servicio de cesta de la compra que contiene una copia desnormalizada de los datos que se necesitan del producto y los microservicios de precios.</span><span class="sxs-lookup"><span data-stu-id="aba93-133">With this pattern, you directly place a local table (known as a *read model*) in the shopping basket service that contains a denormalized copy of the data that is needed from the product and pricing microservices.</span></span> <span data-ttu-id="aba93-134">La colocación de los datos en el microservicio de la cesta de la compra elimina la necesidad de invocar una costosa llamada entre servicios.</span><span class="sxs-lookup"><span data-stu-id="aba93-134">Placing that data inside the shopping basket microservice eliminates the need for invoking expensive cross-service calls.</span></span> <span data-ttu-id="aba93-135">Con los datos locales del servicio, mejora el tiempo de respuesta y la confiabilidad.</span><span class="sxs-lookup"><span data-stu-id="aba93-135">With the data local to the service, you improve response time and reliability.</span></span>

<span data-ttu-id="aba93-136">La detección con este enfoque es que ahora tiene datos duplicados en el sistema.</span><span class="sxs-lookup"><span data-stu-id="aba93-136">The catch with this approach is you now have duplicate data in your system.</span></span> <span data-ttu-id="aba93-137">En los sistemas nativos en la nube, los datos duplicados no se consideran [antipatrón](https://en.wikipedia.org/wiki/Anti-pattern) y se suelen implementar en sistemas nativos de la nube.</span><span class="sxs-lookup"><span data-stu-id="aba93-137">In cloud-native systems, duplicate data isn't considered an [anti-pattern](https://en.wikipedia.org/wiki/Anti-pattern) and is commonly implemented in cloud-native systems.</span></span> <span data-ttu-id="aba93-138">Sin embargo, un solo sistema puede ser el propietario de cualquier conjunto de datos y debe implementar un mecanismo de sincronización para el sistema de registro para actualizar todos los modelos de lectura asociados, siempre que se produzca un cambio en los datos subyacentes.</span><span class="sxs-lookup"><span data-stu-id="aba93-138">However, one and only one system can be the owner of any dataset, and you'll need to implement a synchronization mechanism for the system of record to update all of the associated read models, whenever a change to its underlying data occurs.</span></span>

## <a name="transactional-support"></a><span data-ttu-id="aba93-139">Compatibilidad transaccional</span><span class="sxs-lookup"><span data-stu-id="aba93-139">Transactional support</span></span>

<span data-ttu-id="aba93-140">Aunque las consultas entre microservicios son desafiantes, la implementación de una transacción en varios microservicios puede ser compleja.</span><span class="sxs-lookup"><span data-stu-id="aba93-140">While queries across microservices are challenging, implementing a transaction across microservices can be complex.</span></span> <span data-ttu-id="aba93-141">El reto inherente de mantener la coherencia de los datos entre los orígenes de datos que residen en diferentes microservicios no puede estar en un subestado.</span><span class="sxs-lookup"><span data-stu-id="aba93-141">The inherent challenge of maintaining data consistency across data sources that reside in different microservices can't be understated.</span></span> <span data-ttu-id="aba93-142">En la figura 5-8 se muestra el problema.</span><span class="sxs-lookup"><span data-stu-id="aba93-142">Figure 5-8 shows the problem.</span></span>

![Transacción en el patrón saga](./media/saga-transaction-operation.png)

<span data-ttu-id="aba93-144">**Figura 5-8**.</span><span class="sxs-lookup"><span data-stu-id="aba93-144">**Figure 5-8**.</span></span> <span data-ttu-id="aba93-145">Implementar una transacción entre microservicios</span><span class="sxs-lookup"><span data-stu-id="aba93-145">Implementing a transaction across microservices</span></span>

<span data-ttu-id="aba93-146">Tenga en cuenta que, en la ilustración anterior, cinco microservicios independientes participan en una transacción de *creación de pedidos* distribuida.</span><span class="sxs-lookup"><span data-stu-id="aba93-146">Note how in the previous figure five independent microservices all participate in a distributed *Create Order* transaction.</span></span> <span data-ttu-id="aba93-147">Sin embargo, la transacción de cada uno de los cinco microservicios individuales debe ser correcta, o todos deben anular y revertir la operación.</span><span class="sxs-lookup"><span data-stu-id="aba93-147">However, the transaction for each of the five individual microservices must succeed, or all must abort and roll back the operation.</span></span> <span data-ttu-id="aba93-148">Aunque la compatibilidad con transacciones integrada está disponible dentro de cada uno de los microservicios, no se admite una transacción distribuida en los cinco servicios.</span><span class="sxs-lookup"><span data-stu-id="aba93-148">While built-in transactional support is available inside each of the microservices, there's no support for a distributed transaction across all five services.</span></span>

<span data-ttu-id="aba93-149">Dado que la compatibilidad transaccional es esencial para que esta operación Mantenga los datos coherentes en cada uno de los microservicios, debe construir mediante programación una transacción distribuida.</span><span class="sxs-lookup"><span data-stu-id="aba93-149">Since transactional support is essential for this operation to keep the data consistent in each of the microservices, you have to programmatically construct a distributed transaction.</span></span>

<span data-ttu-id="aba93-150">Un patrón popular para agregar compatibilidad transaccional mediante programación es el [patrón saga](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span><span class="sxs-lookup"><span data-stu-id="aba93-150">A popular pattern for programmatically adding transactional support is the [Saga pattern](https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/).</span></span> <span data-ttu-id="aba93-151">Se implementa mediante la agrupación de transacciones locales y la invocación secuencial de cada una de ellas.</span><span class="sxs-lookup"><span data-stu-id="aba93-151">It's implemented by grouping local transactions together and sequentially invoking each one.</span></span> <span data-ttu-id="aba93-152">Si se produce un error en una transacción local, el saga anula la operación e invoca un conjunto de [transacciones de compensación](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) para deshacer los cambios realizados por las transacciones locales anteriores.</span><span class="sxs-lookup"><span data-stu-id="aba93-152">If a local transaction fails, the Saga aborts the operation and invokes a set of [compensating transactions](https://docs.microsoft.com/azure/architecture/patterns/compensating-transaction) to undo the changes made by the preceding local transactions.</span></span> <span data-ttu-id="aba93-153">En la figura 5-9 se muestra una transacción con error con el patrón saga.</span><span class="sxs-lookup"><span data-stu-id="aba93-153">Figure 5-9 shows a failed transaction with the Saga pattern.</span></span>

![Reversión en el patrón saga](./media/saga-rollback-operation.png)

<span data-ttu-id="aba93-155">**Figura 5-9**.</span><span class="sxs-lookup"><span data-stu-id="aba93-155">**Figure 5-9**.</span></span> <span data-ttu-id="aba93-156">Deshacer una transacción</span><span class="sxs-lookup"><span data-stu-id="aba93-156">Rolling back a transaction</span></span>

<span data-ttu-id="aba93-157">Observe cómo en la ilustración anterior se produjo un error en la operación *GenerateContent* en el microservicio de música.</span><span class="sxs-lookup"><span data-stu-id="aba93-157">Note how in the previous figure the *GenerateContent* operation has failed in the music microservice.</span></span> <span data-ttu-id="aba93-158">El saga invoca las transacciones de compensación (en rojo) para quitar el contenido, cancelar el pago y cancelar el pedido, devolviendo los datos de cada microservicio a un estado coherente.</span><span class="sxs-lookup"><span data-stu-id="aba93-158">The Saga invokes compensating transactions (in red) to remove the content, cancel the payment, and cancel the order, returning the data for each microservice back to a consistent state.</span></span>

<span data-ttu-id="aba93-159">Los patrones de saga normalmente se sencillamenten como una serie de eventos relacionados o se organizan como un conjunto de comandos relacionados.</span><span class="sxs-lookup"><span data-stu-id="aba93-159">Saga patterns are typically choreographed as a series of related events or orchestrated as a set of related commands.</span></span>

## <a name="cqrs-pattern"></a><span data-ttu-id="aba93-160">Patrón CQRS</span><span class="sxs-lookup"><span data-stu-id="aba93-160">CQRS pattern</span></span>

<span data-ttu-id="aba93-161">CQRS, o [segregación de responsabilidades de comandos y consultas](https://docs.microsoft.com/azure/architecture/patterns/cqrs), es un patrón arquitectónico que separa las operaciones que leen los datos de los que escriben datos.</span><span class="sxs-lookup"><span data-stu-id="aba93-161">CQRS, or [Command and Query Responsibility Segregation](https://docs.microsoft.com/azure/architecture/patterns/cqrs), is an architectural pattern that separate operations that read data from those that write data.</span></span> <span data-ttu-id="aba93-162">Este patrón puede ayudar a maximizar el rendimiento, la escalabilidad y la seguridad.</span><span class="sxs-lookup"><span data-stu-id="aba93-162">This pattern can help maximize performance, scalability, and security.</span></span>

<span data-ttu-id="aba93-163">En *los* escenarios de acceso a datos normales, se implementa un modelo único (entidad y objeto de repositorio) que realiza operaciones de lectura y escritura de datos.</span><span class="sxs-lookup"><span data-stu-id="aba93-163">In normal data access scenarios, you implement a single model (entity and repository object) that perform *both* read and write data operations.</span></span>

<span data-ttu-id="aba93-164">Sin embargo, un escenario de acceso a datos más avanzado podría beneficiarse de modelos independientes y tablas de datos para lecturas y escrituras.</span><span class="sxs-lookup"><span data-stu-id="aba93-164">However, a more advanced data access scenario might benefit from separate models and data tables for reads and writes.</span></span> <span data-ttu-id="aba93-165">Para mejorar el rendimiento, la operación de lectura, que se conoce como una *consulta*, puede consultar una representación muy desnormalizada de los datos para evitar combinaciones de tablas repetitivas costosas.</span><span class="sxs-lookup"><span data-stu-id="aba93-165">To improve performance, the read operation, known as a *query*, might query against a highly denormalized representation of the data to avoid expensive repetitive table joins.</span></span> <span data-ttu-id="aba93-166">Mientras que la operación de *escritura* , conocida como *comando*, podría actualizarse contra una representación totalmente normalizada de los datos.</span><span class="sxs-lookup"><span data-stu-id="aba93-166">Whereas the *write* operation, known as a *command*, might update against a fully normalized representation of the data.</span></span> <span data-ttu-id="aba93-167">A continuación, debe implementar un mecanismo para mantener ambas representaciones sincronizadas. Normalmente, siempre que se modifica la tabla de escritura, se genera un evento que replica la modificación de los datos en la tabla de lectura.</span><span class="sxs-lookup"><span data-stu-id="aba93-167">You would then need to implement a mechanism to keep both representations in sync. Typically, whenever the write table is modified, it raises an event that replicates the data modification to the read table.</span></span>

<span data-ttu-id="aba93-168">En la figura 5-10 se muestra una implementación del patrón CQRS.</span><span class="sxs-lookup"><span data-stu-id="aba93-168">Figure 5-10 shows an implementation of the CQRS pattern.</span></span>

![Implementación de CQRS](./media/cqrs-implementation.png)

<span data-ttu-id="aba93-170">**Figura 5-10**.</span><span class="sxs-lookup"><span data-stu-id="aba93-170">**Figure 5-10**.</span></span> <span data-ttu-id="aba93-171">Implementación de CQRS</span><span class="sxs-lookup"><span data-stu-id="aba93-171">CQRS implementation</span></span>

<span data-ttu-id="aba93-172">Observe cómo se implementan los modelos de comando y consulta independientes en la figura anterior.</span><span class="sxs-lookup"><span data-stu-id="aba93-172">Note how in the previous figure separate command and query models are implemented.</span></span> <span data-ttu-id="aba93-173">Además, cada operación de escritura de datos se guarda en el almacén de escritura y, a continuación, se propaga al almacén de lectura.</span><span class="sxs-lookup"><span data-stu-id="aba93-173">Moreover, each data write operation is saved to the write store and then propagated to the read store.</span></span> <span data-ttu-id="aba93-174">Preste mucha atención a cómo funciona el proceso de propagación en el principio de [coherencia eventual](https://www.cloudcomputingpatterns.org/eventual_consistency/), mientras que el modelo de lectura finalmente se sincroniza con el modelo de escritura, pero puede haber algún retraso en el proceso.</span><span class="sxs-lookup"><span data-stu-id="aba93-174">Pay close attention to how the propagation process operates on the principle of [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), whereas the read model eventually synchronizes with the write model, but there may be some lag in the process.</span></span>

<span data-ttu-id="aba93-175">Mediante la implementación de la separación, tiene la capacidad de escalar lecturas y escrituras por separado.</span><span class="sxs-lookup"><span data-stu-id="aba93-175">By implementing separation, you have the ability to scale reads and writes separately.</span></span> <span data-ttu-id="aba93-176">También puede imponer una seguridad más estricta en las operaciones de escritura que las que se refieren a las lecturas.</span><span class="sxs-lookup"><span data-stu-id="aba93-176">As well, you might impose tighter security on write operations than those concerning reads.</span></span>

<span data-ttu-id="aba93-177">Normalmente, los patrones CQRS se aplican a secciones limitadas del sistema en función de las necesidades específicas.</span><span class="sxs-lookup"><span data-stu-id="aba93-177">Typically, CQRS patterns are applied to limited sections of your system based upon specific needs.</span></span>

## <a name="relational-vs-nosql"></a><span data-ttu-id="aba93-178">Relacional frente a NoSQL</span><span class="sxs-lookup"><span data-stu-id="aba93-178">Relational vs NoSQL</span></span>

<span data-ttu-id="aba93-179">El impacto de las tecnologías [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) no puede ser sobreutilizado, especialmente en sistemas nativos en la nube distribuidos.</span><span class="sxs-lookup"><span data-stu-id="aba93-179">The impact of [NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/) technologies can't be overstated, especially for distributed cloud-native systems.</span></span> <span data-ttu-id="aba93-180">La proliferación de nuevas tecnologías de datos en este espacio ha interrumpido soluciones que, una vez confiaba exclusivamente en las bases de datos relacionales.</span><span class="sxs-lookup"><span data-stu-id="aba93-180">The proliferation of new data technologies in this space has disrupted solutions that once exclusively relied on relational databases.</span></span>

<span data-ttu-id="aba93-181">Por un lado, las bases de datos relacionales han sido una tecnología predominante para décadas.</span><span class="sxs-lookup"><span data-stu-id="aba93-181">On the one side, relational databases have been a prevalent technology for decades.</span></span> <span data-ttu-id="aba93-182">Están consolidados, probados y ampliamente implementados.</span><span class="sxs-lookup"><span data-stu-id="aba93-182">They're mature, proven, and widely implemented.</span></span> <span data-ttu-id="aba93-183">Los productos de base de datos, la experiencia y las herramientas que compiten.</span><span class="sxs-lookup"><span data-stu-id="aba93-183">Competing database products, expertise and tooling abounds.</span></span> <span data-ttu-id="aba93-184">Las bases de datos relacionales proporcionan un almacén de tablas de datos relacionadas.</span><span class="sxs-lookup"><span data-stu-id="aba93-184">Relational databases provide a store of related data tables.</span></span> <span data-ttu-id="aba93-185">Estas tablas tienen un esquema fijo, usan SQL (Lenguaje de consulta estructurado) para administrar datos y tienen garantías [acid](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (también conocidas como atomicidad, coherencia, aislamiento y durabilidad).</span><span class="sxs-lookup"><span data-stu-id="aba93-185">These tables have a fixed schema, use SQL (Structured Query Language) to manage data and have [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) (also known as Atomicity, Consistency, Isolation, and Durability) guarantees.</span></span>

<span data-ttu-id="aba93-186">Las bases de datos no-SQL, por otro lado, se refieren a almacenes de datos no relacionales de alto rendimiento.</span><span class="sxs-lookup"><span data-stu-id="aba93-186">No-SQL databases, on the other side, refer to high-performance, non-relational data stores.</span></span> <span data-ttu-id="aba93-187">Excel en sus características de facilidad de uso, escalabilidad, resistencia y disponibilidad.</span><span class="sxs-lookup"><span data-stu-id="aba93-187">They excel in their ease-of-use, scalability, resilience, and availability characteristics.</span></span> <span data-ttu-id="aba93-188">En lugar de combinar tablas de datos normalizados, NoSQL almacena datos autodescriptivos (sin esquema) normalmente en documentos JSON.</span><span class="sxs-lookup"><span data-stu-id="aba93-188">Instead of joining tables of normalized data, NoSQL stores self-describing (schemaless) data typically in JSON documents.</span></span> <span data-ttu-id="aba93-189">No ofrecen garantías [acid](https://www.geeksforgeeks.org/acid-properties-in-dbms/) .</span><span class="sxs-lookup"><span data-stu-id="aba93-189">They don't offer [ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) guarantees.</span></span>

<span data-ttu-id="aba93-190">Una manera de comprender las diferencias entre estos tipos de bases de datos puede encontrarse en el [teorema Cap](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), un conjunto de principios que se pueden aplicar a sistemas distribuidos que almacenan el estado.</span><span class="sxs-lookup"><span data-stu-id="aba93-190">A way to understand the differences between these types of databases can be found in the [CAP theorem](https://towardsdatascience.com/cap-theorem-and-distributed-database-management-systems-5c2be977950e), a set of principles that can be applied to distributed systems that store state.</span></span> <span data-ttu-id="aba93-191">En la figura 5-11 se muestran las tres propiedades del CAP teorema.</span><span class="sxs-lookup"><span data-stu-id="aba93-191">Figure 5-11 shows the three properties of the CAP theorem.</span></span>

![Teorema CAP](./media/cap-theorem.png)

<span data-ttu-id="aba93-193">**Figura 5-11**.</span><span class="sxs-lookup"><span data-stu-id="aba93-193">**Figure 5-11**.</span></span> <span data-ttu-id="aba93-194">Teorema CAP</span><span class="sxs-lookup"><span data-stu-id="aba93-194">The CAP theorem</span></span>

<span data-ttu-id="aba93-195">El teorema indica que cualquier sistema de datos distribuidos ofrecerá un equilibrio entre coherencia, disponibilidad y tolerancia de particiones, y que cualquier base de datos solo puede garantizar dos de las tres propiedades:</span><span class="sxs-lookup"><span data-stu-id="aba93-195">The theorem states that any distributed data system will offer a trade-off between consistency, availability, and partition tolerance, and that any database can only guarantee two of the three properties:</span></span>

- <span data-ttu-id="aba93-196">*Coherencia*: todos los nodos del clúster responderán con los datos más recientes, incluso si necesita bloquear una solicitud hasta que todas las réplicas se actualicen correctamente.</span><span class="sxs-lookup"><span data-stu-id="aba93-196">*Consistency*: every node in the cluster will respond with the most recent data, even if it requires blocking a request until all replicas are correctly updated.</span></span>

- <span data-ttu-id="aba93-197">*Disponibilidad*: cada nodo devolverá una respuesta en un período de tiempo razonable, incluso si esa respuesta no es los datos más recientes.</span><span class="sxs-lookup"><span data-stu-id="aba93-197">*Availability*: every node will return a response in a reasonable amount of time, even if that response isn't the most recent data.</span></span>

- <span data-ttu-id="aba93-198">*Tolerancia de partición*: garantiza que el sistema continuará funcionando si se produce un error en un nodo o se pierde la conectividad con otro.</span><span class="sxs-lookup"><span data-stu-id="aba93-198">*Partition Tolerance*: guarantees that the system will continue operating if a node fails or loses connectivity with another.</span></span>

<span data-ttu-id="aba93-199">Las bases de datos relacionales muestran coherencia y disponibilidad, pero no tolerancia a particiones.</span><span class="sxs-lookup"><span data-stu-id="aba93-199">Relational databases exhibit consistency and availability, but not partition tolerance.</span></span> <span data-ttu-id="aba93-200">La creación de particiones de una base de datos relacional, como el particionamiento, es difícil y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="aba93-200">Partitioning a relational database, such as sharding, is difficult and can impact performance.</span></span>

<span data-ttu-id="aba93-201">Por otra parte, las bases de datos NoSQL suelen presentar tolerancia de particiones, lo que se conoce como escalabilidad horizontal y alta disponibilidad.</span><span class="sxs-lookup"><span data-stu-id="aba93-201">On the other hand, NoSQL databases typically exhibit partition tolerance, known as horizontal scalability, and high availability.</span></span> <span data-ttu-id="aba93-202">Como el CAP teorema especifica, solo puede tener dos de los tres principios y se pierde la propiedad Consistency.</span><span class="sxs-lookup"><span data-stu-id="aba93-202">As the CAP theorem specifies, you can only have two of the three principles, and you lose the  consistency property.</span></span>

<span data-ttu-id="aba93-203">Las bases de datos NoSQL se distribuyen y normalmente se escalan horizontalmente a través de servidores de mercancías.</span><span class="sxs-lookup"><span data-stu-id="aba93-203">NoSQL databases are distributed and commonly scaled out across commodity servers.</span></span> <span data-ttu-id="aba93-204">Si lo hace, puede proporcionar una gran disponibilidad, tanto dentro como entre regiones geográficas con un coste reducido.</span><span class="sxs-lookup"><span data-stu-id="aba93-204">Doing so can provide great availability, both within and across geographical regions at a reduced cost.</span></span> <span data-ttu-id="aba93-205">Los datos se pueden particionar y replicar en estos equipos, o nodos, lo que proporciona redundancia y tolerancia a errores.</span><span class="sxs-lookup"><span data-stu-id="aba93-205">Data can be partitioned and replicated across these machines, or nodes, providing redundancy and fault tolerance.</span></span> <span data-ttu-id="aba93-206">El inconveniente es la coherencia.</span><span class="sxs-lookup"><span data-stu-id="aba93-206">The downside is consistency.</span></span> <span data-ttu-id="aba93-207">Un cambio en los datos de un nodo NoSQL puede tardar algún tiempo en propagarse a otros nodos.</span><span class="sxs-lookup"><span data-stu-id="aba93-207">A change to data on one NoSQL node can take some time to propagate to other nodes.</span></span> <span data-ttu-id="aba93-208">Normalmente, un nodo de base de datos NoSQL proporcionará una respuesta inmediata a una consulta, incluso si los datos que presenta están obsoletos y aún no se han actualizado.</span><span class="sxs-lookup"><span data-stu-id="aba93-208">Typically, a NoSQL database node will provide an immediate response to a query, even if the data that it is presenting is stale and has not been updated yet.</span></span>

<span data-ttu-id="aba93-209">Se trata de una [coherencia final](https://www.cloudcomputingpatterns.org/eventual_consistency/)conocida, una característica de los sistemas de datos distribuidos donde no se admiten las transacciones ACID.</span><span class="sxs-lookup"><span data-stu-id="aba93-209">This is known [eventual consistency](https://www.cloudcomputingpatterns.org/eventual_consistency/), a characteristic of distributed data systems where ACID transactions aren't supported.</span></span> <span data-ttu-id="aba93-210">Es un breve retraso entre la actualización de un elemento de datos y el tiempo que se tarda en propagar esa actualización a cada uno de los nodos de réplica.</span><span class="sxs-lookup"><span data-stu-id="aba93-210">It's a brief delay between the update of a data item and time that it takes to propagate that update to each of the replica nodes.</span></span> <span data-ttu-id="aba93-211">Si actualiza un elemento de producto en una base de datos NoSQL en el Estados Unidos, pero al mismo tiempo consulta ese mismo elemento de datos desde un nodo de réplica de Europa, podría recuperar la información del producto anterior, hasta que el nodo Europeo se haya actualizado con el cambio del producto.</span><span class="sxs-lookup"><span data-stu-id="aba93-211">If you update a product item in a NoSQL database in the United States, but at same time query that same data item from a replica node in Europe, you might retrieve the earlier product information - until the European node has been updated with product change.</span></span> <span data-ttu-id="aba93-212">La desventaja es que, al otorgar una [coherencia fuerte](https://en.wikipedia.org/wiki/Strong_consistency), esperar a que todos los nodos de réplica se actualicen antes de devolver el resultado de una consulta, puede admitir enormes volúmenes de tráfico y escalado, pero con la posibilidad de presentar datos antiguos.</span><span class="sxs-lookup"><span data-stu-id="aba93-212">The trade-off is that by giving up [strong consistency](https://en.wikipedia.org/wiki/Strong_consistency),  waiting for all replica nodes to update before returning a query result, you can support enormous scale and traffic volume, but with the possibility of presenting older data.</span></span>

<span data-ttu-id="aba93-213">Las bases de datos NoSQL se pueden clasificar por los cuatro modelos siguientes:</span><span class="sxs-lookup"><span data-stu-id="aba93-213">NoSQL databases can be categorized by the following four models:</span></span>

- <span data-ttu-id="aba93-214">*Almacén de documentos* (MongoDB, CouchDB, Couchbase): los datos (y los metadatos correspondientes) se almacenan de forma no relacional en documentos basados en JSON desnormalizados dentro de la base de datos.</span><span class="sxs-lookup"><span data-stu-id="aba93-214">*Document Store* (MongoDB, CouchDB, Couchbase): data (and corresponding metadata) is stored non-relationally in denormalized JSON-based documents inside the database.</span></span>

- <span data-ttu-id="aba93-215">*Almacén de clave/valor* (Redis, Riak, Memcached): los datos se almacenan en pares de clave-valor simples con operaciones del sistema realizadas con una clave de acceso única asignada a un valor de datos de usuario.</span><span class="sxs-lookup"><span data-stu-id="aba93-215">*Key/Value Store* (Redis, Riak, memcached): data is stored in simple key-value pairs with system operations performed against a unique access key that is mapped to a value of user data.</span></span>

- <span data-ttu-id="aba93-216">*Almacén de columnas anchas* (HBase, Cassandra): los datos relacionados se almacenan en un formato de columnas como un conjunto de pares de clave-valor anidados dentro de una sola columna con datos que se recuperan normalmente como una sola unidad sin tener que combinar varias tablas.</span><span class="sxs-lookup"><span data-stu-id="aba93-216">*Wide-Column Store* (HBase, Cassandra): related Data is stored in a columnar format as a set of nested-key/value pairs within a single column with data typically retrieved as a single unit without having to join multiple tables together.</span></span>

- <span data-ttu-id="aba93-217">*Almacenes de grafos* (Neo4J, Titan): los datos se almacenan como una representación gráfica dentro de un nodo junto con los bordes que especifican la relación entre los nodos.</span><span class="sxs-lookup"><span data-stu-id="aba93-217">*Graph stores* (neo4j, titan): data is stored as a graphical representation within a node along with edges that specify the relationship between the nodes.</span></span>

<span data-ttu-id="aba93-218">Las bases de datos NoSQL se pueden optimizar para tratar con datos a gran escala, especialmente cuando los datos son relativamente simples.</span><span class="sxs-lookup"><span data-stu-id="aba93-218">NoSQL databases can be optimized to deal with large-scale data, especially when the data is relatively simple.</span></span> <span data-ttu-id="aba93-219">Considere una base de datos NoSQL cuando:</span><span class="sxs-lookup"><span data-stu-id="aba93-219">Consider a NoSQL database when:</span></span>

- <span data-ttu-id="aba93-220">La carga de trabajo requiere una gran escala y una simultaneidad alta.</span><span class="sxs-lookup"><span data-stu-id="aba93-220">Your workload requires a large scale and high concurrency.</span></span>
- <span data-ttu-id="aba93-221">Tiene un gran número de usuarios.</span><span class="sxs-lookup"><span data-stu-id="aba93-221">You have large numbers of users.</span></span>
- <span data-ttu-id="aba93-222">Los datos se pueden expresar simplemente sin relaciones.</span><span class="sxs-lookup"><span data-stu-id="aba93-222">Your data can be expressed simply without relationships.</span></span>
- <span data-ttu-id="aba93-223">Debe distribuir geográficamente los datos.</span><span class="sxs-lookup"><span data-stu-id="aba93-223">You need to geographically distribute your data.</span></span>
- <span data-ttu-id="aba93-224">No necesita garantías ACID.</span><span class="sxs-lookup"><span data-stu-id="aba93-224">You don't need ACID guarantees.</span></span>
- <span data-ttu-id="aba93-225">Se implementará en hardware estándar.</span><span class="sxs-lookup"><span data-stu-id="aba93-225">Will be deployed to commodity hardware.</span></span>

<span data-ttu-id="aba93-226">A continuación, considere una base de datos relacional cuando:</span><span class="sxs-lookup"><span data-stu-id="aba93-226">Then, consider a relational database when:</span></span>

- <span data-ttu-id="aba93-227">Las cargas de trabajo requieren una escala mediana y grande.</span><span class="sxs-lookup"><span data-stu-id="aba93-227">Your workloads require medium to large scale.</span></span>
- <span data-ttu-id="aba93-228">La simultaneidad no es una preocupación importante.</span><span class="sxs-lookup"><span data-stu-id="aba93-228">Concurrency isn't a major concern.</span></span>
- <span data-ttu-id="aba93-229">Se necesitan garantías ACID.</span><span class="sxs-lookup"><span data-stu-id="aba93-229">ACID guarantees are needed.</span></span>
- <span data-ttu-id="aba93-230">Los datos se expresan con mayor relación.</span><span class="sxs-lookup"><span data-stu-id="aba93-230">Data is best expressed relationally.</span></span>
- <span data-ttu-id="aba93-231">La aplicación se implementará en hardware grande y de alto nivel.</span><span class="sxs-lookup"><span data-stu-id="aba93-231">Your application will be deployed to large, high-end hardware.</span></span>

<span data-ttu-id="aba93-232">A continuación, veremos el almacenamiento de datos en la nube de Azure.</span><span class="sxs-lookup"><span data-stu-id="aba93-232">Next, we look at data storage in the Azure cloud.</span></span>

>[!div class="step-by-step"]
><span data-ttu-id="aba93-233">[Anterior](distributed-data.md)
>[Siguiente](azure-data-storage.md)</span><span class="sxs-lookup"><span data-stu-id="aba93-233">[Previous](distributed-data.md)
[Next](azure-data-storage.md)</span></span>
