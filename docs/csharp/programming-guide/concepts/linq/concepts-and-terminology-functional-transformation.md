---
title: Conceptos y terminología (transformación funcional) (C#)
ms.date: 07/20/2015
ms.assetid: 03defb3a-7e17-4ab1-8efa-4dd66621e860
ms.openlocfilehash: 3e2ecc4c2f70700ae92ee36b6f122059b922332e
ms.sourcegitcommit: 581ab03291e91983459e56e40ea8d97b5189227e
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 08/27/2019
ms.locfileid: "70040630"
---
# <a name="concepts-and-terminology-functional-transformation-c"></a><span data-ttu-id="04e56-102">Conceptos y terminología (transformación funcional) (C#)</span><span class="sxs-lookup"><span data-stu-id="04e56-102">Concepts and Terminology (Functional Transformation) (C#)</span></span>

<span data-ttu-id="04e56-103">Este tema presenta los conceptos y la terminología en relación con las transformaciones funcionales.</span><span class="sxs-lookup"><span data-stu-id="04e56-103">This topic introduces the concepts and terminology of pure functional transformations.</span></span> <span data-ttu-id="04e56-104">La aproximación que utiliza la transformación funcional para transformar datos permite obtener un código que normalmente se escribe más rápido, es más expresivo y fácil de mantener y depurar, si lo comparamos con la programación imperativa, que es más tradicional.</span><span class="sxs-lookup"><span data-stu-id="04e56-104">The functional transformation approach to transforming data yields code that is often quicker to program, more expressive, and easier to debug and maintain than more traditional, imperative programming.</span></span>

<span data-ttu-id="04e56-105">Observe que los temas incluidos en esta lección no pretenden explicar con detalle cómo es la programación funcional.</span><span class="sxs-lookup"><span data-stu-id="04e56-105">Note that the topics in this section are not intended to fully explain functional programming.</span></span> <span data-ttu-id="04e56-106">En su lugar, pretenden resaltar algunas de las características de la programación funcional que facilitan el proceso de transformar un XML de una forma a otra.</span><span class="sxs-lookup"><span data-stu-id="04e56-106">Instead, these topics identify some of the functional programming capabilities that make it easier to transform XML from one shape to another.</span></span>

## <a name="what-is-pure-functional-transformation"></a><span data-ttu-id="04e56-107">¿En qué consiste la transformación funcional pura?</span><span class="sxs-lookup"><span data-stu-id="04e56-107">What Is Pure Functional Transformation?</span></span>

<span data-ttu-id="04e56-108">En la *transformación funcional pura*, existe un conjunto de funciones, llamadas *funciones puras*, que definen cómo transformar un conjunto de datos estructurados de su forma original a otra forma.</span><span class="sxs-lookup"><span data-stu-id="04e56-108">In *pure functional transformation*, a set of functions, called *pure functions*, define how to transform a set of structured data from its original form into another form.</span></span> <span data-ttu-id="04e56-109">La palabra "pura" indica que las funciones *admiten composición*, lo que significa que son:</span><span class="sxs-lookup"><span data-stu-id="04e56-109">The word "pure" indicates that the functions are *composable*, which requires that they are:</span></span>

- <span data-ttu-id="04e56-110">*Autocontenidas*, de forma que se pueden ordenar o reorganizar libremente sin preocuparse por las dependencias que puedan tener con el resto del programa.</span><span class="sxs-lookup"><span data-stu-id="04e56-110">*Self-contained*, so that they can be freely ordered and rearranged without entanglement or interdependencies with the rest of the program.</span></span> <span data-ttu-id="04e56-111">Las transformaciones puras no tienen conocimiento sobre su entorno ni ningún efecto sobre éste.</span><span class="sxs-lookup"><span data-stu-id="04e56-111">Pure transformations have no knowledge of or effect upon their environment.</span></span> <span data-ttu-id="04e56-112">Es decir, las funciones que se usan en la transformación no tienen *efectos secundarios*.</span><span class="sxs-lookup"><span data-stu-id="04e56-112">That is, the functions used in the transformation have no *side effects*.</span></span>

- <span data-ttu-id="04e56-113">*Sin estado*, lo que significa que si se ejecuta la misma función o un conjunto específico de funciones en los mismos datos de entrada, el resultado siempre será el mismo.</span><span class="sxs-lookup"><span data-stu-id="04e56-113">*Stateless*, so that executing the same function or specific set of functions on the same input will always result in the same output.</span></span> <span data-ttu-id="04e56-114">Las transformaciones puras no recuerdan sus ejecuciones anteriores.</span><span class="sxs-lookup"><span data-stu-id="04e56-114">Pure transformations have no memory of their prior use.</span></span>

> [!IMPORTANT]
> <span data-ttu-id="04e56-115">Para el resto de este tutorial, el término "función pura" se utilizará en sentido general para señalar una técnica de programación y no una característica específica del lenguaje.</span><span class="sxs-lookup"><span data-stu-id="04e56-115">In the rest of this tutorial, the term "pure function" is used in a general sense to indicate a programming approach, and not a specific language feature.</span></span>
>
> <span data-ttu-id="04e56-116">Tenga en cuenta que las funciones puras deben implementarse como métodos en C#.</span><span class="sxs-lookup"><span data-stu-id="04e56-116">Note that pure functions must be implemented as methods in C#.</span></span>
>
> <span data-ttu-id="04e56-117">Además, no debería confundir las funciones puras con los métodos virtuales puros de C++.</span><span class="sxs-lookup"><span data-stu-id="04e56-117">Also, you should not confuse pure functions with pure virtual methods in C++.</span></span> <span data-ttu-id="04e56-118">Estos últimos indican que la clase contenedora es abstracta y que no incluye ningún cuerpo de método.</span><span class="sxs-lookup"><span data-stu-id="04e56-118">The latter indicates that the containing class is abstract and that no method body is supplied.</span></span>

### <a name="functional-programming"></a><span data-ttu-id="04e56-119">Programación funcional</span><span class="sxs-lookup"><span data-stu-id="04e56-119">Functional Programming</span></span>

<span data-ttu-id="04e56-120">La *programación funcional* es una técnica de programación que permite el uso de transformaciones funcionales puras directamente.</span><span class="sxs-lookup"><span data-stu-id="04e56-120">*Functional programming* is a programming approach that directly supports pure functional transformation.</span></span>

<span data-ttu-id="04e56-121">Tradicionalmente, los lenguajes de programación funcionales de uso general, como ML, Scheme, Haskell y F#, han atraído principalmente la atención de la comunidad académica.</span><span class="sxs-lookup"><span data-stu-id="04e56-121">Historically, general-purpose functional programming languages, such as ML, Scheme, Haskell, and F#, have been primarily of interest to the academic community.</span></span> <span data-ttu-id="04e56-122">Aunque siempre ha sido posible escribir transformaciones funcionales puras en C#, la dificultad para hacerlo no la ha convertido en una opción atractiva de cara a los programadores.</span><span class="sxs-lookup"><span data-stu-id="04e56-122">Although it has always been possible to write pure functional transformations in C#, the difficulty of doing so has not made it an attractive option to most programmers.</span></span> <span data-ttu-id="04e56-123">No obstante, en las versiones recientes de C# se han incorporado nuevos constructores del lenguaje, como son las expresiones lambda o la inferencia de tipos, que simplifican enormemente la programación funcional y permiten aumentar la productividad.</span><span class="sxs-lookup"><span data-stu-id="04e56-123">In recent versions of C#, however, new language constructs such as lambda expressions and type inference make it functional programming much easier and more productive.</span></span>

<span data-ttu-id="04e56-124">Para obtener más información sobre la programación funcional, consulte [Diferencias entre la programación funcional y la programación imperativa (C#)](./functional-programming-vs-imperative-programming.md).</span><span class="sxs-lookup"><span data-stu-id="04e56-124">For more information about functional programming, see [Functional Programming vs. Imperative Programming (C#)](./functional-programming-vs-imperative-programming.md).</span></span>

#### <a name="domain-specific-fp-languages"></a><span data-ttu-id="04e56-125">Lenguajes de programación funcionales para ciertos campos</span><span class="sxs-lookup"><span data-stu-id="04e56-125">Domain-Specific FP Languages</span></span>

<span data-ttu-id="04e56-126">Aunque todavía no se han adoptado mayoritariamente los lenguajes de programación funcionales, sí han tenido más éxito los lenguajes de programación funcionales específicos para ciertos campos.</span><span class="sxs-lookup"><span data-stu-id="04e56-126">Although general functional programming languages have not been widely adopted, specific domain-specific functional programming languages have had better success.</span></span> <span data-ttu-id="04e56-127">Por ejemplo, las hojas de estilos en cascada (CSS) se utilizan para definir la apariencia de numerosas paginas web y las hojas de estilos del Lenguaje de transformación basado en hojas de estilo (XSLT) se utilizan muy a menudo para la manipulación de datos XML.</span><span class="sxs-lookup"><span data-stu-id="04e56-127">For example, Cascading Style Sheets (CSS) are used to determine the look and feel of many Web pages, and Extensible Stylesheet Language Transformations (XSLT) style sheets are used extensively in XML data manipulation.</span></span> <span data-ttu-id="04e56-128">Para obtener más información sobre XSLT, consulte [Transformaciones XSLT](../../../../standard/data/xml/xslt-transformations.md).</span><span class="sxs-lookup"><span data-stu-id="04e56-128">For more information about XSLT, see [XSLT Transformations](../../../../standard/data/xml/xslt-transformations.md).</span></span>

## <a name="terminology"></a><span data-ttu-id="04e56-129">Terminología</span><span class="sxs-lookup"><span data-stu-id="04e56-129">Terminology</span></span>

<span data-ttu-id="04e56-130">La siguiente tabla define algunos términos relacionados con las transformaciones funcionales.</span><span class="sxs-lookup"><span data-stu-id="04e56-130">The following table defines some terms related to functional transformations.</span></span>

<span data-ttu-id="04e56-131">Función de orden superior (primera clase) </span><span class="sxs-lookup"><span data-stu-id="04e56-131">higher-order (first-class) function </span></span>\
<span data-ttu-id="04e56-132">Función que se puede tratar como un objeto de programación.</span><span class="sxs-lookup"><span data-stu-id="04e56-132">A function that can be treated as a programmatic object.</span></span> <span data-ttu-id="04e56-133">Por ejemplo, es posible pasar una función de orden superior como argumento de otra función, así como ser devuelta por otra función.</span><span class="sxs-lookup"><span data-stu-id="04e56-133">For example, a higher-order function can be passed to or returned from other functions.</span></span> <span data-ttu-id="04e56-134">En C#, los delegados y las expresiones lambda son características del lenguaje que admiten el uso de funciones de orden superior.</span><span class="sxs-lookup"><span data-stu-id="04e56-134">In C#c, delegates and lambda expressions are language features that support higher-order functions.</span></span> <span data-ttu-id="04e56-135">Si desea escribir una función de orden superior, deberá declarar uno o más argumentos para recibir delegados, y a menudo utilizará expresiones lambda cuando llame a dichas funciones.</span><span class="sxs-lookup"><span data-stu-id="04e56-135">To write a higher-order function, you declare one or more arguments to take delegates, and you often use lambda expressions when calling it.</span></span> <span data-ttu-id="04e56-136">La mayoría de operadores estándar de consulta son funciones de orden superior.</span><span class="sxs-lookup"><span data-stu-id="04e56-136">Many of the standard query operators are higher-order functions.</span></span>

<span data-ttu-id="04e56-137">Para obtener más información, vea [Standard Query Operators Overview (C#)](./standard-query-operators-overview.md)(Información general sobre operadores de consulta estándar (C#)).</span><span class="sxs-lookup"><span data-stu-id="04e56-137">For more information, see [Standard Query Operators Overview (C#)](./standard-query-operators-overview.md).</span></span>

<span data-ttu-id="04e56-138">Expresión lambda </span><span class="sxs-lookup"><span data-stu-id="04e56-138">lambda expression </span></span>\
<span data-ttu-id="04e56-139">En esencia, es posible utilizar una función anónima alineada siempre que se espere como argumento un tipo delegado.</span><span class="sxs-lookup"><span data-stu-id="04e56-139">Essentially, an inline anonymous function that can be used wherever a delegate type is expected.</span></span> <span data-ttu-id="04e56-140">Esta es una definición simplificada de las expresiones lambda, pero resulta adecuada para los objetivos de este tutorial.</span><span class="sxs-lookup"><span data-stu-id="04e56-140">This is a simplified definition of lambda expressions, but it is adequate for the purposes of this tutorial.</span></span>

<span data-ttu-id="04e56-141">Para obtener más información, consulte [Expresiones lambda](../../statements-expressions-operators/lambda-expressions.md).</span><span class="sxs-lookup"><span data-stu-id="04e56-141">For more information about, see [Lambda Expressions](../../statements-expressions-operators/lambda-expressions.md).</span></span>

<span data-ttu-id="04e56-142">Colección </span><span class="sxs-lookup"><span data-stu-id="04e56-142">collection </span></span>\
<span data-ttu-id="04e56-143">Conjunto de datos estructurados, normalmente del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="04e56-143">A structured set of data, usually of a uniform type.</span></span> <span data-ttu-id="04e56-144">Para que una colección sea compatible con LINQ, ésta debe implementar la interfaz <xref:System.Collections.IEnumerable> o la interfaz <xref:System.Linq.IQueryable> (o una de sus equivalentes genéricas), <xref:System.Collections.Generic.IEnumerator%601> o <xref:System.Linq.IQueryable%601>).</span><span class="sxs-lookup"><span data-stu-id="04e56-144">To be compatible with LINQ, a collection must implement the <xref:System.Collections.IEnumerable> interface or the <xref:System.Linq.IQueryable> interface (or one of their generic counterparts, <xref:System.Collections.Generic.IEnumerator%601> or <xref:System.Linq.IQueryable%601>).</span></span>

<span data-ttu-id="04e56-145">Tupla (tipos anónimos) </span><span class="sxs-lookup"><span data-stu-id="04e56-145">tuple (anonymous types) </span></span>\
<span data-ttu-id="04e56-146">Se trata de un concepto matemático: una tupa es una secuencia finita de objetos, cada uno de los cuales es de un tipo específico.</span><span class="sxs-lookup"><span data-stu-id="04e56-146">A mathematical concept, a tuple is a finite sequence of objects, each of a specific type.</span></span> <span data-ttu-id="04e56-147">A las tuplas también se las conoce como listas ordenadas.</span><span class="sxs-lookup"><span data-stu-id="04e56-147">A tuple is also known as an ordered list.</span></span> <span data-ttu-id="04e56-148">Los tipos anónimos son una implementación del lenguaje para este concepto, lo que permite declarar un tipo de clase sin nombre e instanciar un objeto de este tipo al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="04e56-148">Anonymous types are a language implementation of this concept, which enable an unnamed class type to be declared and an object of that type to be instantiated at the same time.</span></span>

<span data-ttu-id="04e56-149">Para más información, vea [Tipos anónimos](../../classes-and-structs/anonymous-types.md).</span><span class="sxs-lookup"><span data-stu-id="04e56-149">For more information, see [Anonymous Types](../../classes-and-structs/anonymous-types.md).</span></span>

<span data-ttu-id="04e56-150">Inferencia de tipos (tipos implícitos) </span><span class="sxs-lookup"><span data-stu-id="04e56-150">type inference (implicit typing) </span></span>\
<span data-ttu-id="04e56-151">Consiste en la capacidad del compilador para determinar el tipo de una variable en caso de que no exista una declaración de tipos explícita.</span><span class="sxs-lookup"><span data-stu-id="04e56-151">The ability of a compiler to determine the type of a variable in the absence of an explicit type declaration.</span></span>

<span data-ttu-id="04e56-152">Para más información, vea [Variables locales con asignación implícita de tipos](../../classes-and-structs/implicitly-typed-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="04e56-152">For more information, see [Implicitly Typed Local Variables](../../classes-and-structs/implicitly-typed-local-variables.md).</span></span>

<span data-ttu-id="04e56-153">Ejecución aplazada y evaluación diferida </span><span class="sxs-lookup"><span data-stu-id="04e56-153">deferred execution and lazy evaluation </span></span>\
<span data-ttu-id="04e56-154">Es posible retrasar la evaluación de una expresión hasta que se requiera el valor resultante.</span><span class="sxs-lookup"><span data-stu-id="04e56-154">The delaying of evaluation of an expression until its resolved value is actually required.</span></span> <span data-ttu-id="04e56-155">Las colecciones admiten la ejecución aplazada.</span><span class="sxs-lookup"><span data-stu-id="04e56-155">Deferred execution is supported in collections.</span></span>

<span data-ttu-id="04e56-156">Para obtener más información, consulte [Introducción a las consultas LINQ (C#)](./introduction-to-linq-queries.md) y [Ejecución aplazada y evaluación diferida en LINQ to XML](./deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).</span><span class="sxs-lookup"><span data-stu-id="04e56-156">For more information, see [Introduction to LINQ Queries (C#)](./introduction-to-linq-queries.md) and [Deferred Execution and Lazy Evaluation in LINQ to XML (C#)](./deferred-execution-and-lazy-evaluation-in-linq-to-xml.md).</span></span>

<span data-ttu-id="04e56-157">Estas características del lenguaje se utilizarán en códigos de ejemplo a lo largo de esta sección.</span><span class="sxs-lookup"><span data-stu-id="04e56-157">These language features will be used in code samples throughout this section.</span></span>

## <a name="see-also"></a><span data-ttu-id="04e56-158">Vea también</span><span class="sxs-lookup"><span data-stu-id="04e56-158">See also</span></span>

- [<span data-ttu-id="04e56-159">Introducción a las transformaciones funcionales puras (C#)</span><span class="sxs-lookup"><span data-stu-id="04e56-159">Introduction to Pure Functional Transformations (C#)</span></span>](./introduction-to-pure-functional-transformations.md)
- [<span data-ttu-id="04e56-160">Diferencias entre la programación funcional y la programación imperativa (C#)</span><span class="sxs-lookup"><span data-stu-id="04e56-160">Functional Programming vs. Imperative Programming (C#)</span></span>](./functional-programming-vs-imperative-programming.md)
