---
title: Consultas de tabla única (LINQ to DataSet)
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
ms.assetid: 0b74bcf8-3f87-449f-bff7-6bcb0d69d212
ms.openlocfilehash: 7bb8d8e19ac9cf36eabc061ceba9c649b8a4cc00
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/12/2020
ms.locfileid: "79148977"
---
# <a name="single-table-queries-linq-to-dataset"></a><span data-ttu-id="8edfb-102">Consultas de tabla única (LINQ to DataSet)</span><span class="sxs-lookup"><span data-stu-id="8edfb-102">Single-Table Queries (LINQ to DataSet)</span></span>
<span data-ttu-id="8edfb-103">Las consultas de Language-Integrated Query (LINQ) <xref:System.Collections.Generic.IEnumerable%601> funcionan <xref:System.Linq.IQueryable%601> en orígenes de datos que implementan la interfaz o la interfaz.</span><span class="sxs-lookup"><span data-stu-id="8edfb-103">Language-Integrated Query (LINQ) queries work on data sources that implement the <xref:System.Collections.Generic.IEnumerable%601> interface or the <xref:System.Linq.IQueryable%601> interface.</span></span> <span data-ttu-id="8edfb-104">La <xref:System.Data.DataTable> clase no implementa ninguna interfaz, <xref:System.Data.DataTableExtensions.AsEnumerable%2A> por lo que <xref:System.Data.DataTable> debe llamar al `From` método si desea usar como origen en la cláusula de una consulta LINQ.</span><span class="sxs-lookup"><span data-stu-id="8edfb-104">The <xref:System.Data.DataTable> class does not implement either interface, so you must call the <xref:System.Data.DataTableExtensions.AsEnumerable%2A> method if you want to use the <xref:System.Data.DataTable> as a source in the `From` clause of a LINQ query.</span></span>  
  
 <span data-ttu-id="8edfb-105">En el ejemplo siguiente se obtienen todos los pedidos en línea desde la tabla SalesOrderHeader y se envían los resultados de id., fecha y número de pedido a la consola.</span><span class="sxs-lookup"><span data-stu-id="8edfb-105">The following example gets all the online orders from the SalesOrderHeader table and outputs the order ID, order date, and order number to the console.</span></span>  
  
 [!code-csharp[DP LINQ to DataSet Examples#Where1](../../../../samples/snippets/csharp/VS_Snippets_ADO.NET/DP LINQ to DataSet Examples/CS/Program.cs#where1)]  
 [!code-vb[DP LINQ to DataSet Examples#Where1](../../../../samples/snippets/visualbasic/VS_Snippets_ADO.NET/DP LINQ to DataSet Examples/VB/Module1.vb#where1)]
  
 <span data-ttu-id="8edfb-106">La consulta de variable local se inicializa con una expresión de consulta, que funciona en uno o varios orígenes de información aplicando uno o <xref:System.Data.DataSet> varios operadores de consulta de los operadores de consulta estándar o, en el caso de LINQ to DataSet, operadores específicos de la clase.</span><span class="sxs-lookup"><span data-stu-id="8edfb-106">The local variable query is initialized with a query expression, which operates on one or more information sources by applying one or more query operators from either the standard query operators or, in the case of LINQ to DataSet, operators specific to the <xref:System.Data.DataSet> class.</span></span> <span data-ttu-id="8edfb-107">La expresión de consulta del ejemplo anterior utiliza dos de los operadores estándar de consulta: `Where` y `Select`.</span><span class="sxs-lookup"><span data-stu-id="8edfb-107">The query expression in the previous example uses two of the standard query operators: `Where` and `Select`.</span></span>  
  
 <span data-ttu-id="8edfb-108">La cláusula `Where` filtra la secuencia basándose en una condición, en este caso que `OnlineOrderFlag` se establezca en `true`.</span><span class="sxs-lookup"><span data-stu-id="8edfb-108">The `Where` clause filters the sequence based on a condition, in this case that the `OnlineOrderFlag` is set to `true`.</span></span> <span data-ttu-id="8edfb-109">El operador `Select` asigna y devuelve un objeto enumerable que captura los argumentos pasados al operador.</span><span class="sxs-lookup"><span data-stu-id="8edfb-109">The `Select` operator allocates and returns an enumerable object that captures the arguments passed to the operator.</span></span> <span data-ttu-id="8edfb-110">En el ejemplo anterior, se crea un tipo anónimo con tres propiedades: `SalesOrderID`, `OrderDate` y `SalesOrderNumber`.</span><span class="sxs-lookup"><span data-stu-id="8edfb-110">In this above example, an anonymous type is created with three properties: `SalesOrderID`, `OrderDate`, and `SalesOrderNumber`.</span></span> <span data-ttu-id="8edfb-111">Los valores de estas tres propiedades se establecen en los valores de las columnas `SalesOrderID`, `OrderDate` y `SalesOrderNumber` a partir de la tabla `SalesOrderHeader`.</span><span class="sxs-lookup"><span data-stu-id="8edfb-111">The values of these three properties are set to the values of the `SalesOrderID`, `OrderDate`, and `SalesOrderNumber` columns from the `SalesOrderHeader` table.</span></span>  
  
 <span data-ttu-id="8edfb-112">A continuación, el bucle `foreach` enumera el objeto enumerable devuelto por `Select` y produce los resultados de la consulta.</span><span class="sxs-lookup"><span data-stu-id="8edfb-112">The `foreach` loop then enumerates the enumerable object returned by `Select` and yields the query results.</span></span> <span data-ttu-id="8edfb-113">Dado que una consulta es un tipo <xref:System.Linq.Enumerable>, que implementa <xref:System.Collections.Generic.IEnumerable%601>, la evaluación de la consulta se difiere hasta que se procesa una iteración en la variable de la consulta mediante el bucle `foreach`.</span><span class="sxs-lookup"><span data-stu-id="8edfb-113">Because query is an <xref:System.Linq.Enumerable> type, which implements <xref:System.Collections.Generic.IEnumerable%601>, the evaluation of the query is deferred until the query variable is iterated over using the `foreach` loop.</span></span> <span data-ttu-id="8edfb-114">La evaluación de la consulta en diferido permite que éstas se mantengan como valores que se pueden evaluar varias veces, y cada vez produciendo resultados potencialmente diferentes.</span><span class="sxs-lookup"><span data-stu-id="8edfb-114">Deferred query evaluation allows queries to be kept as values that can be evaluated multiple times, each time yielding potentially different results.</span></span>  
  
 <span data-ttu-id="8edfb-115">El método <xref:System.Data.DataRowExtensions.Field%2A> proporciona acceso a los valores de columna de <xref:System.Data.DataRow> y <xref:System.Data.DataRowExtensions.SetField%2A> (que no se mostraba en el ejemplo anterior) establece los valores de columna en <xref:System.Data.DataRow>.</span><span class="sxs-lookup"><span data-stu-id="8edfb-115">The <xref:System.Data.DataRowExtensions.Field%2A> method provides access to the column values of a <xref:System.Data.DataRow> and the <xref:System.Data.DataRowExtensions.SetField%2A> (not shown in the previous example) sets column values in a <xref:System.Data.DataRow>.</span></span> <span data-ttu-id="8edfb-116">Tanto el método <xref:System.Data.DataRowExtensions.Field%2A> como el método <xref:System.Data.DataRowExtensions.SetField%2A> controlan tipos que admiten valores null, por lo que no es necesario comprobar explícitamente si hay valores null.</span><span class="sxs-lookup"><span data-stu-id="8edfb-116">Both the <xref:System.Data.DataRowExtensions.Field%2A> method and <xref:System.Data.DataRowExtensions.SetField%2A> method handle nullable types, so you do not have to explicitly check for null values.</span></span> <span data-ttu-id="8edfb-117">Además, ambos son métodos genéricos, lo que significa que no es necesario convertir el tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="8edfb-117">Both methods are generic methods, also, which means you do not have to cast the return type.</span></span> <span data-ttu-id="8edfb-118">Puede utilizar el descriptor de acceso de columna preexistente en <xref:System.Data.DataRow> (por ejemplo, `o["OrderDate"]`), pero hacerlo le exigiría convertir el objeto de valor devuelto al tipo apropiado.</span><span class="sxs-lookup"><span data-stu-id="8edfb-118">You could use the pre-existing column accessor in <xref:System.Data.DataRow> (for example, `o["OrderDate"]`), but doing so would require you to cast the return object to the appropriate type.</span></span>  <span data-ttu-id="8edfb-119">Si la columna admite valores null, debe comprobar si el valor es null utilizando el método <xref:System.Data.DataRow.IsNull%2A>.</span><span class="sxs-lookup"><span data-stu-id="8edfb-119">If the column is nullable you have to check if the value is null by using the <xref:System.Data.DataRow.IsNull%2A> method.</span></span> <span data-ttu-id="8edfb-120">Para obtener más información, vea [Métodos genéricos Field y SetField](generic-field-and-setfield-methods-linq-to-dataset.md).</span><span class="sxs-lookup"><span data-stu-id="8edfb-120">For more information, see [Generic Field and SetField Methods](generic-field-and-setfield-methods-linq-to-dataset.md).</span></span>  
  
 <span data-ttu-id="8edfb-121">Observe que el tipo de datos especificado en el parámetro `T` genérico de los métodos <xref:System.Data.DataRowExtensions.Field%2A> y <xref:System.Data.DataRowExtensions.SetField%2A> deben coincidir con el tipo del valor subyacente; en caso contrario, se producirá una <xref:System.InvalidCastException>.</span><span class="sxs-lookup"><span data-stu-id="8edfb-121">Note that the data type specified in the generic parameter `T` of the <xref:System.Data.DataRowExtensions.Field%2A> method and <xref:System.Data.DataRowExtensions.SetField%2A> method must match the type of the underlying value or an <xref:System.InvalidCastException> will be thrown.</span></span> <span data-ttu-id="8edfb-122">El nombre de columna especificado debe también coincidir con el nombre de una columna en <xref:System.Data.DataSet>, en caso contrario, se producirá una <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="8edfb-122">The specified column name must also match the name of a column in the <xref:System.Data.DataSet> or an <xref:System.ArgumentException> will be thrown.</span></span> <span data-ttu-id="8edfb-123">En ambos casos, la excepción se produce en tiempo de ejecución de enumeración de datos, cuando se ejecuta la consulta.</span><span class="sxs-lookup"><span data-stu-id="8edfb-123">In both cases, the exception is thrown at run time data enumeration when the query is executed.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="8edfb-124">Consulte también</span><span class="sxs-lookup"><span data-stu-id="8edfb-124">See also</span></span>

- [<span data-ttu-id="8edfb-125">Consultas entre tablas</span><span class="sxs-lookup"><span data-stu-id="8edfb-125">Cross-Table Queries</span></span>](cross-table-queries-linq-to-dataset.md)
- [<span data-ttu-id="8edfb-126">Consultar objetos DataSet con tipo</span><span class="sxs-lookup"><span data-stu-id="8edfb-126">Querying Typed DataSets</span></span>](querying-typed-datasets.md)
- [<span data-ttu-id="8edfb-127">Métodos genéricos Field y SetField</span><span class="sxs-lookup"><span data-stu-id="8edfb-127">Generic Field and SetField Methods</span></span>](generic-field-and-setfield-methods-linq-to-dataset.md)
