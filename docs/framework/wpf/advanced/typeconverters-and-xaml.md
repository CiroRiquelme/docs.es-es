---
title: Clases TypeConverter y XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XAML [WPF], TypeConverter class
ms.assetid: f6313e4d-e89d-497d-ac87-b43511a1ae4b
ms.openlocfilehash: 94cfce44d5702e0550310723ec56184096165436
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 03/12/2020
ms.locfileid: "79187290"
---
# <a name="typeconverters-and-xaml"></a><span data-ttu-id="f866f-102">Clases TypeConverter y XAML</span><span class="sxs-lookup"><span data-stu-id="f866f-102">TypeConverters and XAML</span></span>
<span data-ttu-id="f866f-103">En este tema se presenta el propósito de la conversión de tipos desde cadenas como característica general del lenguaje XAML.</span><span class="sxs-lookup"><span data-stu-id="f866f-103">This topic introduces the purpose of type conversion from string as a general XAML language feature.</span></span> <span data-ttu-id="f866f-104">En .NET Framework, <xref:System.ComponentModel.TypeConverter> la clase sirve para un propósito determinado como parte de la implementación de una clase personalizada administrada que se puede usar como un valor de propiedad en el uso de atributos XAML.</span><span class="sxs-lookup"><span data-stu-id="f866f-104">In the .NET Framework, the <xref:System.ComponentModel.TypeConverter> class serves a particular purpose as part of the implementation for a managed custom class that can be used as a property value in XAML attribute usage.</span></span> <span data-ttu-id="f866f-105">Si escribe una clase personalizada y desea que las instancias de la clase se puedan <xref:System.ComponentModel.TypeConverterAttribute> usar como valores <xref:System.ComponentModel.TypeConverter> de atributo configurables XAML, es posible que deba aplicar una a la clase, escribir una clase personalizada o ambas.</span><span class="sxs-lookup"><span data-stu-id="f866f-105">If you write a custom class, and you want instances of your class to be usable as XAML settable attribute values, you might need to apply a <xref:System.ComponentModel.TypeConverterAttribute> to your class, write a custom <xref:System.ComponentModel.TypeConverter> class, or both.</span></span>  

## <a name="type-conversion-concepts"></a><span data-ttu-id="f866f-106">Conceptos de la conversión de tipos</span><span class="sxs-lookup"><span data-stu-id="f866f-106">Type Conversion Concepts</span></span>  
  
### <a name="xaml-and-string-values"></a><span data-ttu-id="f866f-107">Valores de cadena y XAML</span><span class="sxs-lookup"><span data-stu-id="f866f-107">XAML and String Values</span></span>  
 <span data-ttu-id="f866f-108">Cuando se establece un valor de atributo en un archivo XAML, el tipo inicial de ese valor es una cadena en texto puro.</span><span class="sxs-lookup"><span data-stu-id="f866f-108">When you set an attribute value in a XAML file, the initial type of that value is a string in pure text.</span></span> <span data-ttu-id="f866f-109">Incluso otros primitivos <xref:System.Double> como son inicialmente cadenas de texto a un procesador XAML.</span><span class="sxs-lookup"><span data-stu-id="f866f-109">Even other primitives such as <xref:System.Double> are initially text strings to a XAML processor.</span></span>  
  
 <span data-ttu-id="f866f-110">Un procesador XAML necesita dos fragmentos de información para procesar un valor de atributo.</span><span class="sxs-lookup"><span data-stu-id="f866f-110">A XAML processor needs two pieces of information in order to process an attribute value.</span></span> <span data-ttu-id="f866f-111">El primer fragmento de información es el tipo de valor de la propiedad que se va a establecer.</span><span class="sxs-lookup"><span data-stu-id="f866f-111">The first piece of information is the value type of the property that is being set.</span></span> <span data-ttu-id="f866f-112">Cualquier cadena que defina un valor de atributo y que se procese en XAML se tiene que convertir o resolver en última instancia en un valor de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="f866f-112">Any string that defines an attribute value and that is processed in XAML must ultimately be converted or resolved to a value of that type.</span></span> <span data-ttu-id="f866f-113">Si el valor es un primitivo que el analizador XAML entiende (por ejemplo, un valor numérico), se tratará de convertir la cadena directamente.</span><span class="sxs-lookup"><span data-stu-id="f866f-113">If the value is a primitive that is understood by the XAML parser (such as a numeric value), a direct conversion of the string is attempted.</span></span> <span data-ttu-id="f866f-114">Si el valor es una enumeración, se usa la cadena para comprobar una coincidencia de nombre con una constante con nombre en esa enumeración.</span><span class="sxs-lookup"><span data-stu-id="f866f-114">If the value is an enumeration, the string is used to check for a name match to a named constant in that enumeration.</span></span> <span data-ttu-id="f866f-115">Si el valor no es un primitivo que el analizador entiende ni una enumeración, entonces el tipo en cuestión debe poder proporcionar una instancia del tipo, o un valor, basado en una cadena convertida.</span><span class="sxs-lookup"><span data-stu-id="f866f-115">If the value is neither a parser-understood primitive nor an enumeration, then the type in question must be able to provide an instance of the type, or a value, based on a converted string.</span></span> <span data-ttu-id="f866f-116">Esto se hace indicando una clase de convertidor de tipos.</span><span class="sxs-lookup"><span data-stu-id="f866f-116">This is done by indicating a type converter class.</span></span> <span data-ttu-id="f866f-117">El convertidor de tipos es, en realidad, una clase del asistente para proporcionar valores de otra clase, tanto para el escenario de XAML como, potencialmente, para las llamadas de código en el código de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="f866f-117">The type converter is effectively a helper class for providing values of another class, both for the XAML scenario and also potentially for code calls in .NET code.</span></span>  
  
### <a name="using-existing-type-conversion-behavior-in-xaml"></a><span data-ttu-id="f866f-118">Usar el comportamiento de conversión de tipos existente en XAML</span><span class="sxs-lookup"><span data-stu-id="f866f-118">Using Existing Type Conversion Behavior in XAML</span></span>  
 <span data-ttu-id="f866f-119">Dependiendo de la medida en que esté familiarizado con los conceptos de XAML subyacentes, es posible que ya use el comportamiento de conversión de tipos en aplicaciones XAML básicas sin darse cuenta.</span><span class="sxs-lookup"><span data-stu-id="f866f-119">Depending on your familiarity with the underlying XAML concepts, you may already be using type conversion behavior in basic application XAML without realizing it.</span></span> <span data-ttu-id="f866f-120">Por ejemplo, WPFWPF define literalmente cientos de <xref:System.Windows.Point>propiedades que toman un valor de tipo .</span><span class="sxs-lookup"><span data-stu-id="f866f-120">For instance, WPF defines literally hundreds of properties that take a value of type <xref:System.Windows.Point>.</span></span> <span data-ttu-id="f866f-121">A <xref:System.Windows.Point> es un valor que describe una coordenada en un espacio de coordenadas <xref:System.Windows.Point.X%2A> <xref:System.Windows.Point.Y%2A>bidimensional, y realmente sólo tiene dos propiedades importantes: y .</span><span class="sxs-lookup"><span data-stu-id="f866f-121">A <xref:System.Windows.Point> is a value that describes a coordinate in a two-dimensional coordinate space, and it really just has two important properties: <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A>.</span></span> <span data-ttu-id="f866f-122">Cuando se especifica un punto en XAML, se especifica como una cadena con <xref:System.Windows.Point.X%2A> un <xref:System.Windows.Point.Y%2A> delimitador (normalmente una coma) entre los valores y se proporcionan.</span><span class="sxs-lookup"><span data-stu-id="f866f-122">When you specify a point in XAML, you specify it as a string with a delimiter (typically a comma) between the <xref:System.Windows.Point.X%2A> and <xref:System.Windows.Point.Y%2A> values you provide.</span></span> <span data-ttu-id="f866f-123">Por ejemplo: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span><span class="sxs-lookup"><span data-stu-id="f866f-123">For example: `<LinearGradientBrush StartPoint="0,0" EndPoint="1,1"/>`.</span></span>  
  
 <span data-ttu-id="f866f-124">Incluso este tipo <xref:System.Windows.Point> simple de y su uso simple en XAML implican un convertidor de tipos.</span><span class="sxs-lookup"><span data-stu-id="f866f-124">Even this simple type of <xref:System.Windows.Point> and its simple usage in XAML involve a type converter.</span></span> <span data-ttu-id="f866f-125">En este caso que <xref:System.Windows.PointConverter>es la clase .</span><span class="sxs-lookup"><span data-stu-id="f866f-125">In this case that is the class <xref:System.Windows.PointConverter>.</span></span>  
  
 <span data-ttu-id="f866f-126">El convertidor <xref:System.Windows.Point> de tipos definido en el nivel de clase <xref:System.Windows.Point>simplifica los usos de marcado de todas las propiedades que toman .</span><span class="sxs-lookup"><span data-stu-id="f866f-126">The type converter for <xref:System.Windows.Point> defined at the class level streamlines the markup usages of all properties that take <xref:System.Windows.Point>.</span></span> <span data-ttu-id="f866f-127">Si en este caso no hubiera un convertidor de tipos, se necesitaría el marcado siguiente, mucho más detallado, para obtener el mismo ejemplo mostrado previamente:</span><span class="sxs-lookup"><span data-stu-id="f866f-127">Without a type converter here, you would need the following much more verbose markup for the same example shown previously:</span></span>  

```xaml
<LinearGradientBrush>
  <LinearGradientBrush.StartPoint>
    <Point X="0" Y="0"/>
  </LinearGradientBrush.StartPoint>
  <LinearGradientBrush.EndPoint>
    <Point X="1" Y="1"/>
  </LinearGradientBrush.EndPoint>
</LinearGradientBrush>
 ```
  
 <span data-ttu-id="f866f-128">La decisión entre usar la cadena de conversión de tipos o una sintaxis equivalente más detallada suele depender del estilo de codificación.</span><span class="sxs-lookup"><span data-stu-id="f866f-128">Whether to use the type conversion string or a more verbose equivalent syntax is generally a coding style choice.</span></span> <span data-ttu-id="f866f-129">Es posible que el flujo de trabajo de las herramientas de XAML también influya en el modo de establecer los valores.</span><span class="sxs-lookup"><span data-stu-id="f866f-129">Your XAML tooling workflow might also influence how values are set.</span></span> <span data-ttu-id="f866f-130">Algunas herramientas de XAML suelen crear la forma más detallada del marcado porque facilita la operación de ida y vuelta en las vistas de los diseñadores o su propio mecanismo de serialización.</span><span class="sxs-lookup"><span data-stu-id="f866f-130">Some XAML tools tend to emit the most verbose form of the markup because it is easier to round-trip to designer views or its own serialization mechanism.</span></span>  
  
 <span data-ttu-id="f866f-131">Los convertidores de tipos existentes generalmente se pueden detectar en tipos WPF y .NET <xref:System.ComponentModel.TypeConverterAttribute>Framework comprobando una clase (o propiedad) para la presencia de un .</span><span class="sxs-lookup"><span data-stu-id="f866f-131">Existing type converters can generally be discovered on WPF and .NET Framework types by checking a class (or property) for the presence of an applied <xref:System.ComponentModel.TypeConverterAttribute>.</span></span> <span data-ttu-id="f866f-132">Este atributo denominará la clase que es el convertidor de tipos para los valores de ese tipo, tanto para los fines de XAML como, potencialmente, para otros propósitos.</span><span class="sxs-lookup"><span data-stu-id="f866f-132">This attribute will name the class that is the supporting type converter for values of that type, for XAML purposes as well as potentially other purposes.</span></span>  
  
### <a name="type-converters-and-markup-extensions"></a><span data-ttu-id="f866f-133">Convertidores de tipos y extensiones de marcado</span><span class="sxs-lookup"><span data-stu-id="f866f-133">Type Converters and Markup Extensions</span></span>  
 <span data-ttu-id="f866f-134">Las extensiones de marcado y los convertidores de tipos rellenan los roles ortogonales en lo que se refiere al comportamiento del procesador XAML y los escenarios a los que se aplican.</span><span class="sxs-lookup"><span data-stu-id="f866f-134">Markup extensions and type converters fill orthogonal roles in terms of XAML processor behavior and the scenarios that they are applied to.</span></span> <span data-ttu-id="f866f-135">Aunque el contexto está disponible para los usos de la extensión de marcado, en las implementaciones de extensión de marcado no se suele comprobar el comportamiento de conversión de tipos de aquellas propiedades en las que una extensión de marcado proporciona un valor.</span><span class="sxs-lookup"><span data-stu-id="f866f-135">Although context is available for markup extension usages, type conversion behavior of properties where a markup extension provides a value is generally is not checked in the markup extension implementations.</span></span> <span data-ttu-id="f866f-136">En otras palabras, aunque una extensión de marcado devuelva una cadena de texto como salida de `ProvideValue`, no se invoca el comportamiento de la conversión de tipos en esa cadena tal y como se aplica a una propiedad concreta o al tipo de valor de propiedad. Generalmente, el propósito de una extensión de marcado es procesar una cadena y devolver un objeto sin ningún convertidor de tipos implicado.</span><span class="sxs-lookup"><span data-stu-id="f866f-136">In other words, even if a markup extension returns a text string as its `ProvideValue` output, type conversion behavior on that string as applied to a specific property or property value type is not invoked, Generally, the purpose of a markup extension is to process a string and return an object without any type converter involved.</span></span>  
  
 <span data-ttu-id="f866f-137">Una situación común en la que es necesario usar una extensión de marcado en lugar de un convertidor de tipos es cuando se hace referencia a un objeto que ya existe.</span><span class="sxs-lookup"><span data-stu-id="f866f-137">One common situation where a markup extension is necessary rather than a type converter is to make a reference to an object that already exists.</span></span> <span data-ttu-id="f866f-138">En el mejor de los casos, un convertidor de tipos sin estado solamente podría generar una nueva instancia, lo que podría no ser conveniente.</span><span class="sxs-lookup"><span data-stu-id="f866f-138">At best, a stateless type converter could only generate a new instance, which might not be desirable.</span></span> <span data-ttu-id="f866f-139">Para más información sobre las extensiones de marcado, vea [Extensiones de marcado y XAML de WPF](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="f866f-139">For more information on markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span>  
  
### <a name="native-type-converters"></a><span data-ttu-id="f866f-140">Convertidores de tipos nativos</span><span class="sxs-lookup"><span data-stu-id="f866f-140">Native Type Converters</span></span>  
 <span data-ttu-id="f866f-141">En la implementación de WPF y .NET Framework del analizador de XAML, hay algunos tipos que presentan un control nativo de la conversión de tipos, si bien no se trata de tipos que puedan considerarse primitivos por convención.</span><span class="sxs-lookup"><span data-stu-id="f866f-141">In the WPF and .NET Framework implementation of the XAML parser, there are certain types that have native type conversion handling, yet are not types that might conventionally be thought of as primitives.</span></span> <span data-ttu-id="f866f-142">Un ejemplo de este tipo es <xref:System.DateTime>.</span><span class="sxs-lookup"><span data-stu-id="f866f-142">An example of such a type is <xref:System.DateTime>.</span></span> <span data-ttu-id="f866f-143">La razón de esto se basa en cómo funciona <xref:System.DateTime> la arquitectura de .NET Framework: el tipo se define en mscorlib, la biblioteca más básica de .NET.</span><span class="sxs-lookup"><span data-stu-id="f866f-143">The reason for this is based on how the .NET Framework architecture works: the type <xref:System.DateTime> is defined in mscorlib, the most basic library in .NET.</span></span> <span data-ttu-id="f866f-144"><xref:System.DateTime>no se permite que se atribuya con un atributo<xref:System.ComponentModel.TypeConverterAttribute> que proviene de otro ensamblado que introduce una dependencia (es de System) por lo que no se puede admitir el mecanismo de detección de convertidor de tipos habitual mediante la atribución.</span><span class="sxs-lookup"><span data-stu-id="f866f-144"><xref:System.DateTime> is not permitted to be attributed with an attribute that comes from another assembly that introduces a dependency (<xref:System.ComponentModel.TypeConverterAttribute> is from System) so the usual type converter discovery mechanism by attributing cannot be supported.</span></span> <span data-ttu-id="f866f-145">En su lugar, el analizador de XAML tiene una lista de tipos que necesitan este procesamiento nativo y los procesa de manera parecida a los primitivos auténticos.</span><span class="sxs-lookup"><span data-stu-id="f866f-145">Instead, the XAML parser has a list of types that need such native processing and processes these similarly to how the true primitives are processed.</span></span> <span data-ttu-id="f866f-146">(En el <xref:System.DateTime> caso de esto <xref:System.DateTime.Parse%2A>implica una llamada a .)</span><span class="sxs-lookup"><span data-stu-id="f866f-146">(In the case of <xref:System.DateTime> this involves a call to <xref:System.DateTime.Parse%2A>.)</span></span>  
  
<a name="Implementing_a_Type_Converter"></a>
## <a name="implementing-a-type-converter"></a><span data-ttu-id="f866f-147">Implementación de un convertidor de tipos</span><span class="sxs-lookup"><span data-stu-id="f866f-147">Implementing a Type Converter</span></span>  
  
### <a name="typeconverter"></a><span data-ttu-id="f866f-148">TypeConverter</span><span class="sxs-lookup"><span data-stu-id="f866f-148">TypeConverter</span></span>  
 <span data-ttu-id="f866f-149">En <xref:System.Windows.Point> el ejemplo dado <xref:System.Windows.PointConverter> anteriormente, se mencionó la clase.</span><span class="sxs-lookup"><span data-stu-id="f866f-149">In the <xref:System.Windows.Point> example given previously, the class <xref:System.Windows.PointConverter> was mentioned.</span></span> <span data-ttu-id="f866f-150">Para las implementaciones de .NET de XAML, todos los convertidores de tipos <xref:System.ComponentModel.TypeConverter>que se usan con fines XAML son clases que derivan de la clase base.</span><span class="sxs-lookup"><span data-stu-id="f866f-150">For .NET implementations of XAML, all type converters that are used for XAML purposes are classes that derive from the base class <xref:System.ComponentModel.TypeConverter>.</span></span> <span data-ttu-id="f866f-151">La <xref:System.ComponentModel.TypeConverter> clase existía en versiones de .NET Framework que preceden a la existencia de XAML; uno de sus usos originales era proporcionar la conversión de cadenas para los cuadros de diálogo de propiedades en diseñadores visuales.</span><span class="sxs-lookup"><span data-stu-id="f866f-151">The <xref:System.ComponentModel.TypeConverter> class existed in versions of .NET Framework that precede the existence of XAML; one of its original usages was to provide string conversion for property dialogs in visual designers.</span></span> <span data-ttu-id="f866f-152">Para XAML, el <xref:System.ComponentModel.TypeConverter> rol de se expande para incluir ser la clase base para las conversiones a cadena y de cadena que permiten analizar un valor de atributo de cadena y, posiblemente, procesar un valor en tiempo de ejecución de una propiedad de objeto determinada en una cadena para la serialización como un atributo.</span><span class="sxs-lookup"><span data-stu-id="f866f-152">For XAML, the role of <xref:System.ComponentModel.TypeConverter> is expanded to include being the base class for to-string and from-string conversions that enable parsing a string attribute value, and possibly processing a run-time value of a particular object property back into a string for serialization as an attribute.</span></span>  
  
 <span data-ttu-id="f866f-153"><xref:System.ComponentModel.TypeConverter>define cuatro miembros que son relevantes para convertir a y desde cadenas para fines de procesamiento XAML:</span><span class="sxs-lookup"><span data-stu-id="f866f-153"><xref:System.ComponentModel.TypeConverter> defines four members that are relevant for converting to and from strings for XAML processing purposes:</span></span>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>  
  
- <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>  
  
 <span data-ttu-id="f866f-154">De ellos, el <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>método más importante es .</span><span class="sxs-lookup"><span data-stu-id="f866f-154">Of these, the most important method is <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A>.</span></span> <span data-ttu-id="f866f-155">Este método convierte la cadena de entrada en el tipo de objeto necesario.</span><span class="sxs-lookup"><span data-stu-id="f866f-155">This method converts the input string to the required object type.</span></span> <span data-ttu-id="f866f-156">Estrictamente hablando, el <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> método podría implementarse para convertir una gama mucho más amplia de tipos en el tipo de destino previsto del convertidor y, por lo tanto, servir <xref:System.String> a propósitos que se extienden más allá de XAML, como admitir conversiones en tiempo de ejecución, pero para fines XAML es sólo la ruta de acceso de código que puede procesar una entrada lo que importa.</span><span class="sxs-lookup"><span data-stu-id="f866f-156">Strictly speaking, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method could be implemented to convert a much wider range of types into the converter's intended destination type, and thus serve purposes that extend beyond XAML such as supporting run-time conversions, but for XAML purposes it is only the code path that can process a <xref:System.String> input that matters.</span></span>  
  
 <span data-ttu-id="f866f-157">El siguiente método <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>más importante es .</span><span class="sxs-lookup"><span data-stu-id="f866f-157">The next most important method is <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span> <span data-ttu-id="f866f-158">Si una aplicación se convierte en una representación de marcado (por <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> ejemplo, si se guarda en XAML como un archivo), es responsable de producir una representación de marcado.</span><span class="sxs-lookup"><span data-stu-id="f866f-158">If an application is converted to a markup representation (for instance, if it is saved to XAML as a file), <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is responsible for producing a markup representation.</span></span> <span data-ttu-id="f866f-159">En este caso, la ruta de acceso de `destinationType` <xref:System.String> código que importa para XAML es cuando se pasa un archivo de .</span><span class="sxs-lookup"><span data-stu-id="f866f-159">In this case, the code path that matters for XAML is when you pass a `destinationType` of <xref:System.String> .</span></span>  
  
 <span data-ttu-id="f866f-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> y <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> son métodos de compatibilidad que se usan cuando un servicio consulta las capacidades de la implementación de <xref:System.ComponentModel.TypeConverter> .</span><span class="sxs-lookup"><span data-stu-id="f866f-160"><xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> and <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> are support methods that are used when a service queries the capabilities of the <xref:System.ComponentModel.TypeConverter> implementation.</span></span> <span data-ttu-id="f866f-161">Estos métodos se tienen que implementar para obtener `true` en los casos específicos de tipo que los métodos de conversión equivalentes de su convertidor admiten.</span><span class="sxs-lookup"><span data-stu-id="f866f-161">You must implement these methods to return `true` for type-specific cases that the equivalent conversion methods of your converter support.</span></span> <span data-ttu-id="f866f-162">Para los propósitos de XAML, esto suele traducirse en el tipo <xref:System.String> .</span><span class="sxs-lookup"><span data-stu-id="f866f-162">For XAML purposes, this generally means the <xref:System.String> type.</span></span>  
  
### <a name="culture-information-and-type-converters-for-xaml"></a><span data-ttu-id="f866f-163">Información de referencia cultural y convertidores de tipos para XAML</span><span class="sxs-lookup"><span data-stu-id="f866f-163">Culture Information and Type Converters for XAML</span></span>  

 <span data-ttu-id="f866f-164">Cada <xref:System.ComponentModel.TypeConverter> implementación puede tener su propia interpretación de lo que constituye una cadena válida para una conversión y también puede usar o omitir la descripción de tipo pasada como parámetros.</span><span class="sxs-lookup"><span data-stu-id="f866f-164">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description passed as parameters.</span></span> <span data-ttu-id="f866f-165">Existe una consideración importante con respecto a la referencia cultural y a la conversión de tipos de XAML.</span><span class="sxs-lookup"><span data-stu-id="f866f-165">There is an important consideration with regard to culture and XAML type conversion.</span></span> <span data-ttu-id="f866f-166">XAML admite plenamente el uso de cadenas traducibles como valores de atributo.</span><span class="sxs-lookup"><span data-stu-id="f866f-166">Using localizable strings as attribute values is entirely supported by XAML.</span></span> <span data-ttu-id="f866f-167">Pero no se admite el uso de esa cadena traducible como entrada del convertidor de tipos con requisitos de referencia cultural concretos, porque los convertidores de tipos para los valores de atributo de XAML requieren necesariamente un comportamiento de análisis de lenguaje fijo mediante la referencia cultural `en-US`.</span><span class="sxs-lookup"><span data-stu-id="f866f-167">But using that localizable string as type converter input with specific culture requirements is not supported, because type converters for XAML attribute values involve a necessarily fixed-language parsing behavior, using `en-US` culture.</span></span> <span data-ttu-id="f866f-168">Para obtener más información sobre los motivos de diseño de esta restricción, debe consultar la especificación del lenguaje XAML ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span><span class="sxs-lookup"><span data-stu-id="f866f-168">For more information on the design reasons for this restriction, you should consult the XAML language specification ([\[MS-XAML\]](https://download.microsoft.com/download/0/A/6/0A6F7755-9AF5-448B-907D-13985ACCF53E/[MS-XAML].pdf).</span></span>  
  
 <span data-ttu-id="f866f-169">Un ejemplo que ilustra por qué una referencia cultural puede ser un problema, es que algunas referencias culturales usan una coma como delimitador de separador decimal para los números.</span><span class="sxs-lookup"><span data-stu-id="f866f-169">As an example where culture can be an issue, some cultures use a comma as their decimal point delimiter for numbers.</span></span> <span data-ttu-id="f866f-170">Esto entra en conflicto con el comportamiento de muchos de los convertidores de tipos de XAML de WPF, consistente en usar una coma como delimitador (basándose en precedentes históricos como el formato X,Y común o las listas delimitadas por comas).</span><span class="sxs-lookup"><span data-stu-id="f866f-170">This will collide with the behavior that many of the WPF XAML type converters have, which is to use a comma as a delimiter (based on historical precedents such as the common X,Y form, or comma delimited lists).</span></span> <span data-ttu-id="f866f-171">El problema tampoco se resuelve pasando una referencia cultural en el XAML circundante (estableciendo `Language` o `xml:lang` en la referencia cultural `sl-SI`, que es una de las que usan la coma para separar los decimales de esta manera).</span><span class="sxs-lookup"><span data-stu-id="f866f-171">Even passing a culture in the surrounding XAML (setting `Language` or `xml:lang` to the `sl-SI` culture, an example of a culture that uses a comma for decimal in this way) does not solve the issue.</span></span>  
  
### <a name="implementing-convertfrom"></a><span data-ttu-id="f866f-172">Implementación de ConvertFrom</span><span class="sxs-lookup"><span data-stu-id="f866f-172">Implementing ConvertFrom</span></span>  
 <span data-ttu-id="f866f-173">Para ser igual de utilizable que una implementación de <xref:System.ComponentModel.TypeConverter> que admite XAML, el método <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> para ese convertidor tiene que aceptar una cadena como parámetro `value` .</span><span class="sxs-lookup"><span data-stu-id="f866f-173">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> method for that converter must accept a string as the `value` parameter.</span></span> <span data-ttu-id="f866f-174">Si la cadena estaba en formato válido <xref:System.ComponentModel.TypeConverter> y la implementación se puede convertir, el objeto devuelto debe admitir una conversión al tipo esperado por la propiedad.</span><span class="sxs-lookup"><span data-stu-id="f866f-174">If the string was in valid format, and can be converted by the <xref:System.ComponentModel.TypeConverter> implementation, then the returned object must support a cast to the type expected by the property.</span></span> <span data-ttu-id="f866f-175">De lo contrario, la implementación de <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> debe devolver `null`.</span><span class="sxs-lookup"><span data-stu-id="f866f-175">Otherwise, the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation must return `null`.</span></span>  
  
 <span data-ttu-id="f866f-176">Cada <xref:System.ComponentModel.TypeConverter> implementación puede tener su propia interpretación de lo que constituye una cadena válida para una conversión y también puede usar o ignorar la descripción de tipo o contextos de referencia cultural pasados como parámetros.</span><span class="sxs-lookup"><span data-stu-id="f866f-176">Each <xref:System.ComponentModel.TypeConverter> implementation can have its own interpretation of what constitutes a valid string for a conversion, and can also use or ignore the type description or culture contexts passed as parameters.</span></span> <span data-ttu-id="f866f-177">Pero es posible que el procesamiento de XAML de WPF no pase valores al contexto de descripción del tipo en todos los casos y que tampoco pase referencias culturales basadas en `xml:lang`.</span><span class="sxs-lookup"><span data-stu-id="f866f-177">However, the WPF XAML processing might not pass values to the type description context in all cases, and also might not pass culture based on `xml:lang`.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="f866f-178">No use los caracteres de llave, en concreto {, como elementos posibles del formato de cadena.</span><span class="sxs-lookup"><span data-stu-id="f866f-178">Do not use the curly brace characters, particularly {, as a possible element of your string format.</span></span> <span data-ttu-id="f866f-179">Estos caracteres están reservados como entrada y salida de una secuencia de extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="f866f-179">These characters are reserved as the entry and exit for a markup extension sequence.</span></span>  
  
### <a name="implementing-convertto"></a><span data-ttu-id="f866f-180">Implementación de ConvertTo</span><span class="sxs-lookup"><span data-stu-id="f866f-180">Implementing ConvertTo</span></span>  
 <span data-ttu-id="f866f-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> se usa en teoría para admitir la serialización.</span><span class="sxs-lookup"><span data-stu-id="f866f-181"><xref:System.ComponentModel.TypeConverter.ConvertTo%2A> is potentially used for serialization support.</span></span> <span data-ttu-id="f866f-182">La compatibilidad con la serialización a través de <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> para el tipo personalizado y su convertidor de tipos no es un requisito imprescindible.</span><span class="sxs-lookup"><span data-stu-id="f866f-182">Serialization support through <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> for your custom type and its type converter is not an absolute requirement.</span></span> <span data-ttu-id="f866f-183">Pero, si implementa un control, o usa la serialización como parte de las características o del diseño de la clase, conviene implementar <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span><span class="sxs-lookup"><span data-stu-id="f866f-183">However, if you are implementing a control, or using serialization of as part of the features or design of your class, you should implement <xref:System.ComponentModel.TypeConverter.ConvertTo%2A>.</span></span>  
  
 <span data-ttu-id="f866f-184">Para que se <xref:System.ComponentModel.TypeConverter> pueda usar como <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> una implementación que admita XAML, el método para `value` ese convertidor debe aceptar una instancia del tipo (o un valor) que se admite como parámetro.</span><span class="sxs-lookup"><span data-stu-id="f866f-184">To be usable as a <xref:System.ComponentModel.TypeConverter> implementation that supports XAML, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> method for that converter must accept an instance of the type (or a value) being supported as the `value` parameter.</span></span> <span data-ttu-id="f866f-185">Cuando `destinationType` el parámetro <xref:System.String>es el tipo , el objeto <xref:System.String>devuelto debe poder convertirse como .</span><span class="sxs-lookup"><span data-stu-id="f866f-185">When the `destinationType` parameter is the type <xref:System.String>, then the returned object must be able to be cast as <xref:System.String>.</span></span> <span data-ttu-id="f866f-186">La cadena devuelta debe representar un valor serializado de `value`.</span><span class="sxs-lookup"><span data-stu-id="f866f-186">The returned string must represent a serialized value of `value`.</span></span> <span data-ttu-id="f866f-187">Idealmente, el formato de serialización que elija debe ser capaz de <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> generar el mismo valor si esa cadena se pasó a la implementación del mismo convertidor, sin pérdida significativa de información.</span><span class="sxs-lookup"><span data-stu-id="f866f-187">Ideally, the serialization format you choose should be capable of generating the same value if that string were passed to the <xref:System.ComponentModel.TypeConverter.ConvertFrom%2A> implementation of the same converter, without significant loss of information.</span></span>  
  
 <span data-ttu-id="f866f-188">Si el valor no se puede serializar o <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> el convertidor `null`no admite la serialización, la implementación debe devolver , y se permite producir una excepción en este caso.</span><span class="sxs-lookup"><span data-stu-id="f866f-188">If the value cannot be serialized, or the converter does not support serialization, the <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> implementation must return `null`, and is permitted to throw an exception in this case.</span></span> <span data-ttu-id="f866f-189">Pero si produce excepciones, debe informar de la incapacidad de <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> usar esa conversión <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> como parte de la implementación para que se admita la práctica recomendada de comprobar primero para evitar excepciones.</span><span class="sxs-lookup"><span data-stu-id="f866f-189">But if you do throw exceptions, you should report the inability to use that conversion as part of your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation so that the best practice of checking with <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> first to avoid exceptions is supported.</span></span>  
  
 <span data-ttu-id="f866f-190">Si `destinationType` el parámetro <xref:System.String>no es de tipo , puede elegir su propio control de convertidor.</span><span class="sxs-lookup"><span data-stu-id="f866f-190">If `destinationType` parameter is not of type <xref:System.String>, you can choose your own converter handling.</span></span> <span data-ttu-id="f866f-191">Normalmente, volvería al control de implementación base, que en la base <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> genera una excepción específica.</span><span class="sxs-lookup"><span data-stu-id="f866f-191">Typically, you would revert to base implementation handling, which in the basemost <xref:System.ComponentModel.TypeConverter.ConvertTo%2A> raises a specific exception.</span></span>  
  
### <a name="implementing-canconvertto"></a><span data-ttu-id="f866f-192">Implementación de CanConvertTo</span><span class="sxs-lookup"><span data-stu-id="f866f-192">Implementing CanConvertTo</span></span>  
 <span data-ttu-id="f866f-193">Su implementación de <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> debe devolver `true` para `destinationType` de tipo <xref:System.String>o, si no, respetar la implementación base.</span><span class="sxs-lookup"><span data-stu-id="f866f-193">Your <xref:System.ComponentModel.TypeConverter.CanConvertTo%2A> implementation should return `true` for `destinationType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
### <a name="implementing-canconvertfrom"></a><span data-ttu-id="f866f-194">Implementación de CanConvertFrom</span><span class="sxs-lookup"><span data-stu-id="f866f-194">Implementing CanConvertFrom</span></span>  
 <span data-ttu-id="f866f-195">Su implementación de <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> debe devolver `true` para `sourceType` de tipo <xref:System.String>o, si no, respetar la implementación base.</span><span class="sxs-lookup"><span data-stu-id="f866f-195">Your <xref:System.ComponentModel.TypeConverter.CanConvertFrom%2A> implementation should return `true` for `sourceType` of type <xref:System.String>, and otherwise defer to the base implementation.</span></span>  
  
<a name="Applying_the_TypeConverterAttribute"></a>
## <a name="applying-the-typeconverterattribute"></a><span data-ttu-id="f866f-196">Aplicación de TypeConverterAttribute</span><span class="sxs-lookup"><span data-stu-id="f866f-196">Applying the TypeConverterAttribute</span></span>  
 <span data-ttu-id="f866f-197">Para que un procesador XAML use el convertidor de tipos personalizado como convertidor de <xref:System.ComponentModel.TypeConverterAttribute> tipos que actúa para una clase personalizada, debe aplicar el convertidor de tipos personalizado a la definición de clase.</span><span class="sxs-lookup"><span data-stu-id="f866f-197">In order for your custom type converter to be used as the acting type converter for a custom class by a XAML processor, you must apply the <xref:System.ComponentModel.TypeConverterAttribute> to your class definition.</span></span> <span data-ttu-id="f866f-198">El <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> que se especifica a través del atributo debe ser el nombre de tipo del convertidor de tipos personalizado.</span><span class="sxs-lookup"><span data-stu-id="f866f-198">The <xref:System.ComponentModel.TypeConverterAttribute.ConverterTypeName%2A> that you specify through the attribute must be the type name of your custom type converter.</span></span> <span data-ttu-id="f866f-199">Con este atributo aplicado, cuando un procesador XAML controla valores en los que el tipo de propiedad usa el tipo de la clase personalizada, puede especificar cadenas y devolver instancias de objeto.</span><span class="sxs-lookup"><span data-stu-id="f866f-199">With this attribute applied, when a XAML processor handles values where the property type uses your custom class type, it can input strings and return object instances.</span></span>  
  
 <span data-ttu-id="f866f-200">También puede proporcionar un convertidor de tipos por cada propiedad.</span><span class="sxs-lookup"><span data-stu-id="f866f-200">You can also provide a type converter on a per-property basis.</span></span> <span data-ttu-id="f866f-201">En lugar de <xref:System.ComponentModel.TypeConverterAttribute> aplicar a a la definición de clase, aplíquela a una definición de propiedad (la definición principal, no las implementaciones dentro de ella). `get` / `set`</span><span class="sxs-lookup"><span data-stu-id="f866f-201">Instead of applying a <xref:System.ComponentModel.TypeConverterAttribute> to the class definition, apply it to a property definition (the main definition, not the `get`/`set` implementations within it).</span></span> <span data-ttu-id="f866f-202">El tipo de la propiedad tiene que coincidir con el tipo que el convertidor de tipos personalizado procesa.</span><span class="sxs-lookup"><span data-stu-id="f866f-202">The type of the property must match the type that is processed by your custom type converter.</span></span> <span data-ttu-id="f866f-203">Con este atributo aplicado, cuando un procesador XAML controla valores de esa propiedad, puede procesar cadenas de entrada y devolver instancias de objeto.</span><span class="sxs-lookup"><span data-stu-id="f866f-203">With this attribute applied, when a XAML processor handles values of that property, it can process input strings and return object instances.</span></span> <span data-ttu-id="f866f-204">La técnica de convertidor de tipos por propiedad es especialmente útil si elige usar un tipo de propiedad de Microsoft <xref:System.ComponentModel.TypeConverterAttribute> .NET Framework o de alguna otra biblioteca donde no puede controlar la definición de clase y no puede aplicar una allí.</span><span class="sxs-lookup"><span data-stu-id="f866f-204">The per-property type converter technique is particularly useful if you choose to use a property type from Microsoft .NET Framework or from some other library where you cannot control the class definition and cannot apply a <xref:System.ComponentModel.TypeConverterAttribute> there.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="f866f-205">Consulte también</span><span class="sxs-lookup"><span data-stu-id="f866f-205">See also</span></span>

- <xref:System.ComponentModel.TypeConverter>
- [<span data-ttu-id="f866f-206">Información general sobre XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="f866f-206">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="f866f-207">Extensiones de marcado y XAML de WPF</span><span class="sxs-lookup"><span data-stu-id="f866f-207">Markup Extensions and WPF XAML</span></span>](markup-extensions-and-wpf-xaml.md)
- [<span data-ttu-id="f866f-208">Detalles de la sintaxis XAML</span><span class="sxs-lookup"><span data-stu-id="f866f-208">XAML Syntax In Detail</span></span>](xaml-syntax-in-detail.md)
