---
title: 'Optimizar el rendimiento: Comportamiento de objetos'
ms.date: 03/30/2017
dev_langs:
- csharp
- vb
helpviewer_keywords:
- user interface virtualization [WPF]
- dependency properties [WPF], performance
- event handlers [WPF]
- object performance considerations [WPF]
- Freezable objects [WPF], performance
ms.assetid: 73aa2f47-1d73-439a-be1f-78dc4ba2b5bd
ms.openlocfilehash: 64e567cd28e9458b483b0963e0dedd924ad23bab
ms.sourcegitcommit: 011314e0c8eb4cf4a11d92078f58176c8c3efd2d
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/09/2020
ms.locfileid: "77094493"
---
# <a name="optimizing-performance-object-behavior"></a><span data-ttu-id="af227-102">Optimizar el rendimiento: Comportamiento de objetos</span><span class="sxs-lookup"><span data-stu-id="af227-102">Optimizing Performance: Object Behavior</span></span>
<span data-ttu-id="af227-103">Entender el comportamiento intrínseco de los objetos [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] le ayudará a lograr un equilibrio correcto entre funcionalidad y rendimiento.</span><span class="sxs-lookup"><span data-stu-id="af227-103">Understanding the intrinsic behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] objects will help you make the right tradeoffs between functionality and performance.</span></span>  

<a name="Not_Removing_Event_Handlers"></a>   
## <a name="not-removing-event-handlers-on-objects-may-keep-objects-alive"></a><span data-ttu-id="af227-104">No quitar los controladores de eventos en objetos puede mantener los objetos activos</span><span class="sxs-lookup"><span data-stu-id="af227-104">Not Removing Event Handlers on Objects may Keep Objects Alive</span></span>  
 <span data-ttu-id="af227-105">El delegado que un objeto pasa a su evento es realmente una referencia a ese objeto.</span><span class="sxs-lookup"><span data-stu-id="af227-105">The delegate that an object passes to its event is effectively a reference to that object.</span></span> <span data-ttu-id="af227-106">Por lo tanto, los controladores de eventos pueden mantener los objetos activos durante más tiempo de lo esperado.</span><span class="sxs-lookup"><span data-stu-id="af227-106">Therefore, event handlers can keep objects alive longer than expected.</span></span> <span data-ttu-id="af227-107">Al realizar la limpieza de un objeto registrado para escuchar los eventos de un objeto, es esencial quitar ese delegado antes de liberar el objeto.</span><span class="sxs-lookup"><span data-stu-id="af227-107">When performing clean up of an object that has registered to listen to an object's event, it is essential to remove that delegate before releasing the object.</span></span> <span data-ttu-id="af227-108">Mantener activos objetos innecesarios aumenta el uso de memoria de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="af227-108">Keeping unneeded objects alive increases the application's memory usage.</span></span> <span data-ttu-id="af227-109">Esto es especialmente cierto cuando el objeto es la raíz de un árbol lógico o un árbol visual.</span><span class="sxs-lookup"><span data-stu-id="af227-109">This is especially true when the object is the root of a logical tree or a visual tree.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="af227-110">presenta un patrón de agente de escucha de evento débil para los eventos que pueden ser útiles en situaciones donde es difícil mantener el seguimiento de las relaciones de vigencia de objeto entre el origen y el agente de escucha.</span><span class="sxs-lookup"><span data-stu-id="af227-110">introduces a weak event listener pattern for events that can be useful in situations where the object lifetime relationships between source and listener are difficult to keep track of.</span></span> <span data-ttu-id="af227-111">Algunos eventos [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] existentes usan este patrón.</span><span class="sxs-lookup"><span data-stu-id="af227-111">Some existing [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] events use this pattern.</span></span> <span data-ttu-id="af227-112">Si implementa objetos con eventos personalizados, este patrón puede resultarle de utilidad.</span><span class="sxs-lookup"><span data-stu-id="af227-112">If you are implementing objects with custom events, this pattern may be of use to you.</span></span> <span data-ttu-id="af227-113">Para obtener más información, consulte [Modelos de evento débil](weak-event-patterns.md).</span><span class="sxs-lookup"><span data-stu-id="af227-113">For details, see [Weak Event Patterns](weak-event-patterns.md).</span></span>  
  
 <span data-ttu-id="af227-114">Hay varias herramientas, como CLR Profiler y Visor de espacios de trabajo, que pueden proporcionar información sobre el uso de memoria de un proceso especificado.</span><span class="sxs-lookup"><span data-stu-id="af227-114">There are several tools, such as the CLR Profiler and the Working Set Viewer, that can provides information on the memory usage of a specified process.</span></span> <span data-ttu-id="af227-115">CLR Profiler incluye varias vistas muy útiles del perfil de asignación, incluido un histograma de tipos asignados, gráficos de asignación y llamadas, una línea de tiempo que muestra recolecciones de elementos no usados de varias generaciones y el estado resultante del montón administrado después de esas colecciones, y un árbol de llamadas que muestra las asignaciones por método y las cargas de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="af227-115">The CLR Profiler includes a number of very useful views of the allocation profile, including a histogram of allocated types, allocation and call graphs, a time line showing garbage collections of various generations and the resulting state of the managed heap after those collections, and a call tree showing per-method allocations and assembly loads.</span></span> <span data-ttu-id="af227-116">Para más información, vea [Rendimiento](https://docs.microsoft.com/previous-versions/aa497289(v=msdn.10)).</span><span class="sxs-lookup"><span data-stu-id="af227-116">For more information, see [Performance](https://docs.microsoft.com/previous-versions/aa497289(v=msdn.10)).</span></span>  
  
<a name="DPs_and_Objects"></a>   
## <a name="dependency-properties-and-objects"></a><span data-ttu-id="af227-117">Propiedades y objetos de dependencia</span><span class="sxs-lookup"><span data-stu-id="af227-117">Dependency Properties and Objects</span></span>  
 <span data-ttu-id="af227-118">En general, el acceso a una propiedad de dependencia de un <xref:System.Windows.DependencyObject> no es más lento que el acceso a una propiedad de CLR.</span><span class="sxs-lookup"><span data-stu-id="af227-118">In general, accessing a dependency property of a <xref:System.Windows.DependencyObject> is not slower than accessing a CLR property.</span></span> <span data-ttu-id="af227-119">Aunque hay una pequeña sobrecarga de rendimiento para establecer un valor de propiedad, obtener un valor es tan rápido como obtener el valor de una propiedad de CLR.</span><span class="sxs-lookup"><span data-stu-id="af227-119">While there is a small performance overhead for setting a property value, getting a value is as fast as getting the value from a CLR property.</span></span> <span data-ttu-id="af227-120">El desplazamiento de la pequeña sobrecarga de rendimiento es el hecho de que las propiedades de dependencia admiten características robustas, como el enlace de datos, la animación, la herencia y los estilos.</span><span class="sxs-lookup"><span data-stu-id="af227-120">Offsetting the small performance overhead is the fact that dependency properties support robust features, such as data binding, animation, inheritance, and styling.</span></span> <span data-ttu-id="af227-121">Para obtener más información sobre las propiedades de dependencia, vea [Información general sobre las propiedades de dependencia](dependency-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="af227-121">For more information, see [Dependency Properties Overview](dependency-properties-overview.md).</span></span>  
  
### <a name="dependencyproperty-optimizations"></a><span data-ttu-id="af227-122">Optimizaciones de DependencyProperty</span><span class="sxs-lookup"><span data-stu-id="af227-122">DependencyProperty Optimizations</span></span>  
 <span data-ttu-id="af227-123">Debe definir las propiedades de dependencia en la aplicación con mucho cuidado.</span><span class="sxs-lookup"><span data-stu-id="af227-123">You should define dependency properties in your application very carefully.</span></span> <span data-ttu-id="af227-124">Si el <xref:System.Windows.DependencyProperty> afecta solo a las opciones de metadatos de tipo de representación, en lugar de otras opciones de metadatos como <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, debe marcarla como tal invalidando sus metadatos.</span><span class="sxs-lookup"><span data-stu-id="af227-124">If your <xref:System.Windows.DependencyProperty> affects only render type metadata options, rather than other metadata options such as <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, you should mark it as such by overriding its metadata.</span></span> <span data-ttu-id="af227-125">Para obtener más información sobre cómo invalidar u obtener los metadatos de las propiedades, consulte [Metadatos de las propiedades de dependencia](dependency-property-metadata.md).</span><span class="sxs-lookup"><span data-stu-id="af227-125">For more information about overriding or obtaining property metadata, see [Dependency Property Metadata](dependency-property-metadata.md).</span></span>  
  
 <span data-ttu-id="af227-126">Puede ser más eficaz hacer que un controlador de cambio de propiedad invalide los pases de medición, organización y representación manualmente si todos los cambios de propiedad no afectan realmente a la medición, organización y representación.</span><span class="sxs-lookup"><span data-stu-id="af227-126">It may be more efficient to have a property change handler invalidate the measure, arrange, and render passes manually if not all property changes actually affect measure, arrange, and render.</span></span> <span data-ttu-id="af227-127">Por ejemplo, es posible que decida volver a representar un fondo solo cuando un valor sea mayor que un límite establecido.</span><span class="sxs-lookup"><span data-stu-id="af227-127">For instance, you might decide to re-render a background only when a value is greater than a set limit.</span></span> <span data-ttu-id="af227-128">En este caso, el controlador de cambios de propiedades solo invalidará la representación cuando el valor supere el límite establecido.</span><span class="sxs-lookup"><span data-stu-id="af227-128">In this case, your property change handler would only invalidate render when the value exceeds the set limit.</span></span>  
  
### <a name="making-a-dependencyproperty-inheritable-is-not-free"></a><span data-ttu-id="af227-129">Hacer que DependencyProperty sea heredable tiene consecuencias</span><span class="sxs-lookup"><span data-stu-id="af227-129">Making a DependencyProperty Inheritable is Not Free</span></span>  
 <span data-ttu-id="af227-130">De forma predeterminada, las propiedades de dependencia registradas no son heredables.</span><span class="sxs-lookup"><span data-stu-id="af227-130">By default, registered dependency properties are non-inheritable.</span></span> <span data-ttu-id="af227-131">Sin embargo, puede hacer explícitamente que una propiedad sea heredable.</span><span class="sxs-lookup"><span data-stu-id="af227-131">However, you can explicitly make any property inheritable.</span></span> <span data-ttu-id="af227-132">Aunque es una característica útil, convertir una propiedad a heredable afecta al rendimiento, ya que aumenta la cantidad de tiempo para la invalidación de propiedades.</span><span class="sxs-lookup"><span data-stu-id="af227-132">While this is a useful feature, converting a property to be inheritable impacts performance by increasing the length of time for property invalidation.</span></span>  
  
### <a name="use-registerclasshandler-carefully"></a><span data-ttu-id="af227-133">Usar RegisterClassHandler con cuidado</span><span class="sxs-lookup"><span data-stu-id="af227-133">Use RegisterClassHandler Carefully</span></span>  
 <span data-ttu-id="af227-134">Aunque llamar a <xref:System.Windows.EventManager.RegisterClassHandler%2A> permite guardar el estado de la instancia, es importante tener en cuenta que se llama al controlador en cada instancia, lo que puede causar problemas de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="af227-134">While calling <xref:System.Windows.EventManager.RegisterClassHandler%2A> allows you to save your instance state, it is important to be aware that the handler is called on every instance, which can cause performance problems.</span></span> <span data-ttu-id="af227-135">Use solo <xref:System.Windows.EventManager.RegisterClassHandler%2A> cuando la aplicación requiera que guarde el estado de la instancia.</span><span class="sxs-lookup"><span data-stu-id="af227-135">Only use <xref:System.Windows.EventManager.RegisterClassHandler%2A> when your application requires that you save your instance state.</span></span>  
  
### <a name="set-the-default-value-for-a-dependencyproperty-during-registration"></a><span data-ttu-id="af227-136">Establecer el valor predeterminado para DependencyProperty durante el registro</span><span class="sxs-lookup"><span data-stu-id="af227-136">Set the Default Value for a DependencyProperty during Registration</span></span>  
 <span data-ttu-id="af227-137">Al crear una <xref:System.Windows.DependencyProperty> que requiera un valor predeterminado, establezca el valor usando los metadatos predeterminados que se pasan como un parámetro al método <xref:System.Windows.DependencyProperty.Register%2A> de la <xref:System.Windows.DependencyProperty>.</span><span class="sxs-lookup"><span data-stu-id="af227-137">When creating a <xref:System.Windows.DependencyProperty> that requires a default value, set the value using the default metadata passed as a parameter to the <xref:System.Windows.DependencyProperty.Register%2A> method of the <xref:System.Windows.DependencyProperty>.</span></span> <span data-ttu-id="af227-138">Use esta técnica en lugar de establecer el valor de propiedad en un constructor o en cada instancia de un elemento.</span><span class="sxs-lookup"><span data-stu-id="af227-138">Use this technique rather than setting the property value in a constructor or on each instance of an element.</span></span>  
  
### <a name="set-the-propertymetadata-value-using-register"></a><span data-ttu-id="af227-139">Establecer el valor de PropertyMetadata mediante el Registro</span><span class="sxs-lookup"><span data-stu-id="af227-139">Set the PropertyMetadata Value using Register</span></span>  
 <span data-ttu-id="af227-140">Al crear un <xref:System.Windows.DependencyProperty>, tiene la opción de establecer el <xref:System.Windows.PropertyMetadata> mediante los métodos <xref:System.Windows.DependencyProperty.Register%2A> o <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>.</span><span class="sxs-lookup"><span data-stu-id="af227-140">When creating a <xref:System.Windows.DependencyProperty>, you have the option of setting the <xref:System.Windows.PropertyMetadata> using either the <xref:System.Windows.DependencyProperty.Register%2A> or <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> methods.</span></span> <span data-ttu-id="af227-141">Aunque el objeto puede tener un constructor estático para llamar a <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, no es la solución óptima y afectará al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="af227-141">Although your object could have a static constructor to call <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, this is not the optimal solution and will impact performance.</span></span> <span data-ttu-id="af227-142">Para obtener el mejor rendimiento, establezca la <xref:System.Windows.PropertyMetadata> durante la llamada a <xref:System.Windows.DependencyProperty.Register%2A>.</span><span class="sxs-lookup"><span data-stu-id="af227-142">For best performance, set the <xref:System.Windows.PropertyMetadata> during the call to <xref:System.Windows.DependencyProperty.Register%2A>.</span></span>  
  
<a name="Freezable_Objects"></a>   
## <a name="freezable-objects"></a><span data-ttu-id="af227-143">Objetos Freezable</span><span class="sxs-lookup"><span data-stu-id="af227-143">Freezable Objects</span></span>  
 <span data-ttu-id="af227-144">Un <xref:System.Windows.Freezable> es un tipo especial de objeto que tiene dos Estados: inmovilizado e inmovilizado.</span><span class="sxs-lookup"><span data-stu-id="af227-144">A <xref:System.Windows.Freezable> is a special type of object that has two states: unfrozen and frozen.</span></span> <span data-ttu-id="af227-145">Inmovilizar objetos siempre que sea posible mejora el rendimiento de la aplicación y reduce su conjunto de trabajo.</span><span class="sxs-lookup"><span data-stu-id="af227-145">Freezing objects whenever possible improves the performance of your application and reduces its working set.</span></span> <span data-ttu-id="af227-146">Para obtener más información, consulte [Información general sobre objetos Freezable](freezable-objects-overview.md).</span><span class="sxs-lookup"><span data-stu-id="af227-146">For more information, see [Freezable Objects Overview](freezable-objects-overview.md).</span></span>  
  
 <span data-ttu-id="af227-147">Cada <xref:System.Windows.Freezable> tiene un evento <xref:System.Windows.Freezable.Changed> que se genera cada vez que cambia.</span><span class="sxs-lookup"><span data-stu-id="af227-147">Each <xref:System.Windows.Freezable> has a <xref:System.Windows.Freezable.Changed> event that is raised whenever it changes.</span></span> <span data-ttu-id="af227-148">Sin embargo, las notificaciones de cambio son costosas en términos de rendimiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="af227-148">However, change notifications are costly in terms of application performance.</span></span>  
  
 <span data-ttu-id="af227-149">Considere el siguiente ejemplo en el que cada <xref:System.Windows.Shapes.Rectangle> usa el mismo objeto <xref:System.Windows.Media.Brush>:</span><span class="sxs-lookup"><span data-stu-id="af227-149">Consider the following example in which each <xref:System.Windows.Shapes.Rectangle> uses the same <xref:System.Windows.Media.Brush> object:</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet2](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet2)]
 [!code-vb[Performance#PerformanceSnippet2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet2)]  
  
 <span data-ttu-id="af227-150">De forma predeterminada, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] proporciona un controlador de eventos para el evento <xref:System.Windows.Freezable.Changed> del objeto <xref:System.Windows.Media.SolidColorBrush> con el fin de invalidar la propiedad <xref:System.Windows.Shapes.Shape.Fill%2A> del objeto <xref:System.Windows.Shapes.Rectangle>.</span><span class="sxs-lookup"><span data-stu-id="af227-150">By default, [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provides an event handler for the <xref:System.Windows.Media.SolidColorBrush> object's <xref:System.Windows.Freezable.Changed> event in order to invalidate the <xref:System.Windows.Shapes.Rectangle> object's <xref:System.Windows.Shapes.Shape.Fill%2A> property.</span></span> <span data-ttu-id="af227-151">En este caso, cada vez que el <xref:System.Windows.Media.SolidColorBrush> tiene que activar su evento <xref:System.Windows.Freezable.Changed> se requiere invocar la función de devolución de llamada para cada <xref:System.Windows.Shapes.Rectangle>; la acumulación de estas invocaciones de función de devolución de llamada impone una penalización significativa en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="af227-151">In this case, each time the <xref:System.Windows.Media.SolidColorBrush> has to fire its <xref:System.Windows.Freezable.Changed> event it is required to invoke the callback function for each <xref:System.Windows.Shapes.Rectangle>—the accumulation of these callback function invocations impose a significant performance penalty.</span></span> <span data-ttu-id="af227-152">Además, es muy intensivo para el rendimiento agregar y quitar controladores en este punto, ya que la aplicación deberá recorrer toda la lista para ello.</span><span class="sxs-lookup"><span data-stu-id="af227-152">In addition, it is very performance intensive to add and remove handlers at this point since the application would have to traverse the entire list to do so.</span></span> <span data-ttu-id="af227-153">Si el escenario de la aplicación nunca cambia el <xref:System.Windows.Media.SolidColorBrush>, se le cobrará el costo de mantener <xref:System.Windows.Freezable.Changed> controladores de eventos innecesariamente.</span><span class="sxs-lookup"><span data-stu-id="af227-153">If your application scenario never changes the <xref:System.Windows.Media.SolidColorBrush>, you will be paying the cost of maintaining <xref:System.Windows.Freezable.Changed> event handlers unnecessarily.</span></span>  
  
 <span data-ttu-id="af227-154">La inmovilización de un <xref:System.Windows.Freezable> puede mejorar su rendimiento, ya que ya no es necesario dedicar recursos al mantenimiento de las notificaciones de cambios.</span><span class="sxs-lookup"><span data-stu-id="af227-154">Freezing a <xref:System.Windows.Freezable> can improve its performance, because it no longer needs to expend resources on maintaining change notifications.</span></span> <span data-ttu-id="af227-155">En la tabla siguiente se muestra el tamaño de un <xref:System.Windows.Media.SolidColorBrush> simple cuando su propiedad <xref:System.Windows.Freezable.IsFrozen%2A> está establecida en `true`, en comparación con cuando no lo está.</span><span class="sxs-lookup"><span data-stu-id="af227-155">The table below shows the size of a simple <xref:System.Windows.Media.SolidColorBrush> when its <xref:System.Windows.Freezable.IsFrozen%2A> property is set to `true`, compared to when it is not.</span></span> <span data-ttu-id="af227-156">Se supone que se aplica un pincel a la propiedad <xref:System.Windows.Shapes.Shape.Fill%2A> de diez objetos <xref:System.Windows.Shapes.Rectangle>.</span><span class="sxs-lookup"><span data-stu-id="af227-156">This assumes applying one brush to the <xref:System.Windows.Shapes.Shape.Fill%2A> property of ten <xref:System.Windows.Shapes.Rectangle> objects.</span></span>  
  
|<span data-ttu-id="af227-157">**State**</span><span class="sxs-lookup"><span data-stu-id="af227-157">**State**</span></span>|<span data-ttu-id="af227-158">**Tamaño**</span><span class="sxs-lookup"><span data-stu-id="af227-158">**Size**</span></span>|  
|---------------|--------------|  
|<span data-ttu-id="af227-159"><xref:System.Windows.Media.SolidColorBrush> inmovilizado</span><span class="sxs-lookup"><span data-stu-id="af227-159">Frozen <xref:System.Windows.Media.SolidColorBrush></span></span>|<span data-ttu-id="af227-160">212 bytes</span><span class="sxs-lookup"><span data-stu-id="af227-160">212 Bytes</span></span>|  
|<span data-ttu-id="af227-161"><xref:System.Windows.Media.SolidColorBrush> no inmovilizado</span><span class="sxs-lookup"><span data-stu-id="af227-161">Non-frozen <xref:System.Windows.Media.SolidColorBrush></span></span>|<span data-ttu-id="af227-162">972 bytes</span><span class="sxs-lookup"><span data-stu-id="af227-162">972 Bytes</span></span>|  
  
 <span data-ttu-id="af227-163">En el siguiente ejemplo de código se muestra este concepto:</span><span class="sxs-lookup"><span data-stu-id="af227-163">The following code sample demonstrates this concept:</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet3](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet3)]
 [!code-vb[Performance#PerformanceSnippet3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet3)]  
  
### <a name="changed-handlers-on-unfrozen-freezables-may-keep-objects-alive"></a><span data-ttu-id="af227-164">Los controladores modificados de objetos Freezable no inmovilizados pueden mantener los objetos activos</span><span class="sxs-lookup"><span data-stu-id="af227-164">Changed Handlers on Unfrozen Freezables may Keep Objects Alive</span></span>  
 <span data-ttu-id="af227-165">El delegado que un objeto pasa al evento <xref:System.Windows.Freezable.Changed> de un objeto <xref:System.Windows.Freezable> es realmente una referencia a ese objeto.</span><span class="sxs-lookup"><span data-stu-id="af227-165">The delegate that an object passes to a <xref:System.Windows.Freezable> object's <xref:System.Windows.Freezable.Changed> event is effectively a reference to that object.</span></span> <span data-ttu-id="af227-166">Por lo tanto, los controladores de eventos <xref:System.Windows.Freezable.Changed> pueden mantener los objetos activos más tiempo del esperado.</span><span class="sxs-lookup"><span data-stu-id="af227-166">Therefore, <xref:System.Windows.Freezable.Changed> event handlers can keep objects alive longer than expected.</span></span> <span data-ttu-id="af227-167">Al realizar la limpieza de un objeto registrado para escuchar el evento de <xref:System.Windows.Freezable.Changed> de un objeto <xref:System.Windows.Freezable>, es esencial quitar ese delegado antes de liberar el objeto.</span><span class="sxs-lookup"><span data-stu-id="af227-167">When performing clean up of an object that has registered to listen to a <xref:System.Windows.Freezable> object's <xref:System.Windows.Freezable.Changed> event, it is essential to remove that delegate before releasing the object.</span></span>  
  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="af227-168">también enlaza <xref:System.Windows.Freezable.Changed> eventos internamente.</span><span class="sxs-lookup"><span data-stu-id="af227-168">also hooks up <xref:System.Windows.Freezable.Changed> events internally.</span></span> <span data-ttu-id="af227-169">Por ejemplo, todas las propiedades de dependencia que toman <xref:System.Windows.Freezable> como valor escucharán automáticamente <xref:System.Windows.Freezable.Changed> eventos.</span><span class="sxs-lookup"><span data-stu-id="af227-169">For example, all dependency properties which take <xref:System.Windows.Freezable> as a value will listen to <xref:System.Windows.Freezable.Changed> events automatically.</span></span> <span data-ttu-id="af227-170">La propiedad <xref:System.Windows.Shapes.Shape.Fill%2A>, que toma un <xref:System.Windows.Media.Brush>, ilustra este concepto.</span><span class="sxs-lookup"><span data-stu-id="af227-170">The <xref:System.Windows.Shapes.Shape.Fill%2A> property, which takes a <xref:System.Windows.Media.Brush>, illustrates this concept.</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet4](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet4)]
 [!code-vb[Performance#PerformanceSnippet4](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet4)]  
  
 <span data-ttu-id="af227-171">En la asignación de `myBrush` a `myRectangle.Fill`, se agregará al evento <xref:System.Windows.Freezable.Changed> del objeto <xref:System.Windows.Media.SolidColorBrush> un delegado que apunte de nuevo al objeto <xref:System.Windows.Shapes.Rectangle>.</span><span class="sxs-lookup"><span data-stu-id="af227-171">On the assignment of `myBrush` to `myRectangle.Fill`, a delegate pointing back to the <xref:System.Windows.Shapes.Rectangle> object will be added to the <xref:System.Windows.Media.SolidColorBrush> object's <xref:System.Windows.Freezable.Changed> event.</span></span> <span data-ttu-id="af227-172">Esto significa que el código siguiente realmente no hace que `myRect` sea apto para la recolección de elementos no usados:</span><span class="sxs-lookup"><span data-stu-id="af227-172">This means the following code does not actually make `myRect` eligible for garbage collection:</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet5](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet5)]
 [!code-vb[Performance#PerformanceSnippet5](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet5)]  
  
 <span data-ttu-id="af227-173">En este caso `myBrush` sigue manteniendo `myRectangle` activo y volverá a llamar a él cuando desencadene su evento <xref:System.Windows.Freezable.Changed>.</span><span class="sxs-lookup"><span data-stu-id="af227-173">In this case `myBrush` is still keeping `myRectangle` alive and will call back to it when it fires its <xref:System.Windows.Freezable.Changed> event.</span></span> <span data-ttu-id="af227-174">Tenga en cuenta que la asignación de `myBrush` a la propiedad <xref:System.Windows.Shapes.Shape.Fill%2A> de una nueva <xref:System.Windows.Shapes.Rectangle> simplemente agregará otro controlador de eventos a `myBrush`.</span><span class="sxs-lookup"><span data-stu-id="af227-174">Note that assigning `myBrush` to the <xref:System.Windows.Shapes.Shape.Fill%2A> property of a new <xref:System.Windows.Shapes.Rectangle> will simply add another event handler to `myBrush`.</span></span>  
  
 <span data-ttu-id="af227-175">La manera recomendada de limpiar estos tipos de objetos es quitar el <xref:System.Windows.Media.Brush> de la propiedad <xref:System.Windows.Shapes.Shape.Fill%2A>, que a su vez quitará el controlador de eventos <xref:System.Windows.Freezable.Changed>.</span><span class="sxs-lookup"><span data-stu-id="af227-175">The recommended way to clean up these types of objects is to remove the <xref:System.Windows.Media.Brush> from the <xref:System.Windows.Shapes.Shape.Fill%2A> property, which will in turn remove the <xref:System.Windows.Freezable.Changed> event handler.</span></span>  
  
 [!code-csharp[Performance#PerformanceSnippet6](~/samples/snippets/csharp/VS_Snippets_Wpf/Performance/CSharp/Window1.xaml.cs#performancesnippet6)]
 [!code-vb[Performance#PerformanceSnippet6](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Performance/visualbasic/window1.xaml.vb#performancesnippet6)]  
  
<a name="User_Interface_Virtualization"></a>   
## <a name="user-interface-virtualization"></a><span data-ttu-id="af227-176">Virtualización de la interfaz de usuario</span><span class="sxs-lookup"><span data-stu-id="af227-176">User Interface Virtualization</span></span>  
 [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] <span data-ttu-id="af227-177">también proporciona una variación del elemento <xref:System.Windows.Controls.StackPanel> que "virtualiza" automáticamente el contenido secundario enlazado a datos.</span><span class="sxs-lookup"><span data-stu-id="af227-177">also provides a variation of the <xref:System.Windows.Controls.StackPanel> element that automatically "virtualizes" data-bound child content.</span></span> <span data-ttu-id="af227-178">En este contexto, la palabra "virtualizar" hace referencia a una técnica que permite generar un subconjunto de objetos a partir de un número de elementos de datos más grande basados en los elementos que están visibles en pantalla.</span><span class="sxs-lookup"><span data-stu-id="af227-178">In this context, the word virtualize refers to a technique by which a subset of objects are generated from a larger number of data items based upon which items are visible on-screen.</span></span> <span data-ttu-id="af227-179">Es intensiva, tanto en términos de memoria como de procesador, y permite generar un gran número de elementos de interfaz de usuario cuando solo pueden estar en pantalla algunos de ellos en un momento dado.</span><span class="sxs-lookup"><span data-stu-id="af227-179">It is intensive, both in terms of memory and processor, to generate a large number of UI elements when only a few may be on the screen at a given time.</span></span> <span data-ttu-id="af227-180"><xref:System.Windows.Controls.VirtualizingStackPanel> (a través de la funcionalidad proporcionada por <xref:System.Windows.Controls.VirtualizingPanel>) calcula los elementos visibles y funciona con la <xref:System.Windows.Controls.ItemContainerGenerator> de un <xref:System.Windows.Controls.ItemsControl> (como <xref:System.Windows.Controls.ListBox> o <xref:System.Windows.Controls.ListView>) para crear solo elementos para elementos visibles.</span><span class="sxs-lookup"><span data-stu-id="af227-180"><xref:System.Windows.Controls.VirtualizingStackPanel> (through functionality provided by <xref:System.Windows.Controls.VirtualizingPanel>) calculates visible items and works with the <xref:System.Windows.Controls.ItemContainerGenerator> from an <xref:System.Windows.Controls.ItemsControl> (such as <xref:System.Windows.Controls.ListBox> or <xref:System.Windows.Controls.ListView>) to only create elements for visible items.</span></span>  
  
 <span data-ttu-id="af227-181">Como optimización del rendimiento, los objetos visuales para estos elementos solo se generan o se mantienen activos si están visibles en pantalla.</span><span class="sxs-lookup"><span data-stu-id="af227-181">As a performance optimization, visual objects for these items are only generated or kept alive if they are visible on the screen.</span></span> <span data-ttu-id="af227-182">Cuando ya no están en el área visible del control, se pueden quitar los objetos visuales.</span><span class="sxs-lookup"><span data-stu-id="af227-182">When they are no longer in the viewable area of the control, the visual objects may be removed.</span></span> <span data-ttu-id="af227-183">Esto no se debe confundir con la virtualización de datos, donde los objetos de datos no existen en la colección local, sino que se transmiten según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="af227-183">This is not to be confused with data virtualization, where data objects are not all present in the local collection- rather streamed in as needed.</span></span>  
  
 <span data-ttu-id="af227-184">En la tabla siguiente se muestra el tiempo transcurrido para agregar y representar 5000 elementos <xref:System.Windows.Controls.TextBlock> en una <xref:System.Windows.Controls.StackPanel> y una <xref:System.Windows.Controls.VirtualizingStackPanel>.</span><span class="sxs-lookup"><span data-stu-id="af227-184">The table below shows the elapsed time adding and rendering 5000 <xref:System.Windows.Controls.TextBlock> elements to a <xref:System.Windows.Controls.StackPanel> and a <xref:System.Windows.Controls.VirtualizingStackPanel>.</span></span> <span data-ttu-id="af227-185">En este escenario, las medidas representan el tiempo que transviene entre adjuntar una cadena de texto a la propiedad <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> de un objeto <xref:System.Windows.Controls.ItemsControl> hasta el momento en que los elementos del panel muestran la cadena de texto.</span><span class="sxs-lookup"><span data-stu-id="af227-185">In this scenario, the measurements represent the time between attaching a text string to the <xref:System.Windows.Controls.ItemsControl.ItemsSource%2A> property of an <xref:System.Windows.Controls.ItemsControl> object to the time when the panel elements display the text string.</span></span>  
  
|<span data-ttu-id="af227-186">**Panel de host**</span><span class="sxs-lookup"><span data-stu-id="af227-186">**Host panel**</span></span>|<span data-ttu-id="af227-187">**Tiempo de representación (ms)**</span><span class="sxs-lookup"><span data-stu-id="af227-187">**Render time (ms)**</span></span>|  
|--------------------|----------------------------|  
|<xref:System.Windows.Controls.StackPanel>|<span data-ttu-id="af227-188">3210</span><span class="sxs-lookup"><span data-stu-id="af227-188">3210</span></span>|  
|<xref:System.Windows.Controls.VirtualizingStackPanel>|<span data-ttu-id="af227-189">46</span><span class="sxs-lookup"><span data-stu-id="af227-189">46</span></span>|  
  
## <a name="see-also"></a><span data-ttu-id="af227-190">Consulte también</span><span class="sxs-lookup"><span data-stu-id="af227-190">See also</span></span>

- [<span data-ttu-id="af227-191">Optimizar el rendimiento de la aplicación WPF</span><span class="sxs-lookup"><span data-stu-id="af227-191">Optimizing WPF Application Performance</span></span>](optimizing-wpf-application-performance.md)
- [<span data-ttu-id="af227-192">Planear para mejorar el rendimiento de aplicaciones</span><span class="sxs-lookup"><span data-stu-id="af227-192">Planning for Application Performance</span></span>](planning-for-application-performance.md)
- [<span data-ttu-id="af227-193">Aprovechar el hardware</span><span class="sxs-lookup"><span data-stu-id="af227-193">Taking Advantage of Hardware</span></span>](optimizing-performance-taking-advantage-of-hardware.md)
- [<span data-ttu-id="af227-194">Presentación y diseño</span><span class="sxs-lookup"><span data-stu-id="af227-194">Layout and Design</span></span>](optimizing-performance-layout-and-design.md)
- [<span data-ttu-id="af227-195">Imágenes y gráficos 2D</span><span class="sxs-lookup"><span data-stu-id="af227-195">2D Graphics and Imaging</span></span>](optimizing-performance-2d-graphics-and-imaging.md)
- [<span data-ttu-id="af227-196">Recursos de aplicación</span><span class="sxs-lookup"><span data-stu-id="af227-196">Application Resources</span></span>](optimizing-performance-application-resources.md)
- [<span data-ttu-id="af227-197">Texto</span><span class="sxs-lookup"><span data-stu-id="af227-197">Text</span></span>](optimizing-performance-text.md)
- [<span data-ttu-id="af227-198">Enlace de datos</span><span class="sxs-lookup"><span data-stu-id="af227-198">Data Binding</span></span>](optimizing-performance-data-binding.md)
- [<span data-ttu-id="af227-199">Otras recomendaciones de rendimiento</span><span class="sxs-lookup"><span data-stu-id="af227-199">Other Performance Recommendations</span></span>](optimizing-performance-other-recommendations.md)
