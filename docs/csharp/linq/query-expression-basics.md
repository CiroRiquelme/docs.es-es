---
title: Conceptos básicos de las expresiones de consulta (LINQ en C#)
description: En este tema se presentan los conceptos relacionados con las expresiones de consulta.
ms.date: 11/30/2016
ms.assetid: 027db1f8-346f-44d2-a16e-043fcea3a4e0
ms.openlocfilehash: 83beaa82d4b4b42ff9da5230edddd391b33a0717
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/14/2020
ms.locfileid: "79173359"
---
# <a name="query-expression-basics"></a><span data-ttu-id="49633-103">Conceptos básicos de las expresiones de consultas</span><span class="sxs-lookup"><span data-stu-id="49633-103">Query expression basics</span></span>

<span data-ttu-id="49633-104">En este artículo se presentan los conceptos básicos relacionados con las expresiones de consulta en C#.</span><span class="sxs-lookup"><span data-stu-id="49633-104">This article introduces the basic concepts related to query expressions in C#.</span></span>

## <a name="what-is-a-query-and-what-does-it-do"></a><span data-ttu-id="49633-105">¿Qué es una consulta y qué hace?</span><span class="sxs-lookup"><span data-stu-id="49633-105">What is a query and what does it do?</span></span>

<span data-ttu-id="49633-106">Una *consulta* es un conjunto de instrucciones que describen qué datos se recuperan de uno o varios orígenes de datos determinados y qué forma y qué organización deben tener los datos devueltos.</span><span class="sxs-lookup"><span data-stu-id="49633-106">A *query* is a set of instructions that describes what data to retrieve from a given data source (or sources) and what shape and organization the returned data should have.</span></span> <span data-ttu-id="49633-107">Una consulta es distinta de los resultados que genera.</span><span class="sxs-lookup"><span data-stu-id="49633-107">A query is distinct from the results that it produces.</span></span>

<span data-ttu-id="49633-108">Por lo general, los datos de origen se organizan lógicamente como una secuencia de elementos del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="49633-108">Generally, the source data is organized logically as a sequence of elements of the same kind.</span></span> <span data-ttu-id="49633-109">Por ejemplo, una tabla de base de datos SQL contiene una secuencia de filas.</span><span class="sxs-lookup"><span data-stu-id="49633-109">For example, a SQL database table contains a sequence of rows.</span></span> <span data-ttu-id="49633-110">En un archivo XML, hay una "secuencia" de elementos XML (aunque estos se organizan jerárquicamente en una estructura de árbol).</span><span class="sxs-lookup"><span data-stu-id="49633-110">In an XML file, there is a "sequence" of XML elements (although these are organized hierarchically in a tree structure).</span></span> <span data-ttu-id="49633-111">Una colección en memoria contiene una secuencia de objetos.</span><span class="sxs-lookup"><span data-stu-id="49633-111">An in-memory collection contains a sequence of objects.</span></span>

<span data-ttu-id="49633-112">Desde el punto de vista de la aplicación, el tipo y la estructura específicos de los datos de origen originales no es importante.</span><span class="sxs-lookup"><span data-stu-id="49633-112">From an application's viewpoint, the specific type and structure of the original source data is not important.</span></span> <span data-ttu-id="49633-113">La aplicación siempre ve los datos de origen como una colección <xref:System.Collections.Generic.IEnumerable%601> o <xref:System.Linq.IQueryable%601>.</span><span class="sxs-lookup"><span data-stu-id="49633-113">The application always sees the source data as an <xref:System.Collections.Generic.IEnumerable%601> or <xref:System.Linq.IQueryable%601> collection.</span></span> <span data-ttu-id="49633-114">Por ejemplo, en LINQ to XML, los datos de origen se hacen visibles como `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span><span class="sxs-lookup"><span data-stu-id="49633-114">For example, in LINQ to XML, the source data is made visible as an `IEnumerable`\<<xref:System.Xml.Linq.XElement>>.</span></span>

<span data-ttu-id="49633-115">Dada esta secuencia de origen, una consulta puede hacer una de estas tres cosas:</span><span class="sxs-lookup"><span data-stu-id="49633-115">Given this source sequence, a query may do one of three things:</span></span>

- <span data-ttu-id="49633-116">Recuperar un subconjunto de los elementos para generar una nueva secuencia sin modificar los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="49633-116">Retrieve a subset of the elements to produce a new sequence without modifying the individual elements.</span></span> <span data-ttu-id="49633-117">Después, la consulta puede ordenar o agrupar la secuencia devuelta de varias maneras, como se muestra en el ejemplo siguiente (supongamos que `scores` es `int[]`):</span><span class="sxs-lookup"><span data-stu-id="49633-117">The query may then sort or group the returned sequence in various ways, as shown in the following example (assume `scores` is an `int[]`):</span></span>

    [!code-csharp[csrefQueryExpBasics#45](~/samples/snippets/csharp/concepts/linq/query-expression-basics_1.cs)]

- <span data-ttu-id="49633-118">Recuperar una secuencia de elementos como en el ejemplo anterior, pero transformándolos en un nuevo tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="49633-118">Retrieve a sequence of elements as in the previous example but transform them to a new type of object.</span></span> <span data-ttu-id="49633-119">Por ejemplo, una consulta puede recuperar solo los apellidos de ciertos registros de clientes de un origen de datos.</span><span class="sxs-lookup"><span data-stu-id="49633-119">For example, a query may retrieve only the last names from certain customer records in a data source.</span></span> <span data-ttu-id="49633-120">También puede recuperar el registro completo y, luego, usarlo para construir otro tipo de objeto en memoria, o incluso datos XML, antes de generar la secuencia de resultado final.</span><span class="sxs-lookup"><span data-stu-id="49633-120">Or it may retrieve the complete record and then use it to construct another in-memory object type or even XML data before generating the final result sequence.</span></span> <span data-ttu-id="49633-121">En el ejemplo siguiente muestra una proyección de `int` a `string`.</span><span class="sxs-lookup"><span data-stu-id="49633-121">The following example shows a projection from an `int` to a `string`.</span></span> <span data-ttu-id="49633-122">Observe el nuevo tipo de `highScoresQuery`.</span><span class="sxs-lookup"><span data-stu-id="49633-122">Note the new type of `highScoresQuery`.</span></span>

    [!code-csharp[csrefQueryExpBasics#46](~/samples/snippets/csharp/concepts/linq/query-expression-basics_2.cs)]

- <span data-ttu-id="49633-123">Recuperar un valor singleton sobre los datos de origen, por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="49633-123">Retrieve a singleton value about the source data, such as:</span></span>

  - <span data-ttu-id="49633-124">El número de elementos que coinciden con una condición determinada.</span><span class="sxs-lookup"><span data-stu-id="49633-124">The number of elements that match a certain condition.</span></span>

  - <span data-ttu-id="49633-125">El elemento que tiene el mayor o el menor valor.</span><span class="sxs-lookup"><span data-stu-id="49633-125">The element that has the greatest or least value.</span></span>

  - <span data-ttu-id="49633-126">El primer elemento que coincide con una condición, o bien la suma de determinados valores de un conjunto de elementos especificado.</span><span class="sxs-lookup"><span data-stu-id="49633-126">The first element that matches a condition, or the sum of particular values in a specified set of elements.</span></span> <span data-ttu-id="49633-127">Por ejemplo, la consulta siguiente devuelve el número de resultados mayor que 80 de la matriz de enteros `scores`:</span><span class="sxs-lookup"><span data-stu-id="49633-127">For example, the following query returns the number of scores greater than 80 from the `scores` integer array:</span></span>

    [!code-csharp[csrefQueryExpBasics#47](~/samples/snippets/csharp/concepts/linq/query-expression-basics_3.cs)]

    <span data-ttu-id="49633-128">En el ejemplo anterior, observe el uso de los paréntesis alrededor de la expresión de consulta antes de llamar al método `Count`.</span><span class="sxs-lookup"><span data-stu-id="49633-128">In the previous example, note the use of parentheses around the query expression before the call to the `Count` method.</span></span> <span data-ttu-id="49633-129">Esto también se puede expresar mediante una nueva variable para almacenar el resultado concreto.</span><span class="sxs-lookup"><span data-stu-id="49633-129">You can also express this by using a new variable to store the concrete result.</span></span> <span data-ttu-id="49633-130">Esta técnica es más legible porque hace que la variable que almacena la consulta se mantenga separada de la consulta que almacena un resultado.</span><span class="sxs-lookup"><span data-stu-id="49633-130">This technique is more readable because it keeps the variable that stores the query separate from the query that stores a result.</span></span>

    [!code-csharp[csrefQueryExpBasics#48](~/samples/snippets/csharp/concepts/linq/query-expression-basics_4.cs)]

<span data-ttu-id="49633-131">En el ejemplo anterior, la consulta se ejecuta en la llamada a `Count`, ya que `Count` debe iterar los resultados para determinar el número de elementos devueltos por `highScoresQuery`.</span><span class="sxs-lookup"><span data-stu-id="49633-131">In the previous example, the query is executed in the call to `Count`, because `Count` must iterate over the results in order to determine the number of elements returned by `highScoresQuery`.</span></span>

## <a name="what-is-a-query-expression"></a><span data-ttu-id="49633-132">¿Qué es una expresión de consulta?</span><span class="sxs-lookup"><span data-stu-id="49633-132">What is a query expression?</span></span>

<span data-ttu-id="49633-133">Una *expresión de consulta* es una consulta que se expresa en sintaxis de consulta.</span><span class="sxs-lookup"><span data-stu-id="49633-133">A *query expression* is a query expressed in query syntax.</span></span> <span data-ttu-id="49633-134">Una expresión de consulta es una construcción de lenguaje de primera clase.</span><span class="sxs-lookup"><span data-stu-id="49633-134">A query expression is a first-class language construct.</span></span> <span data-ttu-id="49633-135">Es igual que cualquier otra expresión y puede usarse en cualquier contexto en el que una expresión de C# sea válida.</span><span class="sxs-lookup"><span data-stu-id="49633-135">It is just like any other expression and can be used in any context in which a C# expression is valid.</span></span> <span data-ttu-id="49633-136">Una expresión de consulta consta de un conjunto de cláusulas escritas en una sintaxis declarativa similar a SQL o XQuery.</span><span class="sxs-lookup"><span data-stu-id="49633-136">A query expression consists of a set of clauses written in a declarative syntax similar to SQL or XQuery.</span></span> <span data-ttu-id="49633-137">Cada cláusula contiene una o más expresiones de C#, y estas expresiones pueden ser una expresión de consulta en sí mismas o bien contener una expresión de consulta.</span><span class="sxs-lookup"><span data-stu-id="49633-137">Each clause in turn contains one or more C# expressions, and these expressions may themselves be either a query expression or contain a query expression.</span></span>

<span data-ttu-id="49633-138">Una expresión de consulta debe comenzar con una cláusula [from](../language-reference/keywords/from-clause.md) y debe terminar con una cláusula [select](../language-reference/keywords/select-clause.md) o [group](../language-reference/keywords/group-clause.md).</span><span class="sxs-lookup"><span data-stu-id="49633-138">A query expression must begin with a [from](../language-reference/keywords/from-clause.md) clause and must end with a [select](../language-reference/keywords/select-clause.md) or [group](../language-reference/keywords/group-clause.md) clause.</span></span> <span data-ttu-id="49633-139">Entre la primera cláusula `from` y la última cláusula `select` o `group`, puede contener una o varias de estas cláusulas opcionales: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) e incluso cláusulas [from](../language-reference/keywords/from-clause.md) adicionales.</span><span class="sxs-lookup"><span data-stu-id="49633-139">Between the first `from` clause and the last `select` or `group` clause, it can contain one or more of these optional clauses: [where](../language-reference/keywords/where-clause.md), [orderby](../language-reference/keywords/orderby-clause.md), [join](../language-reference/keywords/join-clause.md), [let](../language-reference/keywords/let-clause.md) and even additional [from](../language-reference/keywords/from-clause.md) clauses.</span></span> <span data-ttu-id="49633-140">También puede usar la palabra clave [into](../language-reference/keywords/into.md) para que el resultado de una cláusula `join` o `group` actúe como el origen de las cláusulas de consulta adicionales en la misma expresión de consulta.</span><span class="sxs-lookup"><span data-stu-id="49633-140">You can also use the [into](../language-reference/keywords/into.md) keyword to enable the result of a `join` or `group` clause to serve as the source for additional query clauses in the same query expression.</span></span>

### <a name="query-variable"></a><span data-ttu-id="49633-141">Variable de consulta</span><span class="sxs-lookup"><span data-stu-id="49633-141">Query variable</span></span>

<span data-ttu-id="49633-142">En LINQ, una variable de consulta es cualquier variable que almacene una *consulta* en lugar de los *resultados* de una consulta.</span><span class="sxs-lookup"><span data-stu-id="49633-142">In LINQ, a query variable is any variable that stores a *query* instead of the *results* of a query.</span></span> <span data-ttu-id="49633-143">Más concretamente, una variable de consulta es siempre un tipo enumerable que generará una secuencia de elementos cuando se itere en una instrucción `foreach` o en una llamada directa a su método `IEnumerator.MoveNext`.</span><span class="sxs-lookup"><span data-stu-id="49633-143">More specifically, a query variable is always an enumerable type that will produce a sequence of elements when it is iterated over in a `foreach` statement or a direct call to its `IEnumerator.MoveNext` method.</span></span>

<span data-ttu-id="49633-144">En el ejemplo de código siguiente se muestra una expresión de consulta simple con un origen de datos, una cláusula de filtrado, una cláusula de clasificación y ninguna transformación en los elementos de origen.</span><span class="sxs-lookup"><span data-stu-id="49633-144">The following code example shows a simple query expression with one data source, one filtering clause, one ordering clause, and no transformation of the source elements.</span></span> <span data-ttu-id="49633-145">La cláusula `select` finaliza la consulta.</span><span class="sxs-lookup"><span data-stu-id="49633-145">The `select` clause ends the query.</span></span>

[!code-csharp[csrefQueryExpBasics#49](~/samples/snippets/csharp/concepts/linq/query-expression-basics_5.cs)]

<span data-ttu-id="49633-146">En el ejemplo anterior, `scoreQuery` es una *variable de consulta*, que a veces se conoce simplemente como una *consulta*.</span><span class="sxs-lookup"><span data-stu-id="49633-146">In the previous example, `scoreQuery` is a *query variable,* which is sometimes referred to as just a *query*.</span></span> <span data-ttu-id="49633-147">La variable de consulta no almacena datos de resultado reales, que se producen en el bucle `foreach`.</span><span class="sxs-lookup"><span data-stu-id="49633-147">The query variable stores no actual result data, which is produced in the `foreach` loop.</span></span> <span data-ttu-id="49633-148">Cuando se ejecuta la instrucción `foreach`, los resultados de la consulta no se devuelven a través de la variable de consulta `scoreQuery`,</span><span class="sxs-lookup"><span data-stu-id="49633-148">And when the `foreach` statement executes, the query results are not returned through the query variable `scoreQuery`.</span></span> <span data-ttu-id="49633-149">sino a través de la variable de iteración `testScore`.</span><span class="sxs-lookup"><span data-stu-id="49633-149">Rather, they are returned through the iteration variable `testScore`.</span></span> <span data-ttu-id="49633-150">La variable `scoreQuery` se puede iterar en un segundo bucle `foreach`.</span><span class="sxs-lookup"><span data-stu-id="49633-150">The `scoreQuery` variable can be iterated in a second `foreach` loop.</span></span> <span data-ttu-id="49633-151">Siempre y cuando ni esta ni el origen de datos se hayan modificado, producirá los mismos resultados.</span><span class="sxs-lookup"><span data-stu-id="49633-151">It will produce the same results as long as neither it nor the data source has been modified.</span></span>

<span data-ttu-id="49633-152">Una variable de consulta puede almacenar una consulta expresada en sintaxis de consulta, en sintaxis de método o en una combinación de ambas.</span><span class="sxs-lookup"><span data-stu-id="49633-152">A query variable may store a query that is expressed in query syntax or method syntax, or a combination of the two.</span></span> <span data-ttu-id="49633-153">En los ejemplos siguientes, `queryMajorCities` y `queryMajorCities2` son variables de consulta:</span><span class="sxs-lookup"><span data-stu-id="49633-153">In the following examples, both `queryMajorCities` and `queryMajorCities2` are query variables:</span></span>

[!code-csharp[csrefQueryExpBasics#50](~/samples/snippets/csharp/concepts/linq/query-expression-basics_6.cs)]

<span data-ttu-id="49633-154">Por otro lado, en los dos ejemplos siguientes se muestran variables que no son de consulta, a pesar de que se inicialicen con una consulta.</span><span class="sxs-lookup"><span data-stu-id="49633-154">On the other hand, the following two examples show variables that are not query variables even though each is initialized with a query.</span></span> <span data-ttu-id="49633-155">No son variables de consulta porque almacenan resultados:</span><span class="sxs-lookup"><span data-stu-id="49633-155">They are not query variables because they store results:</span></span>

[!code-csharp[csrefQueryExpBasics#51](~/samples/snippets/csharp/concepts/linq/query-expression-basics_7.cs)]

<span data-ttu-id="49633-156">Para obtener más información sobre las distintas formas de expresar consultas, vea [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md) (Sintaxis de consulta y sintaxis de método en LINQ).</span><span class="sxs-lookup"><span data-stu-id="49633-156">For more information about the different ways to express queries, see [Query syntax and method syntax in LINQ](../programming-guide/concepts/linq/query-syntax-and-method-syntax-in-linq.md).</span></span>

#### <a name="explicit-and-implicit-typing-of-query-variables"></a><span data-ttu-id="49633-157">Asignación implícita y explícita de tipos de variables de consulta</span><span class="sxs-lookup"><span data-stu-id="49633-157">Explicit and implicit typing of query variables</span></span>

<span data-ttu-id="49633-158">En esta documentación se suele proporcionar el tipo explícito de la variable de consulta para mostrar las relaciones de tipo entre la variable de consulta y la [cláusula select](../language-reference/keywords/select-clause.md).</span><span class="sxs-lookup"><span data-stu-id="49633-158">This documentation usually provides the explicit type of the query variable in order to show the type relationship between the query variable and the [select clause](../language-reference/keywords/select-clause.md).</span></span> <span data-ttu-id="49633-159">Pero también se puede usar la palabra clave [var](../language-reference/keywords/var.md) para indicarle al compilador que infiera el tipo de una variable de consulta (u otra variable local) en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="49633-159">However, you can also use the [var](../language-reference/keywords/var.md) keyword to instruct the compiler to infer the type of a query variable (or any other local variable) at compile time.</span></span> <span data-ttu-id="49633-160">Por ejemplo, la consulta de ejemplo que se mostró anteriormente en este tema también se puede expresar mediante la asignación implícita de tipos:</span><span class="sxs-lookup"><span data-stu-id="49633-160">For example, the query example that was shown previously in this topic can also be expressed by using implicit typing:</span></span>

[!code-csharp[csrefQueryExpBasics#52](~/samples/snippets/csharp/concepts/linq/query-expression-basics_8.cs)]

<span data-ttu-id="49633-161">Para obtener más información, vea [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) (Variables locales con asignación implícita de tipos) y [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md) (Relaciones entre tipos en las operaciones de consulta de LINQ).</span><span class="sxs-lookup"><span data-stu-id="49633-161">For more information, see [Implicitly typed local variables](../programming-guide/classes-and-structs/implicitly-typed-local-variables.md) and [Type relationships in LINQ query operations](../programming-guide/concepts/linq/type-relationships-in-linq-query-operations.md).</span></span>

### <a name="starting-a-query-expression"></a><span data-ttu-id="49633-162">Iniciar una expresión de consulta</span><span class="sxs-lookup"><span data-stu-id="49633-162">Starting a query expression</span></span>

<span data-ttu-id="49633-163">Una expresión de consulta debe comenzar con una cláusula `from`,</span><span class="sxs-lookup"><span data-stu-id="49633-163">A query expression must begin with a `from` clause.</span></span> <span data-ttu-id="49633-164">que especifica un origen de datos junto con una variable de rango.</span><span class="sxs-lookup"><span data-stu-id="49633-164">It specifies a data source together with a range variable.</span></span> <span data-ttu-id="49633-165">La variable de rango representa cada elemento sucesivo de la secuencia de origen a medida que esta se recorre.</span><span class="sxs-lookup"><span data-stu-id="49633-165">The range variable represents each successive element in the source sequence as the source sequence is being traversed.</span></span> <span data-ttu-id="49633-166">La variable de rango está fuertemente tipada en función del tipo de elementos del origen de datos.</span><span class="sxs-lookup"><span data-stu-id="49633-166">The range variable is strongly typed based on the type of elements in the data source.</span></span> <span data-ttu-id="49633-167">En el ejemplo siguiente, como `countries` es una matriz de objetos `Country`, la variable de rango también está tipada como `Country`.</span><span class="sxs-lookup"><span data-stu-id="49633-167">In the following example, because `countries` is an array of `Country` objects, the range variable is also typed as `Country`.</span></span> <span data-ttu-id="49633-168">Dado que la variable de rango está fuertemente tipada, se puede usar el operador punto para tener acceso a cualquier miembro disponible del tipo.</span><span class="sxs-lookup"><span data-stu-id="49633-168">Because the range variable is strongly typed, you can use the dot operator to access any available members of the type.</span></span>

[!code-csharp[csrefQueryExpBasics#53](~/samples/snippets/csharp/concepts/linq/query-expression-basics_9.cs)]

<span data-ttu-id="49633-169">La variable de rango está en el ámbito hasta que se cierra la consulta con un punto y coma o con una cláusula de *continuación*.</span><span class="sxs-lookup"><span data-stu-id="49633-169">The range variable is in scope until the query is exited either with a semicolon or with a *continuation* clause.</span></span>

<span data-ttu-id="49633-170">Una expresión de consulta puede contener varias cláusulas `from`.</span><span class="sxs-lookup"><span data-stu-id="49633-170">A query expression may contain multiple `from` clauses.</span></span> <span data-ttu-id="49633-171">Use más cláusulas `from` cuando cada elemento de la secuencia de origen sea una colección en sí mismo o contenga una colección.</span><span class="sxs-lookup"><span data-stu-id="49633-171">Use additional `from` clauses when each element in the source sequence is itself a collection or contains a collection.</span></span> <span data-ttu-id="49633-172">Por ejemplo, supongamos que tiene una colección de objetos `Country`, cada uno de los cuales contiene una colección de objetos `City` denominados `Cities`.</span><span class="sxs-lookup"><span data-stu-id="49633-172">For example, assume that you have a collection of `Country` objects, each of which contains a collection of `City` objects named `Cities`.</span></span> <span data-ttu-id="49633-173">Para consultar los objetos `City` de cada `Country`, use dos cláusulas `from`, como se muestra aquí:</span><span class="sxs-lookup"><span data-stu-id="49633-173">To query the `City` objects in each `Country`, use two `from` clauses as shown here:</span></span>

[!code-csharp[csrefQueryExpBasics#54](~/samples/snippets/csharp/concepts/linq/query-expression-basics_10.cs)]

<span data-ttu-id="49633-174">Para obtener más información, vea [from clause](../language-reference/keywords/from-clause.md) (Cláusula from).</span><span class="sxs-lookup"><span data-stu-id="49633-174">For more information, see [from clause](../language-reference/keywords/from-clause.md).</span></span>

### <a name="ending-a-query-expression"></a><span data-ttu-id="49633-175">Finalizar una expresión de consulta</span><span class="sxs-lookup"><span data-stu-id="49633-175">Ending a query expression</span></span>

<span data-ttu-id="49633-176">Una expresión de consulta debe finalizar con una cláusula `group` o `select`.</span><span class="sxs-lookup"><span data-stu-id="49633-176">A query expression must end with either a `group` clause or a `select` clause.</span></span>

#### <a name="group-clause"></a><span data-ttu-id="49633-177">group (cláusula)</span><span class="sxs-lookup"><span data-stu-id="49633-177">group clause</span></span>

<span data-ttu-id="49633-178">Use la cláusula `group` para generar una secuencia de grupos organizados por la clave que especifique.</span><span class="sxs-lookup"><span data-stu-id="49633-178">Use the `group` clause to produce a sequence of groups organized by a key that you specify.</span></span> <span data-ttu-id="49633-179">La clave puede ser cualquier tipo de datos.</span><span class="sxs-lookup"><span data-stu-id="49633-179">The key can be any data type.</span></span> <span data-ttu-id="49633-180">Por ejemplo, la siguiente consulta crea una secuencia de grupos que contienen uno o más objetos `Country` y cuya clave es un valor `char`.</span><span class="sxs-lookup"><span data-stu-id="49633-180">For example, the following query creates a sequence of groups that contains one or more `Country` objects and whose key is a `char` value.</span></span>

[!code-csharp[csrefQueryExpBasics#55](~/samples/snippets/csharp/concepts/linq/query-expression-basics_11.cs)]

<span data-ttu-id="49633-181">Para obtener más información sobre la agrupación, vea [group clause](../language-reference/keywords/group-clause.md) (Cláusula group).</span><span class="sxs-lookup"><span data-stu-id="49633-181">For more information about grouping, see [group clause](../language-reference/keywords/group-clause.md).</span></span>

#### <a name="select-clause"></a><span data-ttu-id="49633-182">select (cláusula)</span><span class="sxs-lookup"><span data-stu-id="49633-182">select clause</span></span>

<span data-ttu-id="49633-183">Use la cláusula `select` para generar todos los demás tipos de secuencias.</span><span class="sxs-lookup"><span data-stu-id="49633-183">Use the `select` clause to produce all other types of sequences.</span></span> <span data-ttu-id="49633-184">Una cláusula `select` simple solo genera una secuencia del mismo tipo de objetos que los objetos contenidos en el origen de datos.</span><span class="sxs-lookup"><span data-stu-id="49633-184">A simple `select` clause just produces a sequence of the same type of objects as the objects that are contained in the data source.</span></span> <span data-ttu-id="49633-185">En este ejemplo, el origen de datos contiene objetos `Country`.</span><span class="sxs-lookup"><span data-stu-id="49633-185">In this example, the data source contains `Country` objects.</span></span> <span data-ttu-id="49633-186">La cláusula `orderby` simplemente ordena los elementos con un orden nuevo y la cláusula `select` genera una secuencia con los objetos `Country` reordenados.</span><span class="sxs-lookup"><span data-stu-id="49633-186">The `orderby` clause just sorts the elements into a new order and the `select` clause produces a sequence of the reordered `Country` objects.</span></span>

[!code-csharp[csrefQueryExpBasics#56](~/samples/snippets/csharp/concepts/linq/query-expression-basics_12.cs)]

<span data-ttu-id="49633-187">La cláusula `select` puede usarse para transformar los datos de origen en secuencias de nuevos tipos.</span><span class="sxs-lookup"><span data-stu-id="49633-187">The `select` clause can be used to transform source data into sequences of new types.</span></span> <span data-ttu-id="49633-188">Esta transformación también se denomina *proyección*.</span><span class="sxs-lookup"><span data-stu-id="49633-188">This transformation is also named a *projection*.</span></span> <span data-ttu-id="49633-189">En el ejemplo siguiente, la cláusula `select`*proyecta* una secuencia de tipos anónimos que solo contiene un subconjunto de los campos del elemento original.</span><span class="sxs-lookup"><span data-stu-id="49633-189">In the following example, the `select` clause *projects* a sequence of anonymous types which contains only a subset of the fields in the original element.</span></span> <span data-ttu-id="49633-190">Tenga en cuenta que los nuevos objetos se inicializan mediante un inicializador de objeto.</span><span class="sxs-lookup"><span data-stu-id="49633-190">Note that the new objects are initialized by using an object initializer.</span></span>

[!code-csharp[csrefQueryExpBasics#57](~/samples/snippets/csharp/concepts/linq/query-expression-basics_13.cs)]

<span data-ttu-id="49633-191">Para obtener más información sobre todas las formas en que se puede usar una cláusula `select` para transformar datos de origen, vea [select clause](../language-reference/keywords/select-clause.md) (Cláusula select).</span><span class="sxs-lookup"><span data-stu-id="49633-191">For more information about all the ways that a `select` clause can be used to transform source data, see [select clause](../language-reference/keywords/select-clause.md).</span></span>

#### <a name="continuations-with-into"></a><span data-ttu-id="49633-192">Continuaciones con "into"</span><span class="sxs-lookup"><span data-stu-id="49633-192">Continuations with "into"</span></span>

<span data-ttu-id="49633-193">Puede usar la palabra clave `into` en una cláusula `select` o `group` para crear un identificador temporal que almacene una consulta.</span><span class="sxs-lookup"><span data-stu-id="49633-193">You can use the `into` keyword in a `select` or `group` clause to create a temporary identifier that stores a query.</span></span> <span data-ttu-id="49633-194">Hágalo cuando deba realizar operaciones de consulta adicionales en una consulta después de una operación de agrupación o selección.</span><span class="sxs-lookup"><span data-stu-id="49633-194">Do this when you must perform additional query operations on a query after a grouping or select operation.</span></span> <span data-ttu-id="49633-195">En el siguiente ejemplo se agrupan los objetos `countries` según su población en intervalos de 10 millones.</span><span class="sxs-lookup"><span data-stu-id="49633-195">In the following example `countries` are grouped according to population in ranges of 10 million.</span></span> <span data-ttu-id="49633-196">Una vez que se han creado estos grupos, las cláusulas adicionales filtran algunos grupos y, después, ordenan los grupos en orden ascendente.</span><span class="sxs-lookup"><span data-stu-id="49633-196">After these groups are created, additional clauses filter out some groups, and then to sort the groups in ascending order.</span></span> <span data-ttu-id="49633-197">Para realizar esas operaciones adicionales, es necesaria la continuación representada por `countryGroup`.</span><span class="sxs-lookup"><span data-stu-id="49633-197">To perform those additional operations, the continuation represented by `countryGroup` is required.</span></span>

[!code-csharp[csrefQueryExpBasics#58](~/samples/snippets/csharp/concepts/linq/query-expression-basics_14.cs)]

<span data-ttu-id="49633-198">Para obtener más información, vea [into](../language-reference/keywords/into.md).</span><span class="sxs-lookup"><span data-stu-id="49633-198">For more information, see [into](../language-reference/keywords/into.md).</span></span>

### <a name="filtering-ordering-and-joining"></a><span data-ttu-id="49633-199">Filtrar, ordenar y combinar</span><span class="sxs-lookup"><span data-stu-id="49633-199">Filtering, ordering, and joining</span></span>

<span data-ttu-id="49633-200">Entre la cláusula de inicio `from` y la cláusula de finalización `select` o `group`, todas las demás cláusulas (`where`, `join`, `orderby`, `from`, `let`) son opcionales.</span><span class="sxs-lookup"><span data-stu-id="49633-200">Between the starting `from` clause, and the ending `select` or `group` clause, all other clauses (`where`, `join`, `orderby`, `from`, `let`) are optional.</span></span> <span data-ttu-id="49633-201">Cualquiera de las cláusulas opcionales puede usarse cero o varias veces en el cuerpo de una consulta.</span><span class="sxs-lookup"><span data-stu-id="49633-201">Any of the optional clauses may be used zero times or multiple times in a query body.</span></span>

#### <a name="where-clause"></a><span data-ttu-id="49633-202">where (cláusula)</span><span class="sxs-lookup"><span data-stu-id="49633-202">where clause</span></span>

<span data-ttu-id="49633-203">Use la cláusula `where` para filtrar los elementos de los datos de origen en función de una o varias expresiones de predicado.</span><span class="sxs-lookup"><span data-stu-id="49633-203">Use the `where` clause to filter out elements from the source data based on one or more predicate expressions.</span></span> <span data-ttu-id="49633-204">La cláusula `where` del ejemplo siguiente tiene un predicado con dos condiciones.</span><span class="sxs-lookup"><span data-stu-id="49633-204">The `where` clause in the following example has one predicate with two conditions.</span></span>

[!code-csharp[csrefQueryExpBasics#59](~/samples/snippets/csharp/concepts/linq/query-expression-basics_15.cs)]

<span data-ttu-id="49633-205">Para obtener más información, vea [where (Cláusula)](../language-reference/keywords/where-clause.md).</span><span class="sxs-lookup"><span data-stu-id="49633-205">For more information, see [where clause](../language-reference/keywords/where-clause.md).</span></span>

#### <a name="orderby-clause"></a><span data-ttu-id="49633-206">orderby (cláusula)</span><span class="sxs-lookup"><span data-stu-id="49633-206">orderby clause</span></span>

<span data-ttu-id="49633-207">Use la cláusula `orderby` para ordenar los resultados en orden ascendente o descendente.</span><span class="sxs-lookup"><span data-stu-id="49633-207">Use the `orderby` clause to sort the results in either ascending or descending order.</span></span> <span data-ttu-id="49633-208">También puede especificar criterios de ordenación secundaria.</span><span class="sxs-lookup"><span data-stu-id="49633-208">You can also specify secondary sort orders.</span></span> <span data-ttu-id="49633-209">En el ejemplo siguiente se realiza una ordenación primaria de los objetos `country` mediante la propiedad `Area`.</span><span class="sxs-lookup"><span data-stu-id="49633-209">The following example performs a primary sort on the `country` objects by using the `Area` property.</span></span> <span data-ttu-id="49633-210">Después, se realiza una ordenación secundaria mediante la propiedad `Population`.</span><span class="sxs-lookup"><span data-stu-id="49633-210">It then performs a secondary sort by using the `Population` property.</span></span>

[!code-csharp[csrefQueryExpBasics#60](~/samples/snippets/csharp/concepts/linq/query-expression-basics_16.cs)]

<span data-ttu-id="49633-211">La palabra clave `ascending` es opcional; es el criterio de ordenación predeterminado si no se especifica ningún orden.</span><span class="sxs-lookup"><span data-stu-id="49633-211">The `ascending` keyword is optional; it is the default sort order if no order is specified.</span></span> <span data-ttu-id="49633-212">Para obtener más información, vea [orderby (Cláusula)](../language-reference/keywords/orderby-clause.md).</span><span class="sxs-lookup"><span data-stu-id="49633-212">For more information, see [orderby clause](../language-reference/keywords/orderby-clause.md).</span></span>

#### <a name="join-clause"></a><span data-ttu-id="49633-213">join (cláusula)</span><span class="sxs-lookup"><span data-stu-id="49633-213">join clause</span></span>

<span data-ttu-id="49633-214">Use la cláusula `join` para asociar o combinar elementos de un origen de datos con elementos de otro origen de datos en función de una comparación de igualdad entre las claves especificadas en cada elemento.</span><span class="sxs-lookup"><span data-stu-id="49633-214">Use the `join` clause to associate and/or combine elements from one data source with elements from another data source based on an equality comparison between specified keys in each element.</span></span> <span data-ttu-id="49633-215">En LINQ, las operaciones de combinación se realizan en secuencias de objetos cuyos elementos son de tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="49633-215">In LINQ, join operations are performed on sequences of objects whose elements are different types.</span></span> <span data-ttu-id="49633-216">Después de combinar dos secuencias, debe usar una instrucción `select` o `group` para especificar qué elemento se va a almacenar en la secuencia de salida.</span><span class="sxs-lookup"><span data-stu-id="49633-216">After you have joined two sequences, you must use a `select` or `group` statement to specify which element to store in the output sequence.</span></span> <span data-ttu-id="49633-217">También puede usar un tipo anónimo para combinar propiedades de cada conjunto de elementos asociados en un nuevo tipo para la secuencia de salida.</span><span class="sxs-lookup"><span data-stu-id="49633-217">You can also use an anonymous type to combine properties from each set of associated elements into a new type for the output sequence.</span></span> <span data-ttu-id="49633-218">En el ejemplo siguiente se asocian objetos `prod` cuya propiedad `Category` coincide con una de las categorías de la matriz de cadenas `categories`.</span><span class="sxs-lookup"><span data-stu-id="49633-218">The following example associates `prod` objects whose `Category` property matches one of the categories in the `categories` string array.</span></span> <span data-ttu-id="49633-219">Los productos cuya propiedad `Category` no coincide con ninguna cadena de `categories` se filtran. La instrucción `select` proyecta un nuevo tipo cuyas propiedades se toman de `cat` y `prod`.</span><span class="sxs-lookup"><span data-stu-id="49633-219">Products whose `Category` does not match any string in `categories` are filtered out. The `select` statement projects a new type whose properties are taken from both `cat` and `prod`.</span></span>

[!code-csharp[csrefQueryExpBasics#61](~/samples/snippets/csharp/concepts/linq/query-expression-basics_17.cs)]

<span data-ttu-id="49633-220">También puede realizar una combinación agrupada. Para ello, almacene los resultados de la operación `join` en una variable temporal mediante el uso de la palabra clave [into](../language-reference/keywords/into.md).</span><span class="sxs-lookup"><span data-stu-id="49633-220">You can also perform a group join by storing the results of the `join` operation into a temporary variable by using the [into](../language-reference/keywords/into.md) keyword.</span></span> <span data-ttu-id="49633-221">Para obtener más información, vea [join (Cláusula, Referencia de C#)](../language-reference/keywords/join-clause.md).</span><span class="sxs-lookup"><span data-stu-id="49633-221">For more information, see [join clause](../language-reference/keywords/join-clause.md).</span></span>

#### <a name="let-clause"></a><span data-ttu-id="49633-222">let (cláusula)</span><span class="sxs-lookup"><span data-stu-id="49633-222">let clause</span></span>

<span data-ttu-id="49633-223">Use la cláusula `let` para almacenar el resultado de una expresión, como una llamada de método, en una nueva variable de rango.</span><span class="sxs-lookup"><span data-stu-id="49633-223">Use the `let` clause to store the result of an expression, such as a method call, in a new range variable.</span></span> <span data-ttu-id="49633-224">En el ejemplo siguiente, la variable de rango `firstName` almacena el primer elemento de la matriz de cadenas devuelta por `Split`.</span><span class="sxs-lookup"><span data-stu-id="49633-224">In the following example, the range variable `firstName` stores the first element of the array of strings that is returned by `Split`.</span></span>

[!code-csharp[csrefQueryExpBasics#62](~/samples/snippets/csharp/concepts/linq/query-expression-basics_18.cs)]

<span data-ttu-id="49633-225">Para obtener más información, vea [let (Cláusula)](../language-reference/keywords/let-clause.md).</span><span class="sxs-lookup"><span data-stu-id="49633-225">For more information, see [let clause](../language-reference/keywords/let-clause.md).</span></span>

### <a name="subqueries-in-a-query-expression"></a><span data-ttu-id="49633-226">Subconsultas en una expresión de consulta</span><span class="sxs-lookup"><span data-stu-id="49633-226">Subqueries in a query expression</span></span>

<span data-ttu-id="49633-227">Una cláusula de consulta puede contener una expresión de consulta, en ocasiones denominada *subconsulta*.</span><span class="sxs-lookup"><span data-stu-id="49633-227">A query clause may itself contain a query expression, which is sometimes referred to as a *subquery*.</span></span> <span data-ttu-id="49633-228">Cada subconsulta comienza con su propia cláusula `from` que no necesariamente hace referencia al mismo origen de datos de la primera cláusula `from`.</span><span class="sxs-lookup"><span data-stu-id="49633-228">Each subquery starts with its own `from` clause that does not necessarily point to the same data source in the first `from` clause.</span></span> <span data-ttu-id="49633-229">Por ejemplo, la consulta siguiente muestra una expresión de consulta que se usa en la instrucción select para recuperar los resultados de una operación de agrupación.</span><span class="sxs-lookup"><span data-stu-id="49633-229">For example, the following query shows a query expression that is used in the select statement to retrieve the results of a grouping operation.</span></span>

[!code-csharp[csrefQueryExpBasics#63](~/samples/snippets/csharp/concepts/linq/query-expression-basics_19.cs)]

<span data-ttu-id="49633-230">Para más información, consulte [Realizar una subconsulta en una operación de agrupación](perform-a-subquery-on-a-grouping-operation.md).</span><span class="sxs-lookup"><span data-stu-id="49633-230">For more information, see [Perform a subquery on a grouping operation](perform-a-subquery-on-a-grouping-operation.md).</span></span>

## <a name="see-also"></a><span data-ttu-id="49633-231">Vea también</span><span class="sxs-lookup"><span data-stu-id="49633-231">See also</span></span>

- [<span data-ttu-id="49633-232">Guía de programación de C#</span><span class="sxs-lookup"><span data-stu-id="49633-232">C# programming guide</span></span>](../programming-guide/index.md)
- [<span data-ttu-id="49633-233">Language-Integrated Query (LINQ)</span><span class="sxs-lookup"><span data-stu-id="49633-233">Language Integrated Query (LINQ)</span></span>](index.md)
- [<span data-ttu-id="49633-234">Palabras clave de consultas (LINQ)</span><span class="sxs-lookup"><span data-stu-id="49633-234">Query keywords (LINQ)</span></span>](../language-reference/keywords/query-keywords.md)
- [<span data-ttu-id="49633-235">Información general sobre operadores de consulta estándar</span><span class="sxs-lookup"><span data-stu-id="49633-235">Standard query operators overview</span></span>](../programming-guide/concepts/linq/standard-query-operators-overview.md)
