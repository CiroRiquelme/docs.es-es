---
title: Arquitectura
ms.date: 03/30/2017
helpviewer_keywords:
- properties [WPF], attached
- attached properties [WPF]
- architecture [WPF]
- unmanaged components [WPF]
- affinity thread [WPF]
- Storyboards [WPF]
- milcore [WPF]
- components [WPF], unmanaged
- painter's algorithm
- interfaces [WPF], INotifyPropertyChange
- CommandBindings [WPF]
- data templates [WPF]
- thread [WPF], affinity
ms.assetid: 8579c10b-76ab-4c52-9691-195ce02333c8
ms.openlocfilehash: 6d8dedafd4ffc582b529289d3583f90d81779762
ms.sourcegitcommit: 13e79efdbd589cad6b1de634f5d6b1262b12ab01
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/28/2020
ms.locfileid: "76794033"
---
# <a name="wpf-architecture"></a><span data-ttu-id="d91e6-102">Arquitectura de WPF</span><span class="sxs-lookup"><span data-stu-id="d91e6-102">WPF Architecture</span></span>
<span data-ttu-id="d91e6-103">En este tema se proporciona un paseo guiado por la jerarquía de clases de Windows Presentation Foundation (WPF).</span><span class="sxs-lookup"><span data-stu-id="d91e6-103">This topic provides a guided tour of the Windows Presentation Foundation (WPF) class hierarchy.</span></span> <span data-ttu-id="d91e6-104">Abarca la mayoría de los subsistemas principales de WPF y describe cómo interactúan.</span><span class="sxs-lookup"><span data-stu-id="d91e6-104">It covers most of the major subsystems of WPF, and describes how they interact.</span></span> <span data-ttu-id="d91e6-105">También se detallan algunas de las opciones realizadas por los arquitectos de WPF.</span><span class="sxs-lookup"><span data-stu-id="d91e6-105">It also details some of the choices made by the architects of WPF.</span></span>  

<a name="System_Object"></a>   
## <a name="systemobject"></a><span data-ttu-id="d91e6-106">System.Object</span><span class="sxs-lookup"><span data-stu-id="d91e6-106">System.Object</span></span>  
 <span data-ttu-id="d91e6-107">El modelo de programación de WPF principal se expone a través del código administrado.</span><span class="sxs-lookup"><span data-stu-id="d91e6-107">The primary WPF programming model is exposed through managed code.</span></span> <span data-ttu-id="d91e6-108">Al principio de la fase de diseño de WPF, había una serie de debates sobre dónde se debe dibujar la línea entre los componentes administrados del sistema y los no administrados.</span><span class="sxs-lookup"><span data-stu-id="d91e6-108">Early in the design phase of WPF there were a number of debates about where the line should be drawn between the managed components of the system and the unmanaged ones.</span></span> <span data-ttu-id="d91e6-109">CLR proporciona una serie de características que hacen que el desarrollo sea más productivo y robusto (incluida la administración de la memoria, el control de errores, el sistema de tipos común, etc.), pero tienen un costo.</span><span class="sxs-lookup"><span data-stu-id="d91e6-109">The CLR provides a number of features that make development more productive and robust (including memory management, error handling, common type system, etc.) but they come at a cost.</span></span>  
  
 <span data-ttu-id="d91e6-110">Los componentes principales de WPF se muestran en la ilustración siguiente.</span><span class="sxs-lookup"><span data-stu-id="d91e6-110">The major components of WPF are illustrated in the figure below.</span></span> <span data-ttu-id="d91e6-111">Las secciones rojas del diagrama (PresentationFramework, PresentationCore y Milcore) son las partes principales del código de WPF.</span><span class="sxs-lookup"><span data-stu-id="d91e6-111">The red sections of the diagram (PresentationFramework, PresentationCore, and milcore) are the major code portions of WPF.</span></span> <span data-ttu-id="d91e6-112">De estos, solo uno es un componente no administrado: Milcore.</span><span class="sxs-lookup"><span data-stu-id="d91e6-112">Of these, only one is an unmanaged component – milcore.</span></span> <span data-ttu-id="d91e6-113">Milcore está escrito en código no administrado con el fin de permitir una estrecha integración con DirectX.</span><span class="sxs-lookup"><span data-stu-id="d91e6-113">Milcore is written in unmanaged code in order to enable tight integration with DirectX.</span></span> <span data-ttu-id="d91e6-114">Todas las pantallas en WPF se realizan a través del motor de DirectX, lo que permite una eficaz representación de software y hardware.</span><span class="sxs-lookup"><span data-stu-id="d91e6-114">All display in WPF is done through the DirectX engine, allowing for efficient hardware and software rendering.</span></span> <span data-ttu-id="d91e6-115">WPF también requiere un control preciso sobre la memoria y la ejecución.</span><span class="sxs-lookup"><span data-stu-id="d91e6-115">WPF also required fine control over memory and execution.</span></span> <span data-ttu-id="d91e6-116">El motor de composición de Milcore es sumamente sensible al rendimiento y se requiere que se ofrezcan muchas ventajas de CLR para obtener un rendimiento.</span><span class="sxs-lookup"><span data-stu-id="d91e6-116">The composition engine in milcore is extremely performance sensitive, and required giving up many advantages of the CLR to gain performance.</span></span>  
  
 <span data-ttu-id="d91e6-117">![Posición de WPF en el .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span><span class="sxs-lookup"><span data-stu-id="d91e6-117">![The position of WPF within the .NET Framework.](./media/wpf-architect1.PNG "wpf_architect1")</span></span>  
  
 <span data-ttu-id="d91e6-118">La comunicación entre las partes administradas y no administradas de WPF se describe más adelante en este tema.</span><span class="sxs-lookup"><span data-stu-id="d91e6-118">Communication between the managed and unmanaged portions of WPF is discussed later in this topic.</span></span> <span data-ttu-id="d91e6-119">A continuación se describe el resto del modelo de programación administrado.</span><span class="sxs-lookup"><span data-stu-id="d91e6-119">The remainder of the managed programming model is described below.</span></span>  
  
<a name="System_Threading_DispatcherObject"></a>   
## <a name="systemthreadingdispatcherobject"></a><span data-ttu-id="d91e6-120">System.Threading.DispatcherObject</span><span class="sxs-lookup"><span data-stu-id="d91e6-120">System.Threading.DispatcherObject</span></span>  
 <span data-ttu-id="d91e6-121">La mayoría de los objetos de WPF se derivan de <xref:System.Windows.Threading.DispatcherObject>, que proporciona las construcciones básicas para tratar la simultaneidad y el subprocesamiento.</span><span class="sxs-lookup"><span data-stu-id="d91e6-121">Most objects in WPF derive from <xref:System.Windows.Threading.DispatcherObject>, which provides the basic constructs for dealing with concurrency and threading.</span></span> <span data-ttu-id="d91e6-122">WPF se basa en un sistema de mensajería implementado por el distribuidor.</span><span class="sxs-lookup"><span data-stu-id="d91e6-122">WPF is based on a messaging system implemented by the dispatcher.</span></span> <span data-ttu-id="d91e6-123">Esto funciona de forma muy similar al conocido bombeo de mensajes Win32; de hecho, el distribuidor de WPF usa mensajes User32 para realizar llamadas entre subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-123">This works much like the familiar Win32 message pump; in fact, the WPF dispatcher uses User32 messages for performing cross thread calls.</span></span>  
  
 <span data-ttu-id="d91e6-124">En realidad hay dos conceptos básicos que se deben comprender al hablar de la simultaneidad en WPF: el distribuidor y la afinidad de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-124">There are really two core concepts to understand when discussing concurrency in WPF – the dispatcher and thread affinity.</span></span>  
  
 <span data-ttu-id="d91e6-125">Durante la fase de diseño de WPF, el objetivo era pasar a un único subproceso de ejecución, pero a un modelo "afinidad con" que no es de subproceso.</span><span class="sxs-lookup"><span data-stu-id="d91e6-125">During the design phase of WPF, the goal was to move to a single thread of execution, but a non-thread "affinitized" model.</span></span> <span data-ttu-id="d91e6-126">La afinidad de subprocesos se produce cuando un componente usa la identidad del subproceso que se está ejecutando para almacenar algún tipo de estado.</span><span class="sxs-lookup"><span data-stu-id="d91e6-126">Thread affinity happens when a component uses the identity of the executing thread to store some type of state.</span></span> <span data-ttu-id="d91e6-127">La forma más común de esta afinidad es usar el almacenamiento local de subprocesos (TLS) para almacenar el estado.</span><span class="sxs-lookup"><span data-stu-id="d91e6-127">The most common form of this is to use the thread local store (TLS) to store state.</span></span> <span data-ttu-id="d91e6-128">La afinidad de subprocesos requiere que cada subproceso lógico de ejecución sea propiedad de un único subproceso físico en el sistema operativo, lo que puede consumir mucha memoria.</span><span class="sxs-lookup"><span data-stu-id="d91e6-128">Thread affinity requires that each logical thread of execution be owned by only one physical thread in the operating system, which can become memory intensive.</span></span> <span data-ttu-id="d91e6-129">Finalmente, el modelo de subprocesos de WPF se mantuvo sincronizado con el modelo de subprocesos de User32 existente, que consiste en la ejecución de un solo subproceso con afinidad de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-129">In the end, WPF’s threading model was kept in sync with the existing User32 threading model of single threaded execution with thread affinity.</span></span> <span data-ttu-id="d91e6-130">La razón principal para esto era la interoperabilidad: los sistemas como OLE 2,0, el portapapeles e Internet Explorer requieren la ejecución de afinidad de subproceso único (STA).</span><span class="sxs-lookup"><span data-stu-id="d91e6-130">The primary reason for this was interoperability – systems like OLE 2.0, the clipboard, and Internet Explorer all require single thread affinity (STA) execution.</span></span>  
  
 <span data-ttu-id="d91e6-131">Dado que disponemos de objetos con subprocesos STA, necesitamos un medio de comunicación entre subprocesos y estar seguros de que nos encontramos en el subproceso correcto.</span><span class="sxs-lookup"><span data-stu-id="d91e6-131">Given that you have objects with STA threading, you need a way to communicate between threads, and validate that you are on the correct thread.</span></span> <span data-ttu-id="d91e6-132">A continuación se describe el rol del distribuidor.</span><span class="sxs-lookup"><span data-stu-id="d91e6-132">Herein lies the role of the dispatcher.</span></span> <span data-ttu-id="d91e6-133">El distribuidor es un sistema de envío de mensajes básico que dispone de varias colas con prioridad.</span><span class="sxs-lookup"><span data-stu-id="d91e6-133">The dispatcher is a basic message dispatching system, with multiple prioritized queues.</span></span> <span data-ttu-id="d91e6-134">Por ejemplo, son mensajes las notificaciones de entrada sin formato (el mouse se ha movido), las funciones de marco de trabajo (diseño) o los comandos de usuario (ejecutar este método).</span><span class="sxs-lookup"><span data-stu-id="d91e6-134">Examples of messages include raw input notifications (mouse moved), framework functions (layout), or user commands (execute this method).</span></span> <span data-ttu-id="d91e6-135">Al derivar de <xref:System.Windows.Threading.DispatcherObject>, se crea un objeto CLR que tiene un comportamiento STA y se le proporcionará un puntero a un distribuidor en el momento de la creación.</span><span class="sxs-lookup"><span data-stu-id="d91e6-135">By deriving from <xref:System.Windows.Threading.DispatcherObject>, you create a CLR object that has STA behavior, and will be given a pointer to a dispatcher at creation time.</span></span>  
  
<a name="System_Windows_DependencyObject"></a>   
## <a name="systemwindowsdependencyobject"></a><span data-ttu-id="d91e6-136">System.Windows.DependencyObject</span><span class="sxs-lookup"><span data-stu-id="d91e6-136">System.Windows.DependencyObject</span></span>  
 <span data-ttu-id="d91e6-137">Una de las principales filosofías arquitectónicas que se usan para compilar WPF era una preferencia para las propiedades de métodos o eventos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-137">One of the primary architectural philosophies used in building WPF was a preference for properties over methods or events.</span></span> <span data-ttu-id="d91e6-138">Las propiedades son declarativas y le permiten especificar más fácilmente la intención en lugar de la acción.</span><span class="sxs-lookup"><span data-stu-id="d91e6-138">Properties are declarative and allow you to more easily specify intent instead of action.</span></span> <span data-ttu-id="d91e6-139">Esto también ha permitido el uso de un sistema basado en modelos, o en datos, para mostrar el contenido de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="d91e6-139">This also supported a model driven, or data driven, system for displaying user interface content.</span></span> <span data-ttu-id="d91e6-140">Esta filosofía tenía como objetivo crear más propiedades con las que poder enlazar, y así tener un mejor control del comportamiento de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="d91e6-140">This philosophy had the intended effect of creating more properties that you could bind to, in order to better control the behavior of an application.</span></span>  
  
 <span data-ttu-id="d91e6-141">Para que el sistema sea más controlado por las propiedades, se necesitaba un sistema de propiedades más completo que el que proporciona el CLR.</span><span class="sxs-lookup"><span data-stu-id="d91e6-141">In order to have more of the system driven by properties, a richer property system than what the CLR provides was needed.</span></span> <span data-ttu-id="d91e6-142">Un ejemplo sencillo de esto son las notificaciones de cambios.</span><span class="sxs-lookup"><span data-stu-id="d91e6-142">A simple example of this richness is change notifications.</span></span> <span data-ttu-id="d91e6-143">Para poder habilitar los enlaces bidireccionales, será necesario que ambos lados del enlace admitan la notificación de cambios.</span><span class="sxs-lookup"><span data-stu-id="d91e6-143">In order to enable two way binding, you need both sides of the bind to support change notification.</span></span> <span data-ttu-id="d91e6-144">Para poder tener el comportamiento vinculado a los valores de propiedad, deberá recibir una notificación cuando cambie el valor de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="d91e6-144">In order to have behavior tied to property values, you need to be notified when the property value changes.</span></span> <span data-ttu-id="d91e6-145">El marco de Microsoft .NET tiene una interfaz, **INotifyPropertyChange**, que permite a un objeto publicar notificaciones de cambios, pero es opcional.</span><span class="sxs-lookup"><span data-stu-id="d91e6-145">The Microsoft .NET Framework has an interface, **INotifyPropertyChange**, which allows an object to publish change notifications, however it is optional.</span></span>  
  
 <span data-ttu-id="d91e6-146">WPF proporciona un sistema de propiedades más completo, derivado del tipo <xref:System.Windows.DependencyObject>.</span><span class="sxs-lookup"><span data-stu-id="d91e6-146">WPF provides a richer property system, derived from the <xref:System.Windows.DependencyObject> type.</span></span> <span data-ttu-id="d91e6-147">El sistema de propiedades puede considerarse un sistema de "dependencias" porque realiza el seguimiento de las dependencias entre las expresiones de las propiedades y vuelve a validar automáticamente los valores de propiedad cuando cambian las dependencias.</span><span class="sxs-lookup"><span data-stu-id="d91e6-147">The property system is truly a "dependency" property system in that it tracks dependencies between property expressions and automatically revalidates property values when dependencies change.</span></span> <span data-ttu-id="d91e6-148">Por ejemplo, si tiene una propiedad que hereda (como <xref:System.Windows.Controls.Control.FontSize%2A>), el sistema se actualiza automáticamente si la propiedad cambia en un elemento primario de un elemento que hereda el valor.</span><span class="sxs-lookup"><span data-stu-id="d91e6-148">For example, if you have a property that inherits (like <xref:System.Windows.Controls.Control.FontSize%2A>), the system is automatically updated if the property changes on a parent of an element that inherits the value.</span></span>  
  
 <span data-ttu-id="d91e6-149">La base del sistema de propiedades de WPF es el concepto de una expresión de propiedad.</span><span class="sxs-lookup"><span data-stu-id="d91e6-149">The foundation of the WPF property system is the concept of a property expression.</span></span> <span data-ttu-id="d91e6-150">En esta primera versión de WPF, el sistema de expresión de propiedad está cerrado y todas las expresiones se proporcionan como parte del marco de trabajo.</span><span class="sxs-lookup"><span data-stu-id="d91e6-150">In this first release of WPF, the property expression system is closed, and the expressions are all provided as part of the framework.</span></span> <span data-ttu-id="d91e6-151">Las expresiones son el motivo de que el sistema de propiedades no tenga características de enlace de datos, de estilo o de herencia incluidas en el código, sino que son proporcionadas por capas posteriores dentro del marco de trabajo.</span><span class="sxs-lookup"><span data-stu-id="d91e6-151">Expressions are why the property system doesn’t have data binding, styling, or inheritance hard coded, but rather provided by later layers within the framework.</span></span>  
  
 <span data-ttu-id="d91e6-152">El sistema de propiedades también proporciona almacenamiento disperso de valores de propiedades.</span><span class="sxs-lookup"><span data-stu-id="d91e6-152">The property system also provides for sparse storage of property values.</span></span> <span data-ttu-id="d91e6-153">Debido a que los objetos pueden tener docenas (o incluso cientos) de propiedades, y la mayoría de los valores está en su estado predeterminado (heredado, establecido por estilos, etc.), no todas las instancias de un objeto necesitan tener definidas todas las propiedades.</span><span class="sxs-lookup"><span data-stu-id="d91e6-153">Because objects can have dozens (if not hundreds) of properties, and most of the values are in their default state (inherited, set by styles, etc.), not every instance of an object needs to have the full weight of every property defined on it.</span></span>  
  
 <span data-ttu-id="d91e6-154">La última de las características nuevas del sistema de propiedades es el concepto de propiedades adjuntas.</span><span class="sxs-lookup"><span data-stu-id="d91e6-154">The final new feature of the property system is the notion of attached properties.</span></span> <span data-ttu-id="d91e6-155">Los elementos de WPF se basan en el principio de composición y reutilización de componentes.</span><span class="sxs-lookup"><span data-stu-id="d91e6-155">WPF elements are built on the principle of composition and component reuse.</span></span> <span data-ttu-id="d91e6-156">Suele ser el caso de que algún elemento contenedor (como un elemento de diseño <xref:System.Windows.Controls.Grid>) necesite datos adicionales en los elementos secundarios para controlar su comportamiento (por ejemplo, la información de fila o columna).</span><span class="sxs-lookup"><span data-stu-id="d91e6-156">It is often the case that some containing element (like a <xref:System.Windows.Controls.Grid> layout element) needs additional data on child elements to control its behavior (like the Row/Column information).</span></span> <span data-ttu-id="d91e6-157">En lugar de asociar todas estas propiedades a cada elemento, cualquier objeto puede proporcionar las definiciones de las propiedades para cualquier otro objeto.</span><span class="sxs-lookup"><span data-stu-id="d91e6-157">Instead of associating all of these properties with every element, any object is allowed to provide property definitions for any other object.</span></span> <span data-ttu-id="d91e6-158">Esto es similar a las características "expando" de JavaScript.</span><span class="sxs-lookup"><span data-stu-id="d91e6-158">This is similar to the "expando" features of JavaScript.</span></span>  
  
<a name="System_Windows_Media_Visual"></a>   
## <a name="systemwindowsmediavisual"></a><span data-ttu-id="d91e6-159">System.Windows.Media.Visual</span><span class="sxs-lookup"><span data-stu-id="d91e6-159">System.Windows.Media.Visual</span></span>  
 <span data-ttu-id="d91e6-160">Con un sistema ya definido, el paso siguiente consiste en conseguir que se dibujen los píxeles en la pantalla.</span><span class="sxs-lookup"><span data-stu-id="d91e6-160">With a system defined, the next step is getting pixels drawn to the screen.</span></span> <span data-ttu-id="d91e6-161">La clase <xref:System.Windows.Media.Visual> proporciona para compilar un árbol de objetos visuales, cada uno de los cuales puede contener instrucciones de dibujo y metadatos sobre cómo representar esas instrucciones (recorte, transformación, etc.).</span><span class="sxs-lookup"><span data-stu-id="d91e6-161">The <xref:System.Windows.Media.Visual> class provides for building a tree of visual objects, each optionally containing drawing instructions and metadata about how to render those instructions (clipping, transformation, etc.).</span></span> <span data-ttu-id="d91e6-162"><xref:System.Windows.Media.Visual> está diseñado para ser extremadamente ligero y flexible, por lo que la mayoría de las características no tienen exposición de API pública y dependen en gran medida de las funciones de devolución de llamada protegidas.</span><span class="sxs-lookup"><span data-stu-id="d91e6-162"><xref:System.Windows.Media.Visual> is designed to be extremely lightweight and flexible, so most of the features have no public API exposure and rely heavily on protected callback functions.</span></span>  
  
 <span data-ttu-id="d91e6-163"><xref:System.Windows.Media.Visual> es realmente el punto de entrada al sistema de composición de WPF.</span><span class="sxs-lookup"><span data-stu-id="d91e6-163"><xref:System.Windows.Media.Visual> is really the entry point to the WPF composition system.</span></span> <span data-ttu-id="d91e6-164"><xref:System.Windows.Media.Visual> es el punto de conexión entre estos dos subsistemas, la API administrada y la Milcore no administrada.</span><span class="sxs-lookup"><span data-stu-id="d91e6-164"><xref:System.Windows.Media.Visual> is the point of connection between these two subsystems, the managed API and the unmanaged milcore.</span></span>  
  
 <span data-ttu-id="d91e6-165">WPF muestra los datos recorriendo las estructuras de datos no administradas administradas por Milcore.</span><span class="sxs-lookup"><span data-stu-id="d91e6-165">WPF displays data by traversing the unmanaged data structures managed by the milcore.</span></span> <span data-ttu-id="d91e6-166">Estas estructuras, denominadas nodos de composición, representan un árbol de presentación jerárquica con instrucciones de representación en cada nodo.</span><span class="sxs-lookup"><span data-stu-id="d91e6-166">These structures, called composition nodes, represent a hierarchical display tree with rendering instructions at each node.</span></span> <span data-ttu-id="d91e6-167">Solo se puede tener acceso a este árbol, mostrado en el lado derecho de la ilustración siguiente, a través de un protocolo de mensajería.</span><span class="sxs-lookup"><span data-stu-id="d91e6-167">This tree, illustrated on the right hand side of the figure below, is only accessible through a messaging protocol.</span></span>  
  
 <span data-ttu-id="d91e6-168">Al programar WPF, se crean <xref:System.Windows.Media.Visual> elementos y los tipos derivados, que se comunican internamente con el árbol de composición a través de este protocolo de mensajería.</span><span class="sxs-lookup"><span data-stu-id="d91e6-168">When programming WPF, you create <xref:System.Windows.Media.Visual> elements, and derived types, which internally communicate to the composition tree through this messaging protocol.</span></span> <span data-ttu-id="d91e6-169">Cada <xref:System.Windows.Media.Visual> en WPF puede crear uno, ninguno o varios nodos de composición.</span><span class="sxs-lookup"><span data-stu-id="d91e6-169">Each <xref:System.Windows.Media.Visual> in WPF may create one, none, or several composition nodes.</span></span>  
  
 <span data-ttu-id="d91e6-170">![Árbol visual de Windows Presentation Foundation.](./media/wpf-architecture2.PNG "wpf_architecture2")</span><span class="sxs-lookup"><span data-stu-id="d91e6-170">![The Windows Presentation Foundation Visual Tree.](./media/wpf-architecture2.PNG "wpf_architecture2")</span></span>  
  
 <span data-ttu-id="d91e6-171">Hay que observar aquí un detalle arquitectónico muy importante, y es que el árbol completo de objetos visuales e instrucciones de dibujo se guarda en la memoria caché.</span><span class="sxs-lookup"><span data-stu-id="d91e6-171">There is a very important architectural detail to notice here – the entire tree of visuals and drawing instructions is cached.</span></span> <span data-ttu-id="d91e6-172">En términos de gráficos, WPF usa un sistema de representación retenido.</span><span class="sxs-lookup"><span data-stu-id="d91e6-172">In graphics terms, WPF uses a retained rendering system.</span></span> <span data-ttu-id="d91e6-173">Esto permite al sistema volver a dibujar con frecuencias de actualización altas sin que el sistema de composición bloquee las devoluciones de llamada al código del usuario.</span><span class="sxs-lookup"><span data-stu-id="d91e6-173">This enables the system to repaint at high refresh rates without the composition system blocking on callbacks to user code.</span></span> <span data-ttu-id="d91e6-174">Esto ayuda a evitar la sensación de que la aplicación no responde.</span><span class="sxs-lookup"><span data-stu-id="d91e6-174">This helps prevent the appearance of an unresponsive application.</span></span>  
  
 <span data-ttu-id="d91e6-175">Otro detalle importante que no es muy evidente en el diagrama es la forma en la que el sistema realiza realmente la composición.</span><span class="sxs-lookup"><span data-stu-id="d91e6-175">Another important detail that isn’t really noticeable in the diagram is how the system actually performs composition.</span></span>  
  
 <span data-ttu-id="d91e6-176">En user32 y GDI, el sistema funciona en un sistema de recorte de modo inmediato.</span><span class="sxs-lookup"><span data-stu-id="d91e6-176">In User32 and GDI, the system works on an immediate mode clipping system.</span></span> <span data-ttu-id="d91e6-177">Cuando es necesario representar un componente, el sistema establece un límite de recorte en cuyo exterior no permite al componente tocar los píxeles y, después, le pide que pinte los píxeles en ese cuadro.</span><span class="sxs-lookup"><span data-stu-id="d91e6-177">When a component needs to be rendered, the system establishes a clipping bounds outside of which the component isn’t allowed to touch the pixels, and then the component is asked to paint pixels in that box.</span></span> <span data-ttu-id="d91e6-178">Este método funciona muy bien en sistemas con restricciones de memoria, ya que cuando algo cambia solo se debe modificar el componente afectado; nunca hay dos componentes que afecten al color de un mismo píxel.</span><span class="sxs-lookup"><span data-stu-id="d91e6-178">This system works very well in memory constrained systems because when something changes you only have to touch the affected component – no two components ever contribute to the color of a single pixel.</span></span>  
  
 <span data-ttu-id="d91e6-179">WPF usa el modelo de dibujo "algoritmo de pintor".</span><span class="sxs-lookup"><span data-stu-id="d91e6-179">WPF uses a "painter's algorithm" painting model.</span></span> <span data-ttu-id="d91e6-180">Esto significa que, en lugar de recortar cada componente, se pide a este que efectúe la representación desde la parte trasera hacia la parte delantera de la imagen.</span><span class="sxs-lookup"><span data-stu-id="d91e6-180">This means that instead of clipping each component, each component is asked to render from the back to the front of the display.</span></span> <span data-ttu-id="d91e6-181">Esto permite a cada componente pintar sobre la imagen generada por el componente anterior.</span><span class="sxs-lookup"><span data-stu-id="d91e6-181">This allows each component to paint over the previous component's display.</span></span> <span data-ttu-id="d91e6-182">La ventaja de este modelo es que permite tener formas complejas parcialmente transparentes.</span><span class="sxs-lookup"><span data-stu-id="d91e6-182">The advantage of this model is that you can have complex, partially transparent shapes.</span></span> <span data-ttu-id="d91e6-183">Con el actual hardware de gráficos moderno, este modelo es relativamente rápido (que no es el caso cuando se crearon user32/GDI).</span><span class="sxs-lookup"><span data-stu-id="d91e6-183">With today’s modern graphics hardware, this model is relatively fast (which wasn’t the case when User32/ GDI were created).</span></span>  
  
 <span data-ttu-id="d91e6-184">Como se mencionó anteriormente, una filosofía principal de WPF es pasar a un modelo de programación más declarativo centrado en la propiedad.</span><span class="sxs-lookup"><span data-stu-id="d91e6-184">As mentioned previously, a core philosophy of WPF is to move to a more declarative, "property centric" model of programming.</span></span> <span data-ttu-id="d91e6-185">En el sistema visual, esto se pone de manifiesto en un par de lugares interesantes.</span><span class="sxs-lookup"><span data-stu-id="d91e6-185">In the visual system, this shows up in a couple of interesting places.</span></span>  
  
 <span data-ttu-id="d91e6-186">En primer lugar, si piensa en el sistema de gráficos de modo retenido, este se está alejando de un modelo de tipo DrawLine/DrawLine imperativo hacia un modelo orientado a datos, new Line()/new Line().</span><span class="sxs-lookup"><span data-stu-id="d91e6-186">First, if you think about the retained mode graphic system, this is really moving away from an imperative DrawLine/DrawLine type model, to a data oriented model – new Line()/new Line().</span></span> <span data-ttu-id="d91e6-187">Esta migración hacia la representación controlada por datos permite expresar operaciones complejas en las instrucciones de dibujo mediante propiedades.</span><span class="sxs-lookup"><span data-stu-id="d91e6-187">This move to data driven rendering allows complex operations on the drawing instructions to be expressed using properties.</span></span> <span data-ttu-id="d91e6-188">Los tipos que se derivan de <xref:System.Windows.Media.Drawing> son en realidad el modelo de objetos para la representación.</span><span class="sxs-lookup"><span data-stu-id="d91e6-188">The types deriving from <xref:System.Windows.Media.Drawing> are effectively the object model for rendering.</span></span>  
  
 <span data-ttu-id="d91e6-189">En segundo lugar, si evalúa el sistema de animación, verá que es declarativo casi por completo.</span><span class="sxs-lookup"><span data-stu-id="d91e6-189">Second, if you evaluate the animation system, you'll see that it is almost completely declarative.</span></span> <span data-ttu-id="d91e6-190">En lugar de exigir al desarrollador que calcule la ubicación o el color siguiente, las animaciones pueden expresarse como un conjunto de propiedades en un objeto de animación.</span><span class="sxs-lookup"><span data-stu-id="d91e6-190">Instead of requiring a developer to compute the next location, or next color, you can express animations as a set of properties on an animation object.</span></span> <span data-ttu-id="d91e6-191">Estas animaciones permitirán expresar la intención del desarrollador o del diseñador (mueva este botón de aquí a allí en 5 segundos) y el sistema podrá determinar la manera más eficaz de lograrlo.</span><span class="sxs-lookup"><span data-stu-id="d91e6-191">These animations can then express the intent of the developer or designer (move this button from here to there in 5 seconds), and the system can determine the most efficient way to accomplish that.</span></span>  
  
<a name="System_Windows_UIElement"></a>   
## <a name="systemwindowsuielement"></a><span data-ttu-id="d91e6-192">System.Windows.UIElement</span><span class="sxs-lookup"><span data-stu-id="d91e6-192">System.Windows.UIElement</span></span>  
 <span data-ttu-id="d91e6-193"><xref:System.Windows.UIElement> define subsistemas principales, como el diseño, la entrada y los eventos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-193"><xref:System.Windows.UIElement> defines core subsystems including Layout, Input, and Events.</span></span>  
  
 <span data-ttu-id="d91e6-194">El diseño es un concepto básico en WPF.</span><span class="sxs-lookup"><span data-stu-id="d91e6-194">Layout is a core concept in WPF.</span></span> <span data-ttu-id="d91e6-195">Son muchos los sistemas en los que, o existe un conjunto fijo de modelos de diseño (HTML admite tres modelos de diseño; flujo, absoluto y tablas), o no existe ningún modelo de diseño (en realidad, User32 solo admite el posicionamiento absoluto).</span><span class="sxs-lookup"><span data-stu-id="d91e6-195">In many systems there is either a fixed set of layout models (HTML supports three models for layout; flow, absolute, and tables) or no model for layout (User32 really only supports absolute positioning).</span></span> <span data-ttu-id="d91e6-196">WPF comenzó con la suposición de que los desarrolladores y diseñadores querían un modelo de diseño flexible y extensible, que podía estar controlado por valores de propiedad en lugar de lógica imperativa.</span><span class="sxs-lookup"><span data-stu-id="d91e6-196">WPF started with the assumption that developers and designers wanted a flexible, extensible layout model, which could be driven by property values rather than imperative logic.</span></span> <span data-ttu-id="d91e6-197">En el nivel de <xref:System.Windows.UIElement>, se introduce el contrato básico para el diseño: un modelo de dos fases con <xref:System.Windows.UIElement.Measure%2A> y <xref:System.Windows.UIElement.Arrange%2A>.</span><span class="sxs-lookup"><span data-stu-id="d91e6-197">At the <xref:System.Windows.UIElement> level, the basic contract for layout is introduced – a two phase model with <xref:System.Windows.UIElement.Measure%2A> and <xref:System.Windows.UIElement.Arrange%2A> passes.</span></span>  
  
 <span data-ttu-id="d91e6-198"><xref:System.Windows.UIElement.Measure%2A> permite a un componente determinar cuánto tamaño le gustaría tomar.</span><span class="sxs-lookup"><span data-stu-id="d91e6-198"><xref:System.Windows.UIElement.Measure%2A> allows a component to determine how much size it would like to take.</span></span> <span data-ttu-id="d91e6-199">Se trata de una fase independiente de <xref:System.Windows.UIElement.Arrange%2A> porque hay muchas situaciones en las que un elemento primario solicitará a un elemento secundario que mida varias veces para determinar su posición y tamaño óptimos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-199">This is a separate phase from <xref:System.Windows.UIElement.Arrange%2A> because there are many situations where a parent element will ask a child to measure several times to determine its optimal position and size.</span></span> <span data-ttu-id="d91e6-200">El hecho de que los elementos primarios pidan a los elementos secundarios que se midan demuestra otra filosofía clave de WPF: tamaño del contenido.</span><span class="sxs-lookup"><span data-stu-id="d91e6-200">The fact that parent elements ask child elements to measure demonstrates another key philosophy of WPF – size to content.</span></span> <span data-ttu-id="d91e6-201">Todos los controles de WPF admiten la capacidad de ajustarse al tamaño natural de su contenido.</span><span class="sxs-lookup"><span data-stu-id="d91e6-201">All controls in WPF support the ability to size to the natural size of their content.</span></span> <span data-ttu-id="d91e6-202">Esto facilita enormemente la localización y permite un diseño dinámico de los elementos cuando los objetos cambian de tamaño.</span><span class="sxs-lookup"><span data-stu-id="d91e6-202">This makes localization much easier, and allows for dynamic layout of elements as things resize.</span></span> <span data-ttu-id="d91e6-203">La fase <xref:System.Windows.UIElement.Arrange%2A> permite a un elemento primario colocar y determinar el tamaño final de cada elemento secundario.</span><span class="sxs-lookup"><span data-stu-id="d91e6-203">The <xref:System.Windows.UIElement.Arrange%2A> phase allows a parent to position and determine the final size of each child.</span></span>  
  
 <span data-ttu-id="d91e6-204">A menudo se emplea mucho tiempo en hablar sobre el lado de salida de WPF: <xref:System.Windows.Media.Visual> y los objetos relacionados.</span><span class="sxs-lookup"><span data-stu-id="d91e6-204">A lot of time is often spent talking about the output side of WPF – <xref:System.Windows.Media.Visual> and related objects.</span></span> <span data-ttu-id="d91e6-205">En cambio, también hay una gran cantidad de innovaciones en cuanto a la entrada.</span><span class="sxs-lookup"><span data-stu-id="d91e6-205">However there is a tremendous amount of innovation on the input side as well.</span></span> <span data-ttu-id="d91e6-206">Probablemente, el cambio más importante en el modelo de entrada de WPF es el modelo coherente por el que los eventos de entrada se enrutan a través del sistema.</span><span class="sxs-lookup"><span data-stu-id="d91e6-206">Probably the most fundamental change in the input model for WPF is the consistent model by which input events are routed through the system.</span></span>  
  
 <span data-ttu-id="d91e6-207">La entrada se origina en forma de señal en un controlador de dispositivo de modo kernel y se vuelve a enrutar al proceso y subproceso correctos a través de un intrincado procedimiento que implica el kernel de Windows y User32.</span><span class="sxs-lookup"><span data-stu-id="d91e6-207">Input originates as a signal on a kernel mode device driver and gets routed to the correct process and thread through an intricate process involving the Windows kernel and User32.</span></span> <span data-ttu-id="d91e6-208">Una vez que el mensaje user32 correspondiente a la entrada se enruta a WPF, se convierte en un mensaje de entrada sin formato de WPF y se envía al distribuidor.</span><span class="sxs-lookup"><span data-stu-id="d91e6-208">Once the User32 message corresponding to the input is routed to WPF, it is converted into a WPF raw input message and sent to the dispatcher.</span></span> <span data-ttu-id="d91e6-209">WPF permite que los eventos de entrada sin formato se conviertan en varios eventos reales, lo que permite implementar características como "MouseEnter" en un nivel bajo del sistema con entrega garantizada.</span><span class="sxs-lookup"><span data-stu-id="d91e6-209">WPF allows for raw input events to be converted to multiple actual events, enabling features like "MouseEnter" to be implemented at a low level of the system with guaranteed delivery.</span></span>  
  
 <span data-ttu-id="d91e6-210">Cada evento de entrada se convierte en al menos dos eventos, un evento de "vista previa" y el evento real.</span><span class="sxs-lookup"><span data-stu-id="d91e6-210">Each input event is converted to at least two events – a "preview" event and the actual event.</span></span> <span data-ttu-id="d91e6-211">Todos los eventos de WPF tienen una noción de enrutamiento a través del árbol de elementos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-211">All events in WPF have a notion of routing through the element tree.</span></span> <span data-ttu-id="d91e6-212">Los eventos se indican como "burbuja" Si atraviesan un destino hasta la raíz del árbol y se dice que se trata de un "túnel" si empiezan en la raíz y pasan a un destino.</span><span class="sxs-lookup"><span data-stu-id="d91e6-212">Events are said to "bubble" if they traverse from a target up the tree to the root, and are said to "tunnel" if they start at the root and traverse down to a target.</span></span> <span data-ttu-id="d91e6-213">Los eventos de vista previa de entrada tunelizan, lo que ofrece a cualquiera de los elementos del árbol una oportunidad para filtrar o realizar acciones cuando se produce un evento.</span><span class="sxs-lookup"><span data-stu-id="d91e6-213">Input preview events tunnel, enabling any element in the tree an opportunity to filter or take action on the event.</span></span> <span data-ttu-id="d91e6-214">Los eventos normales (sin vista previa) se traspasan a continuación desde el destino hasta la raíz.</span><span class="sxs-lookup"><span data-stu-id="d91e6-214">The regular (non-preview) events then bubble from the target up to the root.</span></span>  
  
 <span data-ttu-id="d91e6-215">Esta diferencia entre la fase de túnel y de traspaso permite que la implementación de características como los aceleradores de teclado funcione de manera coherente en un universo compuesto.</span><span class="sxs-lookup"><span data-stu-id="d91e6-215">This split between the tunnel and bubble phase makes implementation of features like keyboard accelerators work in a consistent fashion in a composite world.</span></span> <span data-ttu-id="d91e6-216">En User32, la implementación de los aceleradores de teclado se realizaría teniendo una tabla global única con todos los aceleradores admitidos (Ctrl+N asignado a "Nuevo").</span><span class="sxs-lookup"><span data-stu-id="d91e6-216">In User32 you would implement keyboard accelerators by having a single global table containing all the accelerators you wanted to support (Ctrl+N mapping to "New").</span></span> <span data-ttu-id="d91e6-217">En el distribuidor de la aplicación se llamaría a **TranslateAccelerator**, que examinaría los mensajes de entrada en User32 y determinaría si alguno de ellos coincide con un acelerador registrado.</span><span class="sxs-lookup"><span data-stu-id="d91e6-217">In the dispatcher for your application you would call **TranslateAccelerator** which would sniff the input messages in User32 and determine if any matched a registered accelerator.</span></span> <span data-ttu-id="d91e6-218">En WPF esto no funcionaría porque el sistema está totalmente "ajustable": cualquier elemento puede controlar y usar cualquier tecla de aceleración.</span><span class="sxs-lookup"><span data-stu-id="d91e6-218">In WPF this wouldn’t work because the system is fully "composable" – any element can handle and use any keyboard accelerator.</span></span> <span data-ttu-id="d91e6-219">Tener este modelo de dos fases para la entrada permite a los componentes implementar su propio "TranslateAccelerator".</span><span class="sxs-lookup"><span data-stu-id="d91e6-219">Having this two phase model for input allows components to implement their own "TranslateAccelerator".</span></span>  
  
 <span data-ttu-id="d91e6-220">Para seguir este paso, <xref:System.Windows.UIElement> también presenta la noción de CommandBindings.</span><span class="sxs-lookup"><span data-stu-id="d91e6-220">To take this one step further, <xref:System.Windows.UIElement> also introduces the notion of CommandBindings.</span></span> <span data-ttu-id="d91e6-221">El sistema de comandos de WPF permite a los desarrolladores definir la funcionalidad en términos de un punto de conexión de comando, algo que implementa <xref:System.Windows.Input.ICommand>.</span><span class="sxs-lookup"><span data-stu-id="d91e6-221">The WPF command system allows developers to define functionality in terms of a command end point – something that implements <xref:System.Windows.Input.ICommand>.</span></span> <span data-ttu-id="d91e6-222">Los enlaces de comandos permiten a un elemento definir una asignación entre un gesto de entrada (Ctrl+N) y un comando (Nuevo).</span><span class="sxs-lookup"><span data-stu-id="d91e6-222">Command bindings enable an element to define a mapping between an input gesture (Ctrl+N) and a command (New).</span></span> <span data-ttu-id="d91e6-223">Tanto los gestos de entrada como las definiciones de comandos son extensibles, y pueden conectarse en el momento de su uso.</span><span class="sxs-lookup"><span data-stu-id="d91e6-223">Both the input gestures and command definitions are extensible, and can be wired together at usage time.</span></span> <span data-ttu-id="d91e6-224">Esto hace que resulte trivial, por ejemplo, permitir que un usuario final personalice los enlaces de teclado que quiere usar dentro de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="d91e6-224">This makes it trivial, for example, to allow an end user to customize the key bindings that they want to use within an application.</span></span>  
  
 <span data-ttu-id="d91e6-225">En este punto del tema, las características "principales" de WPF (características implementadas en el ensamblado PresentationCore) fueron el foco.</span><span class="sxs-lookup"><span data-stu-id="d91e6-225">To this point in the topic, "core" features of WPF – features implemented in the PresentationCore assembly, have been the focus.</span></span> <span data-ttu-id="d91e6-226">Al compilar WPF, una separación limpia entre las partes fundamentales (como el contrato para el diseño con **Measure** y **Arrange**) y las partes del marco (como la implementación de un diseño específico como <xref:System.Windows.Controls.Grid>) era el resultado deseado.</span><span class="sxs-lookup"><span data-stu-id="d91e6-226">When building WPF, a clean separation between foundational pieces (like the contract for layout with **Measure** and **Arrange**) and framework pieces (like the implementation of a specific layout like <xref:System.Windows.Controls.Grid>) was the desired outcome.</span></span> <span data-ttu-id="d91e6-227">El objetivo era proporcionar un punto de extensibilidad en la zona inferior de la pila que permitiría a los programadores externos crear sus propios marcos de trabajo en caso necesario.</span><span class="sxs-lookup"><span data-stu-id="d91e6-227">The goal was to provide an extensibility point low in the stack that would allow external developers to create their own frameworks if needed.</span></span>  
  
<a name="System_Windows_FrameworkElement"></a>   
## <a name="systemwindowsframeworkelement"></a><span data-ttu-id="d91e6-228">System.Windows.FrameworkElement</span><span class="sxs-lookup"><span data-stu-id="d91e6-228">System.Windows.FrameworkElement</span></span>  
 <span data-ttu-id="d91e6-229"><xref:System.Windows.FrameworkElement> se pueden examinar de dos maneras diferentes.</span><span class="sxs-lookup"><span data-stu-id="d91e6-229"><xref:System.Windows.FrameworkElement> can be looked at in two different ways.</span></span> <span data-ttu-id="d91e6-230">Presenta un conjunto de directivas y personalizaciones en los subsistemas introducidos en capas inferiores de WPF.</span><span class="sxs-lookup"><span data-stu-id="d91e6-230">It introduces a set of policies and customizations on the subsystems introduced in lower layers of WPF.</span></span> <span data-ttu-id="d91e6-231">También presenta un conjunto de nuevos subsistemas.</span><span class="sxs-lookup"><span data-stu-id="d91e6-231">It also introduces a set of new subsystems.</span></span>  
  
 <span data-ttu-id="d91e6-232">La directiva principal introducida por <xref:System.Windows.FrameworkElement> está en torno al diseño de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d91e6-232">The primary policy introduced by <xref:System.Windows.FrameworkElement> is around application layout.</span></span> <span data-ttu-id="d91e6-233"><xref:System.Windows.FrameworkElement> se basa en el contrato de diseño básico introducido por <xref:System.Windows.UIElement> y agrega la noción de una "ranura" de diseño que facilita que los autores del diseño tengan un conjunto coherente de semántica de diseño controlado por propiedades.</span><span class="sxs-lookup"><span data-stu-id="d91e6-233"><xref:System.Windows.FrameworkElement> builds on the basic layout contract introduced by <xref:System.Windows.UIElement> and adds the notion of a layout "slot" that makes it easier for layout authors to have a consistent set of property driven layout semantics.</span></span> <span data-ttu-id="d91e6-234">Las propiedades como <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>y <xref:System.Windows.FrameworkElement.Margin%2A> (por nombrar algunas) proporcionan a todos los componentes derivados de <xref:System.Windows.FrameworkElement> comportamiento coherente dentro de los contenedores de diseño.</span><span class="sxs-lookup"><span data-stu-id="d91e6-234">Properties like <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A>, <xref:System.Windows.FrameworkElement.VerticalAlignment%2A>, <xref:System.Windows.FrameworkElement.MinWidth%2A>, and <xref:System.Windows.FrameworkElement.Margin%2A> (to name a few) give all components derived from <xref:System.Windows.FrameworkElement> consistent behavior inside of layout containers.</span></span>  
  
 <span data-ttu-id="d91e6-235"><xref:System.Windows.FrameworkElement> también proporciona una exposición de API más sencilla a muchas de las características que se encuentran en las capas principales de WPF.</span><span class="sxs-lookup"><span data-stu-id="d91e6-235"><xref:System.Windows.FrameworkElement> also provides easier API exposure to many features found in the core layers of WPF.</span></span> <span data-ttu-id="d91e6-236">Por ejemplo, <xref:System.Windows.FrameworkElement> proporciona acceso directo a la animación a través del método <xref:System.Windows.FrameworkElement.BeginStoryboard%2A>.</span><span class="sxs-lookup"><span data-stu-id="d91e6-236">For example, <xref:System.Windows.FrameworkElement> provides direct access to animation through the <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> method.</span></span> <span data-ttu-id="d91e6-237">Un <xref:System.Windows.Media.Animation.Storyboard> proporciona una manera de generar scripts de varias animaciones en un conjunto de propiedades.</span><span class="sxs-lookup"><span data-stu-id="d91e6-237">A <xref:System.Windows.Media.Animation.Storyboard> provides a way to script multiple animations against a set of properties.</span></span>  
  
 <span data-ttu-id="d91e6-238">Las dos cosas más críticas que <xref:System.Windows.FrameworkElement> presenta son el enlace de datos y los estilos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-238">The two most critical things that <xref:System.Windows.FrameworkElement> introduces are data binding and styles.</span></span>  
  
 <span data-ttu-id="d91e6-239">El subsistema de enlace de datos en WPF debe ser relativamente familiar para cualquier persona que haya usado Windows Forms o ASP.NET para crear una aplicación [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="d91e6-239">The data binding subsystem in WPF should be relatively familiar to anyone that has used Windows Forms or ASP.NET for creating an application [!INCLUDE[TLA#tla_ui](../../../../includes/tlasharptla-ui-md.md)].</span></span> <span data-ttu-id="d91e6-240">En cada uno de estos sistemas, hay una manera sencilla de expresar que quiere enlazar una o varias propiedades de un elemento determinado a un fragmento de datos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-240">In each of these systems, there is a simple way to express that you want one or more properties from a given element to be bound to a piece of data.</span></span> <span data-ttu-id="d91e6-241">WPF es totalmente compatible con el enlace de propiedades, la transformación y el enlace de listas.</span><span class="sxs-lookup"><span data-stu-id="d91e6-241">WPF has full support for property binding, transformation, and list binding.</span></span>  
  
 <span data-ttu-id="d91e6-242">Una de las características más interesantes del enlace de datos en WPF es la introducción de las plantillas de datos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-242">One of the most interesting features of data binding in WPF is the introduction of data templates.</span></span> <span data-ttu-id="d91e6-243">Las plantillas de datos le permiten especificar mediante declaración cómo se debería visualizar un fragmento de datos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-243">Data templates allow you to declaratively specify how a piece of data should be visualized.</span></span> <span data-ttu-id="d91e6-244">En lugar de crear una interfaz de usuario personalizada que se puede enlazar a los datos, puede solucionar el problema permitiendo que los datos determinen la presentación que se va a crear.</span><span class="sxs-lookup"><span data-stu-id="d91e6-244">Instead of creating a custom user interface that can be bound to data, you can instead turn the problem around and let the data determine the display that will be created.</span></span>  
  
 <span data-ttu-id="d91e6-245">La aplicación de estilos es realmente una forma ligera de enlace de datos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-245">Styling is really a lightweight form of data binding.</span></span> <span data-ttu-id="d91e6-246">El uso de estilos le permite enlazar un conjunto de propiedades de una definición compartida a una o varias instancias de un elemento.</span><span class="sxs-lookup"><span data-stu-id="d91e6-246">Using styling you can bind a set of properties from a shared definition to one or more instances of an element.</span></span> <span data-ttu-id="d91e6-247">Los estilos se aplican a un elemento mediante una referencia explícita (estableciendo la propiedad <xref:System.Windows.FrameworkElement.Style%2A>) o implícitamente asociando un estilo al tipo CLR del elemento.</span><span class="sxs-lookup"><span data-stu-id="d91e6-247">Styles get applied to an element either by explicit reference (by setting the <xref:System.Windows.FrameworkElement.Style%2A> property) or implicitly by associating a style with the CLR type of the element.</span></span>  
  
<a name="System_Windows_Controls_Control"></a>   
## <a name="systemwindowscontrolscontrol"></a><span data-ttu-id="d91e6-248">System.Windows.Controls.Control</span><span class="sxs-lookup"><span data-stu-id="d91e6-248">System.Windows.Controls.Control</span></span>  
 <span data-ttu-id="d91e6-249">La característica más significativa del control es la definición de plantillas.</span><span class="sxs-lookup"><span data-stu-id="d91e6-249">Control’s most significant feature is templating.</span></span> <span data-ttu-id="d91e6-250">Si piensa en el sistema de composición de WPF como en un sistema de representación de modo retenido, la definición de plantillas permite a un control describir su representación de una manera parametrizada y declarativa.</span><span class="sxs-lookup"><span data-stu-id="d91e6-250">If you think about WPF’s composition system as a retained mode rendering system, templating allows a control to describe its rendering in a parameterized, declarative manner.</span></span> <span data-ttu-id="d91e6-251">Un <xref:System.Windows.Controls.ControlTemplate> no es realmente nada más que un script para crear un conjunto de elementos secundarios, con enlaces a las propiedades que ofrece el control.</span><span class="sxs-lookup"><span data-stu-id="d91e6-251">A <xref:System.Windows.Controls.ControlTemplate> is really nothing more than a script to create a set of child elements, with bindings to properties offered by the control.</span></span>  
  
 <span data-ttu-id="d91e6-252"><xref:System.Windows.Controls.Control> proporciona un conjunto de propiedades estándar, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, por nombrar algunas, que los autores de la plantilla pueden usar para personalizar la presentación de un control.</span><span class="sxs-lookup"><span data-stu-id="d91e6-252"><xref:System.Windows.Controls.Control> provides a set of stock properties, <xref:System.Windows.Controls.Control.Foreground%2A>, <xref:System.Windows.Controls.Control.Background%2A>, <xref:System.Windows.Controls.Control.Padding%2A>, to name a few, which template authors can then use to customize the display of a control.</span></span> <span data-ttu-id="d91e6-253">La implementación de un control proporciona un modelo de datos y un modelo de interacción.</span><span class="sxs-lookup"><span data-stu-id="d91e6-253">The implementation of a control provides a data model and interaction model.</span></span> <span data-ttu-id="d91e6-254">El modelo de interacción define un conjunto de comandos (como Cerrar para una ventana) y enlaces a gestos de entrada (como hacer clic en la X roja situada en la esquina superior de la ventana).</span><span class="sxs-lookup"><span data-stu-id="d91e6-254">The interaction model defines a set of commands (like Close for a window) and bindings to input gestures (like clicking the red X in the upper corner of the window).</span></span> <span data-ttu-id="d91e6-255">El modelo de datos proporciona un conjunto de propiedades para personalizar el modelo de interacción o la presentación (determinado por la plantilla).</span><span class="sxs-lookup"><span data-stu-id="d91e6-255">The data model provides a set of properties to either customize the interaction model or customize the display (determined by the template).</span></span>  
  
 <span data-ttu-id="d91e6-256">Esta diferencia entre el modelo de datos (propiedades), el modelo de interacción (comandos y eventos) y el modelo de presentación (plantillas) permite una total personalización de la apariencia y el comportamiento de un control.</span><span class="sxs-lookup"><span data-stu-id="d91e6-256">This split between the data model (properties), interaction model (commands and events), and display model (templates) enables complete customization of a control’s look and behavior.</span></span>  
  
 <span data-ttu-id="d91e6-257">Un aspecto común del modelo de datos de los controles es el modelo de contenido.</span><span class="sxs-lookup"><span data-stu-id="d91e6-257">A common aspect of the data model of controls is the content model.</span></span> <span data-ttu-id="d91e6-258">Si observa un control como <xref:System.Windows.Controls.Button>, verá que tiene una propiedad denominada "Content" de tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="d91e6-258">If you look at a control like <xref:System.Windows.Controls.Button>, you will see that it has a property named "Content" of type <xref:System.Object>.</span></span> <span data-ttu-id="d91e6-259">En Windows Forms y ASP.NET, esta propiedad normalmente sería una cadena; sin embargo, esto limita el tipo de contenido que se puede colocar en un botón.</span><span class="sxs-lookup"><span data-stu-id="d91e6-259">In Windows Forms and ASP.NET, this property would typically be a string – however that limits the type of content you can put in a button.</span></span> <span data-ttu-id="d91e6-260">El contenido de un botón puede ser una cadena simple, un objeto de datos complejo o un árbol de elementos completo.</span><span class="sxs-lookup"><span data-stu-id="d91e6-260">Content for a button can either be a simple string, a complex data object, or an entire element tree.</span></span> <span data-ttu-id="d91e6-261">En el caso de un objeto de datos, la plantilla de datos se usa para construir una presentación.</span><span class="sxs-lookup"><span data-stu-id="d91e6-261">In the case of a data object, the data template is used to construct a display.</span></span>  
  
<a name="Summary"></a>   
## <a name="summary"></a><span data-ttu-id="d91e6-262">Resumen</span><span class="sxs-lookup"><span data-stu-id="d91e6-262">Summary</span></span>  
 <span data-ttu-id="d91e6-263">WPF está diseñado para permitirle crear sistemas de presentación dinámicos y controlados por datos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-263">WPF is designed to allow you to create dynamic, data driven presentation systems.</span></span> <span data-ttu-id="d91e6-264">Cada parte del sistema está diseñada para crear objetos mediante conjuntos de propiedades que controlan el comportamiento.</span><span class="sxs-lookup"><span data-stu-id="d91e6-264">Every part of the system is designed to create objects through property sets that drive behavior.</span></span> <span data-ttu-id="d91e6-265">El enlace de datos es una parte fundamental del sistema y está integrado en cada capa.</span><span class="sxs-lookup"><span data-stu-id="d91e6-265">Data binding is a fundamental part of the system, and is integrated at every layer.</span></span>  
  
 <span data-ttu-id="d91e6-266">Las aplicaciones tradicionales crean una presentación y, después, enlazan a algunos datos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-266">Traditional applications create a display and then bind to some data.</span></span> <span data-ttu-id="d91e6-267">En WPF, todo lo relacionado con el control, cada aspecto de la pantalla, se genera mediante algún tipo de enlace de datos.</span><span class="sxs-lookup"><span data-stu-id="d91e6-267">In WPF, everything about the control, every aspect of the display, is generated by some type of data binding.</span></span> <span data-ttu-id="d91e6-268">El texto situado dentro de un botón se muestra creando un control compuesto dentro de este y enlazando su presentación a la propiedad de contenido del botón.</span><span class="sxs-lookup"><span data-stu-id="d91e6-268">The text found inside a button is displayed by creating a composed control inside of the button and binding its display to the button’s content property.</span></span>  
  
 <span data-ttu-id="d91e6-269">Cuando empiece a desarrollar aplicaciones basadas en WPF, debe sentir muy familiar.</span><span class="sxs-lookup"><span data-stu-id="d91e6-269">When you begin developing WPF based applications, it should feel very familiar.</span></span> <span data-ttu-id="d91e6-270">Puede establecer propiedades, utilizar objetos y enlazar datos de la misma manera que puede usar Windows Forms o ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="d91e6-270">You can set properties, use objects, and data bind in much the same way that you can using Windows Forms or ASP.NET.</span></span> <span data-ttu-id="d91e6-271">Con una investigación más profunda de la arquitectura de WPF, observará que existe la posibilidad de crear aplicaciones mucho más enriquecidas que traten fundamentalmente los datos como el controlador principal de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="d91e6-271">With a deeper investigation into the architecture of WPF, you'll find that the possibility exists for creating much richer applications that fundamentally treat data as the core driver of the application.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="d91e6-272">Vea también</span><span class="sxs-lookup"><span data-stu-id="d91e6-272">See also</span></span>

- <xref:System.Windows.Media.Visual>
- <xref:System.Windows.UIElement>
- <xref:System.Windows.Input.ICommand>
- <xref:System.Windows.FrameworkElement>
- <xref:System.Windows.Threading.DispatcherObject>
- <xref:System.Windows.Input.CommandBinding>
- <xref:System.Windows.Controls.Control>
- [<span data-ttu-id="d91e6-273">Información general sobre el enlace de datos</span><span class="sxs-lookup"><span data-stu-id="d91e6-273">Data Binding Overview</span></span>](../../../desktop-wpf/data/data-binding-overview.md)
- [<span data-ttu-id="d91e6-274">Diseño</span><span class="sxs-lookup"><span data-stu-id="d91e6-274">Layout</span></span>](layout.md)
- [<span data-ttu-id="d91e6-275">Información general sobre animaciones</span><span class="sxs-lookup"><span data-stu-id="d91e6-275">Animation Overview</span></span>](../graphics-multimedia/animation-overview.md)
