---
title: Árboles de expresiones en detalle
description: Obtenga información sobre los árboles de expresión y cómo son útiles en la traducción de algoritmos para la ejecución externa y la inspección de código antes de ejecutarlo.
ms.date: 06/20/2016
ms.technology: csharp-advanced-concepts
ms.assetid: bbcdd339-86eb-4ae5-9911-4c214a39a92d
ms.openlocfilehash: 12093e9c9246c87cc5ea3aedaca6ba34acacce4d
ms.sourcegitcommit: 7588136e355e10cbc2582f389c90c127363c02a5
ms.translationtype: HT
ms.contentlocale: es-ES
ms.lasthandoff: 03/14/2020
ms.locfileid: "73036990"
---
# <a name="expression-trees-explained"></a><span data-ttu-id="376f0-103">Árboles de expresiones en detalle</span><span class="sxs-lookup"><span data-stu-id="376f0-103">Expression Trees Explained</span></span>

[<span data-ttu-id="376f0-104">Anterior: Información general</span><span class="sxs-lookup"><span data-stu-id="376f0-104">Previous -- Overview</span></span>](expression-trees.md)

<span data-ttu-id="376f0-105">Los árboles de expresiones son estructuras de datos que definen código.</span><span class="sxs-lookup"><span data-stu-id="376f0-105">An Expression Tree is a data structure that defines code.</span></span> <span data-ttu-id="376f0-106">Se basan en las mismas estructuras que usa un compilador para analizar el código y generar el resultado compilado.</span><span class="sxs-lookup"><span data-stu-id="376f0-106">They are based on the same structures that a compiler uses to analyze code and generate the compiled output.</span></span> <span data-ttu-id="376f0-107">A medida que vaya leyendo este tutorial, observará cierta similitud entre los árboles de expresiones y los tipos usados en las API de Roslyn para compilar [analizadores y correcciones de código](https://github.com/dotnet/roslyn-analyzers).</span><span class="sxs-lookup"><span data-stu-id="376f0-107">As you read through this tutorial, you will notice quite a bit of similarity between Expression Trees and the types used in the Roslyn APIs to build [Analyzers and CodeFixes](https://github.com/dotnet/roslyn-analyzers).</span></span>
<span data-ttu-id="376f0-108">(Los analizadores y las correcciones de código son paquetes de NuGet que realizan un análisis estático en código y pueden sugerir posibles correcciones para un desarrollador). Los conceptos son similares y el resultado final es una estructura de datos que permite examinar el código fuente de forma significativa.</span><span class="sxs-lookup"><span data-stu-id="376f0-108">(Analyzers and CodeFixes are NuGet packages that perform static analysis on code and can suggest potential fixes for a developer.) The concepts are similar, and the end result is a data structure that allows examination of the source code in a meaningful way.</span></span> <span data-ttu-id="376f0-109">En cambio, los árboles de expresiones se basan en un conjunto de clases y API totalmente diferente a las API de Roslyn.</span><span class="sxs-lookup"><span data-stu-id="376f0-109">However, Expression Trees are based on a totally different set of classes and APIs than the Roslyn APIs.</span></span>

<span data-ttu-id="376f0-110">Veamos un ejemplo sencillo.</span><span class="sxs-lookup"><span data-stu-id="376f0-110">Let's look at a simple example.</span></span>
<span data-ttu-id="376f0-111">Aquí tiene una línea de código:</span><span class="sxs-lookup"><span data-stu-id="376f0-111">Here's a line of code:</span></span>

```csharp
var sum = 1 + 2;
```

<span data-ttu-id="376f0-112">Si fuera a analizarlo como un árbol de expresión, el árbol contiene varios nodos.</span><span class="sxs-lookup"><span data-stu-id="376f0-112">If you were to analyze this as an expression tree, the tree contains several nodes.</span></span>
<span data-ttu-id="376f0-113">El nodo más externo es una instrucción de declaración de variable con asignación (`var sum = 1 + 2;`). Ese nodo exterior contiene varios nodos secundarios: una declaración de variable, un operador de asignación y una expresión que representa el lado derecho del signo igual.</span><span class="sxs-lookup"><span data-stu-id="376f0-113">The outermost node is a variable declaration statement with assignment (`var sum = 1 + 2;`) That outermost node contains several child nodes: a variable declaration, an assignment operator, and an expression representing the right hand side of the equals sign.</span></span> <span data-ttu-id="376f0-114">Esa expresión se subdivide aún más en expresiones que representan la operación de suma, y los operandos izquierdo y derecho de la suma.</span><span class="sxs-lookup"><span data-stu-id="376f0-114">That expression is further subdivided into expressions that represent the addition operation, and left and right operands of the addition.</span></span>

<span data-ttu-id="376f0-115">Vamos a profundizar un poco más en las expresiones que constituyen el lado derecho del signo igual.</span><span class="sxs-lookup"><span data-stu-id="376f0-115">Let's drill down a bit more into the expressions that make up the right side of the equals sign.</span></span>
<span data-ttu-id="376f0-116">La expresión es `1 + 2`.</span><span class="sxs-lookup"><span data-stu-id="376f0-116">The expression is `1 + 2`.</span></span> <span data-ttu-id="376f0-117">Se trata de una expresión binaria.</span><span class="sxs-lookup"><span data-stu-id="376f0-117">That's a binary expression.</span></span> <span data-ttu-id="376f0-118">Concretamente, es una expresión binaria de suma.</span><span class="sxs-lookup"><span data-stu-id="376f0-118">More specifically, it's a binary addition expression.</span></span> <span data-ttu-id="376f0-119">Una expresión binaria de suma tiene dos elementos secundarios, que representan los nodos izquierdo y derecho de la expresión de suma.</span><span class="sxs-lookup"><span data-stu-id="376f0-119">A binary addition expression has two children, representing the left and right nodes of the addition expression.</span></span> <span data-ttu-id="376f0-120">Aquí, ambos nodos son expresiones constantes: El operador izquierdo es el valor `1` y el operador derecho, el valor `2`.</span><span class="sxs-lookup"><span data-stu-id="376f0-120">Here, both nodes are constant expressions: The left operand is the value `1`, and the right operand is the value `2`.</span></span>

<span data-ttu-id="376f0-121">Visualmente, toda la instrucción es un árbol: puede empezar en el nodo raíz y desplazarse a cada uno de los nodos del árbol para ver el código que compone la instrucción:</span><span class="sxs-lookup"><span data-stu-id="376f0-121">Visually, the entire statement is a tree: You could start at the root node, and travel to each node in the tree to see the code that makes up the statement:</span></span>

- <span data-ttu-id="376f0-122">Instrucción de declaración de variable con asignación (`var sum = 1 + 2;`)</span><span class="sxs-lookup"><span data-stu-id="376f0-122">Variable declaration statement with assignment (`var sum = 1 + 2;`)</span></span>
  - <span data-ttu-id="376f0-123">Declaración de tipo de variable implícita (`var sum`)</span><span class="sxs-lookup"><span data-stu-id="376f0-123">Implicit variable type declaration (`var sum`)</span></span>
    - <span data-ttu-id="376f0-124">Palabra clave var implícita (`var`)</span><span class="sxs-lookup"><span data-stu-id="376f0-124">Implicit var keyword (`var`)</span></span>
    - <span data-ttu-id="376f0-125">Declaración de nombre de variable (`sum`)</span><span class="sxs-lookup"><span data-stu-id="376f0-125">Variable name declaration (`sum`)</span></span>
  - <span data-ttu-id="376f0-126">Operador de asignación (`=`)</span><span class="sxs-lookup"><span data-stu-id="376f0-126">Assignment operator (`=`)</span></span>
  - <span data-ttu-id="376f0-127">Expresión binaria de suma (`1 + 2`)</span><span class="sxs-lookup"><span data-stu-id="376f0-127">Binary addition expression (`1 + 2`)</span></span>
    - <span data-ttu-id="376f0-128">Operando izquierdo (`1`)</span><span class="sxs-lookup"><span data-stu-id="376f0-128">Left operand (`1`)</span></span>
    - <span data-ttu-id="376f0-129">Operador de suma (`+`)</span><span class="sxs-lookup"><span data-stu-id="376f0-129">Addition operator (`+`)</span></span>
    - <span data-ttu-id="376f0-130">Operando derecho (`2`)</span><span class="sxs-lookup"><span data-stu-id="376f0-130">Right operand (`2`)</span></span>

<span data-ttu-id="376f0-131">Esto puede parecer complicado, pero resulta muy eficaz.</span><span class="sxs-lookup"><span data-stu-id="376f0-131">This may look complicated, but it is very powerful.</span></span> <span data-ttu-id="376f0-132">Siguiendo el mismo proceso, puede descomponer expresiones mucho más complicadas.</span><span class="sxs-lookup"><span data-stu-id="376f0-132">Following the same process, you can decompose much more complicated expressions.</span></span> <span data-ttu-id="376f0-133">Tomemos esta expresión como ejemplo:</span><span class="sxs-lookup"><span data-stu-id="376f0-133">Consider this expression:</span></span>

```csharp
var finalAnswer = this.SecretSauceFunction(
    currentState.createInterimResult(), currentState.createSecondValue(1, 2),
    decisionServer.considerFinalOptions("hello")) +
    MoreSecretSauce('A', DateTime.Now, true);
```

<span data-ttu-id="376f0-134">La expresión anterior también es una declaración de variable con una asignación.</span><span class="sxs-lookup"><span data-stu-id="376f0-134">The expression above is also a variable declaration with an assignment.</span></span>
<span data-ttu-id="376f0-135">En este caso, el lado derecho de la asignación es un árbol mucho más complicado.</span><span class="sxs-lookup"><span data-stu-id="376f0-135">In this instance, the right hand side of the assignment is a much more complicated tree.</span></span>
<span data-ttu-id="376f0-136">No voy a descomponer esta expresión, pero tenga en cuenta lo que podrían ser los distintos nodos.</span><span class="sxs-lookup"><span data-stu-id="376f0-136">I'm not going to decompose this expression, but consider what the different nodes might be.</span></span> <span data-ttu-id="376f0-137">Hay llamadas de método que usan el objeto actual como un receptor, una que tiene un receptor `this` explícito y otra que no.</span><span class="sxs-lookup"><span data-stu-id="376f0-137">There are method calls using the current object as a receiver, one that has an explicit `this` receiver, one that does not.</span></span> <span data-ttu-id="376f0-138">Hay llamadas de método que usan otros objetos de receptor, así como argumentos constantes de tipos diferentes.</span><span class="sxs-lookup"><span data-stu-id="376f0-138">There are method calls using other receiver objects, there are constant arguments of different types.</span></span> <span data-ttu-id="376f0-139">Y, por último, hay un operador binario de suma.</span><span class="sxs-lookup"><span data-stu-id="376f0-139">And finally, there is a binary addition operator.</span></span> <span data-ttu-id="376f0-140">Según el tipo de valor devuelto de `SecretSauceFunction()` o `MoreSecretSauce()`, ese operador binario de suma puede ser una llamada de método a un operador de suma invalidado, que se resuelva en una llamada de método estático al operador binario de suma definido para una clase.</span><span class="sxs-lookup"><span data-stu-id="376f0-140">Depending on the return type of `SecretSauceFunction()` or `MoreSecretSauce()`, that binary addition operator may be a method call to an overridden addition operator, resolving to a static method call to the binary addition operator defined for a class.</span></span>

<span data-ttu-id="376f0-141">A pesar de esta aparente complejidad, la expresión anterior crea una estructura de árbol por la que se puede navegar con tanta facilidad como en el primer ejemplo.</span><span class="sxs-lookup"><span data-stu-id="376f0-141">Despite this perceived complexity, the expression above creates a tree structure that can be navigated as easily as the first sample.</span></span> <span data-ttu-id="376f0-142">Puede seguir recorriendo los nodos secundarios para buscar nodos hoja en la expresión.</span><span class="sxs-lookup"><span data-stu-id="376f0-142">You can keep traversing child nodes to find leaf nodes in the expression.</span></span> <span data-ttu-id="376f0-143">Los nodos primarios tendrán referencias a sus elementos secundarios, y cada nodo tiene una propiedad que describe de qué tipo es.</span><span class="sxs-lookup"><span data-stu-id="376f0-143">Parent nodes will have references to their children, and each node has a property that describes what kind of node it is.</span></span>

<span data-ttu-id="376f0-144">La estructura de los árboles de expresiones es muy coherente.</span><span class="sxs-lookup"><span data-stu-id="376f0-144">The structure of an expression tree is very consistent.</span></span> <span data-ttu-id="376f0-145">Una vez que conozca los aspectos básicos, podrá entender incluso el código más complejo cuando esté representado como un árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="376f0-145">Once you've learned the basics, you can understand even the most complex code when it is represented as an expression tree.</span></span> <span data-ttu-id="376f0-146">La elegancia de la estructura de datos explica cómo el compilador de C# puede analizar los programas de C# más complejos y crear resultados correctos a partir de código fuente complicado.</span><span class="sxs-lookup"><span data-stu-id="376f0-146">The elegance in the data structure explains how the C# compiler can analyze the most complex C# programs and create proper output from that complicated source code.</span></span>

<span data-ttu-id="376f0-147">Una vez que esté familiarizado con la estructura de los árboles de expresiones, verá que los conocimientos que ha adquirido le permiten trabajar rápidamente con muchos escenarios más avanzados.</span><span class="sxs-lookup"><span data-stu-id="376f0-147">Once you become familiar with the structure of expression trees, you will find that knowledge you've gained quickly enables you to work with many more and more advanced scenarios.</span></span> <span data-ttu-id="376f0-148">Los árboles de expresiones ofrecen posibilidades increíbles.</span><span class="sxs-lookup"><span data-stu-id="376f0-148">There is incredible power to expression trees.</span></span>

<span data-ttu-id="376f0-149">Además de traducir algoritmos para ejecutarlos en otros entornos, se pueden usar árboles de expresiones para que resulte más fácil escribir algoritmos que inspeccionen el código antes de ejecutarlo.</span><span class="sxs-lookup"><span data-stu-id="376f0-149">In addition to translating algorithms to execute in other environments, expression trees can be used to make it easier to write algorithms that inspect code before executing it.</span></span> <span data-ttu-id="376f0-150">Puede escribir un método cuyos argumentos sean expresiones y, luego, examinar esas expresiones antes de ejecutar el código.</span><span class="sxs-lookup"><span data-stu-id="376f0-150">You can write a method whose arguments are expressions and then examine those expressions before executing the code.</span></span> <span data-ttu-id="376f0-151">El árbol de expresión es una representación completa del código: puede ver los valores de cualquier subexpresión.</span><span class="sxs-lookup"><span data-stu-id="376f0-151">The Expression Tree is a full representation of the code: you can see values of any sub-expression.</span></span>
<span data-ttu-id="376f0-152">Puede ver los nombres de propiedad y método.</span><span class="sxs-lookup"><span data-stu-id="376f0-152">You can see method and property names.</span></span> <span data-ttu-id="376f0-153">Puede ver el valor de las expresiones constantes.</span><span class="sxs-lookup"><span data-stu-id="376f0-153">You can see the value of any constant expressions.</span></span>
<span data-ttu-id="376f0-154">También puede convertir un árbol de expresión en un delegado ejecutable y ejecutar el código.</span><span class="sxs-lookup"><span data-stu-id="376f0-154">You can also convert an expression tree into an executable delegate, and execute the code.</span></span>

<span data-ttu-id="376f0-155">Las API de los árboles de expresiones permiten crear árboles que representan casi cualquier construcción de código válida.</span><span class="sxs-lookup"><span data-stu-id="376f0-155">The APIs for Expression Trees enable you to create trees that represent almost any valid code construct.</span></span> <span data-ttu-id="376f0-156">En cambio, para que todo resulte lo más sencillo posible, algunas expresiones de C# no se pueden crear en un árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="376f0-156">However, to keep things as simple as possible, some C# idioms cannot be created in an expression tree.</span></span> <span data-ttu-id="376f0-157">Un ejemplo son las expresiones asincrónicas (mediante las palabras clave `async` y `await`).</span><span class="sxs-lookup"><span data-stu-id="376f0-157">One example is asynchronous expressions (using the `async` and `await` keywords).</span></span> <span data-ttu-id="376f0-158">Si necesita algoritmos asincrónicos, tendría que manipular los objetos `Task` directamente, en lugar de confiar en la compatibilidad del compilador.</span><span class="sxs-lookup"><span data-stu-id="376f0-158">If your needs require asynchronous algorithms, you would need to manipulate the `Task` objects directly, rather than rely on the compiler support.</span></span> <span data-ttu-id="376f0-159">Otro ejemplo es en la creación de bucles.</span><span class="sxs-lookup"><span data-stu-id="376f0-159">Another is in creating loops.</span></span> <span data-ttu-id="376f0-160">Normalmente, puede crearlos usando bucles `for`, `foreach`, `while` o `do`.</span><span class="sxs-lookup"><span data-stu-id="376f0-160">Typically, you create these by using `for`, `foreach`, `while` or `do` loops.</span></span> <span data-ttu-id="376f0-161">Como verá [más adelante en esta serie](expression-trees-building.md), las API de los árboles de expresiones admiten una expresión de bucle individual, con expresiones `break` y `continue` que controlan la repetición del bucle.</span><span class="sxs-lookup"><span data-stu-id="376f0-161">As you'll see [later in this series](expression-trees-building.md), the APIs for expression trees support a single loop expression, with `break` and `continue` expressions that control repeating the loop.</span></span>

<span data-ttu-id="376f0-162">Lo único lo que no se puede hacer es modificar un árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="376f0-162">The one thing you can't do is modify an expression tree.</span></span>  <span data-ttu-id="376f0-163">Los árboles de expresiones son estructuras de datos inmutables.</span><span class="sxs-lookup"><span data-stu-id="376f0-163">Expression Trees are immutable data structures.</span></span> <span data-ttu-id="376f0-164">Si quiere mutar (cambiar) un árbol de expresión, debe crear un nuevo árbol que sea una copia del original, pero con los cambios que quiera.</span><span class="sxs-lookup"><span data-stu-id="376f0-164">If you want to mutate (change) an expression tree, you must create a new tree that is a copy of the original, but with your desired changes.</span></span>

[<span data-ttu-id="376f0-165">Siguiente: Tipos de marco que admiten árboles de expresión</span><span class="sxs-lookup"><span data-stu-id="376f0-165">Next -- Framework Types Supporting Expression Trees</span></span>](expression-classes.md)
