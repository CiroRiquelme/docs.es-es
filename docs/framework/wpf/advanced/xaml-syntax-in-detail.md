---
title: Detalles de la sintaxis XAML
ms.date: 03/30/2017
helpviewer_keywords:
- XML [WPF], namespaces
- XAML [WPF], parsing of attributes
- parsing of attributes [WPF]
- XAML [WPF], markup extensions
- attached properties [WPF]
- tag syntax [XAML]
- markup extensions [WPF]
- XAML [WPF], object element syntax
- XAML [WPF], syntax terminology
- attached events [WPF]
- lookup semantics [WPF]
- XAML [WPF], attached events
- XAML [WPF], content syntax
- XAML [WPF], lookup semantics
- content syntax [WPF]
- object element syntax [WPF]
- syntax terminology [XAML]
- XAML [WPF], attached properties
- attributes [XAML], parsing
- XAML [WPF], tag syntax
- XAML [WPF], attribute syntax
- property element syntax [WPF]
- terminology [XAML]
- namespaces [WPF], XML
- attribute syntax [XAML]
- XAML [WPF], property element syntax
ms.assetid: 67cce290-ca26-4c41-a797-b68aabc45479
ms.openlocfilehash: 2c6a8662236b614545e7fb8545b7b60e1b08b6bd
ms.sourcegitcommit: f8c36054eab877de4d40a705aacafa2552ce70e9
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 12/31/2019
ms.locfileid: "75559838"
---
# <a name="xaml-syntax-in-detail"></a><span data-ttu-id="76a56-102">Detalles de la sintaxis XAML</span><span class="sxs-lookup"><span data-stu-id="76a56-102">XAML Syntax In Detail</span></span>
<span data-ttu-id="76a56-103">En este tema se definen los términos que se usan para describir los elementos de la sintaxis XAML.</span><span class="sxs-lookup"><span data-stu-id="76a56-103">This topic defines the terms that are used to describe the elements of XAML syntax.</span></span> <span data-ttu-id="76a56-104">Estos términos se usan con frecuencia en el resto de esta documentación, tanto para la documentación de WPF específicamente como para los otros marcos de trabajo que usan XAML o los conceptos básicos de XAML habilitados por la compatibilidad del lenguaje XAML en el nivel System. Xaml.</span><span class="sxs-lookup"><span data-stu-id="76a56-104">These terms are used frequently throughout the remainder of this documentation, both for WPF documentation specifically and for the other frameworks that use XAML or the basic XAML concepts enabled by the XAML language support at the System.Xaml level.</span></span> <span data-ttu-id="76a56-105">En este tema se amplía la terminología básica introducida en el tema [información general sobre XAML (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span><span class="sxs-lookup"><span data-stu-id="76a56-105">This topic expands on the basic terminology introduced in the topic [XAML Overview (WPF)](../../../desktop-wpf/fundamentals/xaml.md).</span></span>  

<a name="the_xaml_language_specification"></a>   
## <a name="the-xaml-language-specification"></a><span data-ttu-id="76a56-106">Especificación del lenguaje XAML</span><span class="sxs-lookup"><span data-stu-id="76a56-106">The XAML Language Specification</span></span>  
 <span data-ttu-id="76a56-107">También se define o se hace referencia a la terminología de sintaxis XAML definida aquí en la especificación del lenguaje XAML.</span><span class="sxs-lookup"><span data-stu-id="76a56-107">The XAML syntax terminology defined here is also defined or referenced within the XAML language specification.</span></span> <span data-ttu-id="76a56-108">XAML es un lenguaje basado en XML y sigue o amplía las reglas estructurales de XML.</span><span class="sxs-lookup"><span data-stu-id="76a56-108">XAML is a language based on XML and follows or expands upon XML structural rules.</span></span> <span data-ttu-id="76a56-109">Parte de la terminología se comparte desde o se basa en la terminología que se usa normalmente al describir el lenguaje XML o el modelo de objetos de documento XML.</span><span class="sxs-lookup"><span data-stu-id="76a56-109">Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML document object model.</span></span>  
  
 <span data-ttu-id="76a56-110">Para obtener más información sobre la especificación del lenguaje XAML, descargue [\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525) desde el centro de descarga de Microsoft.</span><span class="sxs-lookup"><span data-stu-id="76a56-110">For more information about the XAML language specification, download [\[MS-XAML\]](https://go.microsoft.com/fwlink/?LinkId=114525) from the Microsoft Download Center.</span></span>  
  
<a name="xaml_and_clr"></a>   
## <a name="xaml-and-clr"></a><span data-ttu-id="76a56-111">XAML y CLR</span><span class="sxs-lookup"><span data-stu-id="76a56-111">XAML and CLR</span></span>  
 <span data-ttu-id="76a56-112">XAML es un lenguaje de marcado.</span><span class="sxs-lookup"><span data-stu-id="76a56-112">XAML is a markup language.</span></span> <span data-ttu-id="76a56-113">El Common Language Runtime (CLR), tal y como lo implica su nombre, habilita la ejecución en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="76a56-113">The common language runtime (CLR), as implied by its name, enables runtime execution.</span></span> <span data-ttu-id="76a56-114">XAML no es en sí mismo uno de los lenguajes comunes que el Runtime de CLR usa directamente.</span><span class="sxs-lookup"><span data-stu-id="76a56-114">XAML is not by itself one of the common languages that is directly consumed by the CLR runtime.</span></span> <span data-ttu-id="76a56-115">En su lugar, puede considerar XAML como compatible con su propio sistema de tipos.</span><span class="sxs-lookup"><span data-stu-id="76a56-115">Instead, you can think of XAML as supporting its own type system.</span></span> <span data-ttu-id="76a56-116">El sistema de análisis de XAML concreto que usa WPF se basa en CLR y en el sistema de tipos de CLR.</span><span class="sxs-lookup"><span data-stu-id="76a56-116">The particular XAML parsing system that is used by WPF is built on the CLR and the CLR type system.</span></span> <span data-ttu-id="76a56-117">Los tipos XAML se asignan a los tipos de CLR para crear instancias de una representación en tiempo de ejecución cuando se analiza el XAML para WPF.</span><span class="sxs-lookup"><span data-stu-id="76a56-117">XAML types are mapped to CLR types to instantiate a run time representation when the XAML for WPF is parsed.</span></span> <span data-ttu-id="76a56-118">Por esta razón, el resto de la explicación de la sintaxis de este documento incluirá referencias al sistema de tipos de CLR, aunque las discusiones de sintaxis equivalentes en la especificación del lenguaje XAML no lo hacen.</span><span class="sxs-lookup"><span data-stu-id="76a56-118">For this reason, the remainder of discussion of syntax in this document will include references to the CLR type system, even though the equivalent syntax discussions in the XAML language specification do not.</span></span> <span data-ttu-id="76a56-119">(Según el nivel de especificación del lenguaje XAML, los tipos XAML pueden asignarse a cualquier otro sistema de tipos, que no tiene que ser el CLR, pero eso requeriría la creación y el uso de un analizador XAML diferente).</span><span class="sxs-lookup"><span data-stu-id="76a56-119">(Per the XAML language specification level, XAML types could be mapped to any other type system, which does not have to be the CLR, but that would require the creation and use of a different XAML parser.)</span></span>  
  
#### <a name="members-of-types-and-class-inheritance"></a><span data-ttu-id="76a56-120">Miembros de tipos y herencia de clases</span><span class="sxs-lookup"><span data-stu-id="76a56-120">Members of Types and Class Inheritance</span></span>  
 <span data-ttu-id="76a56-121">Las propiedades y los eventos tal como aparecen como miembros XAML de un tipo [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] se suelen heredar de los tipos base.</span><span class="sxs-lookup"><span data-stu-id="76a56-121">Properties and events as they appear as XAML members of a [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] type are often inherited from base types.</span></span> <span data-ttu-id="76a56-122">Por ejemplo, considere este ejemplo: `<Button Background="Blue" .../>`.</span><span class="sxs-lookup"><span data-stu-id="76a56-122">For example, consider this example: `<Button Background="Blue" .../>`.</span></span> <span data-ttu-id="76a56-123">La propiedad <xref:System.Windows.Controls.Control.Background%2A> no es una propiedad declarada inmediatamente en la clase <xref:System.Windows.Controls.Button>, si se va a examinar la definición de clase, los resultados de la reflexión o la documentación.</span><span class="sxs-lookup"><span data-stu-id="76a56-123">The <xref:System.Windows.Controls.Control.Background%2A> property is not an immediately declared property on the <xref:System.Windows.Controls.Button> class, if you were to look at the class definition, reflection results, or the documentation.</span></span> <span data-ttu-id="76a56-124">En su lugar, <xref:System.Windows.Controls.Control.Background%2A> se hereda de la clase base <xref:System.Windows.Controls.Control>.</span><span class="sxs-lookup"><span data-stu-id="76a56-124">Instead, <xref:System.Windows.Controls.Control.Background%2A> is inherited from the base <xref:System.Windows.Controls.Control> class.</span></span>  
  
 <span data-ttu-id="76a56-125">El comportamiento de la herencia de clases de los elementos de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML es una salida significativa de una interpretación impuesta por el esquema del marcado XML.</span><span class="sxs-lookup"><span data-stu-id="76a56-125">The class inheritance behavior of [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML elements is a significant departure from a schema-enforced interpretation of XML markup.</span></span> <span data-ttu-id="76a56-126">La herencia de clases puede ser compleja, especialmente cuando las clases base intermedias son abstractas o cuando intervienen interfaces.</span><span class="sxs-lookup"><span data-stu-id="76a56-126">Class inheritance can become complex, particularly when intermediate base classes are abstract, or when interfaces are involved.</span></span> <span data-ttu-id="76a56-127">Esta es una de las razones por las que el conjunto de elementos XAML y sus atributos permisibles es difícil de representar con precisión y por completo con los tipos de esquema que se suelen usar para la programación XML, como el formato DTD o XSD.</span><span class="sxs-lookup"><span data-stu-id="76a56-127">This is one reason that the set of XAML elements and their permissible attributes is difficult to represent accurately and completely using the schema types that are typically used for XML programming, such as DTD or XSD format.</span></span> <span data-ttu-id="76a56-128">Otra razón es que las características de extensibilidad y asignación de tipos del propio lenguaje XAML impiden la integridad de cualquier representación fija de los tipos y miembros permitidos.</span><span class="sxs-lookup"><span data-stu-id="76a56-128">Another reason is that extensibility and type-mapping features of the XAML language itself preclude completeness of any fixed representation of the permissible types and members.</span></span>  
  
<a name="object_element_syntax"></a>   
## <a name="object-element-syntax"></a><span data-ttu-id="76a56-129">Sintaxis de elemento de objeto</span><span class="sxs-lookup"><span data-stu-id="76a56-129">Object Element Syntax</span></span>  
 <span data-ttu-id="76a56-130">La *Sintaxis de elementos de objeto* es la sintaxis de marcado XAML que crea instancias de una clase o estructura de CLR declarando un elemento XML.</span><span class="sxs-lookup"><span data-stu-id="76a56-130">*Object element syntax* is the XAML markup syntax that instantiates a CLR class or structure by declaring an XML element.</span></span> <span data-ttu-id="76a56-131">Esta sintaxis es similar a la sintaxis de los elementos de otros lenguajes de marcado, como HTML.</span><span class="sxs-lookup"><span data-stu-id="76a56-131">This syntax resembles the element syntax of other markup languages such as HTML.</span></span> <span data-ttu-id="76a56-132">La sintaxis del elemento de objeto comienza con un corchete angular de apertura (\<), seguido inmediatamente del nombre de tipo de la clase o estructura de la que se crea una instancia.</span><span class="sxs-lookup"><span data-stu-id="76a56-132">Object element syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure being instantiated.</span></span> <span data-ttu-id="76a56-133">Cero o más espacios pueden seguir el nombre del tipo, y también se pueden declarar cero o más atributos en el elemento de objeto, con uno o más espacios que separan cada atributo name = "Value".</span><span class="sxs-lookup"><span data-stu-id="76a56-133">Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair.</span></span> <span data-ttu-id="76a56-134">Por último, debe cumplirse una de las siguientes condiciones:</span><span class="sxs-lookup"><span data-stu-id="76a56-134">Finally, one of the following must be true:</span></span>  
  
- <span data-ttu-id="76a56-135">El elemento y la etiqueta deben cerrarse con una barra diagonal (/) seguida inmediatamente de un corchete angular de cierre (>).</span><span class="sxs-lookup"><span data-stu-id="76a56-135">The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).</span></span>  
  
- <span data-ttu-id="76a56-136">La etiqueta de apertura debe completarse con un corchete angular de cierre (>).</span><span class="sxs-lookup"><span data-stu-id="76a56-136">The opening tag must be completed by a right angle bracket (>).</span></span> <span data-ttu-id="76a56-137">Otros elementos de objeto, elementos de propiedad o texto interno, pueden seguir la etiqueta de apertura.</span><span class="sxs-lookup"><span data-stu-id="76a56-137">Other object elements, property elements, or inner text, can follow the opening tag.</span></span> <span data-ttu-id="76a56-138">Exactamente, el contenido que se puede incluir aquí está restringido por el modelo de objetos del elemento.</span><span class="sxs-lookup"><span data-stu-id="76a56-138">Exactly what content may be contained here is typically constrained by the object model of the element.</span></span> <span data-ttu-id="76a56-139">También debe existir la etiqueta de cierre equivalente para el elemento de objeto, en el anidamiento y el equilibrio adecuados con otros pares de etiquetas de apertura y cierre.</span><span class="sxs-lookup"><span data-stu-id="76a56-139">The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.</span></span>  
  
 <span data-ttu-id="76a56-140">XAML, tal y como lo implementa .NET, tiene un conjunto de reglas que asignan elementos de objeto a tipos, atributos en propiedades o eventos, y espacios de nombres XAML a espacios de nombres CLR y ensamblado.</span><span class="sxs-lookup"><span data-stu-id="76a56-140">XAML as implemented by .NET has a set of rules that map object elements into types, attributes into properties or events, and XAML namespaces to CLR namespaces plus assembly.</span></span> <span data-ttu-id="76a56-141">Para WPF y .NET, los elementos de objeto XAML se asignan a los tipos .NET tal y como se definen en los ensamblados a los que se hace referencia, y los atributos se asignan a los miembros de esos tipos.</span><span class="sxs-lookup"><span data-stu-id="76a56-141">For WPF and .NET, XAML object elements map to .NET types as defined in referenced assemblies, and the attributes map to members of those types.</span></span> <span data-ttu-id="76a56-142">Cuando se hace referencia a un tipo CLR en XAML, también se tiene acceso a los miembros heredados de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="76a56-142">When you reference a CLR type in XAML, you have access to the inherited members of that type as well.</span></span>  
  
 <span data-ttu-id="76a56-143">Por ejemplo, el ejemplo siguiente es la sintaxis de elementos de objeto que crea instancias de una nueva instancia de la clase <xref:System.Windows.Controls.Button> y también especifica un atributo <xref:System.Windows.FrameworkElement.Name%2A> y un valor para ese atributo:</span><span class="sxs-lookup"><span data-stu-id="76a56-143">For example, the following example is object element syntax that instantiates a new instance of the <xref:System.Windows.Controls.Button> class, and also specifies a <xref:System.Windows.FrameworkElement.Name%2A> attribute and a value for that attribute:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxOE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxoe)]  
  
 <span data-ttu-id="76a56-144">En el ejemplo siguiente se muestra la sintaxis de elementos de objeto que también incluye sintaxis de propiedad de contenido XAML.</span><span class="sxs-lookup"><span data-stu-id="76a56-144">The following example is object element syntax that also includes XAML content property syntax.</span></span> <span data-ttu-id="76a56-145">El texto interno incluido en se utilizará para establecer la propiedad de contenido de XAML <xref:System.Windows.Controls.TextBox>, <xref:System.Windows.Controls.TextBox.Text%2A>.</span><span class="sxs-lookup"><span data-stu-id="76a56-145">The inner text contained within will be used to set the <xref:System.Windows.Controls.TextBox> XAML content property, <xref:System.Windows.Controls.TextBox.Text%2A>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ThisIsATextBox](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#thisisatextbox)]  
  
### <a name="content-models"></a><span data-ttu-id="76a56-146">Modelos de contenido</span><span class="sxs-lookup"><span data-stu-id="76a56-146">Content Models</span></span>  
 <span data-ttu-id="76a56-147">Una clase podría admitir un uso como elemento de objeto XAML en términos de sintaxis, pero ese elemento solo funcionará correctamente en una aplicación o página cuando se coloca en una posición esperada de un árbol de elementos o un modelo de contenido general.</span><span class="sxs-lookup"><span data-stu-id="76a56-147">A class might support a usage as a XAML object element in terms of the syntax, but that element will only function properly in an application or page when it is placed in an expected position of an overall content model or element tree.</span></span> <span data-ttu-id="76a56-148">Por ejemplo, un <xref:System.Windows.Controls.MenuItem> normalmente solo debe colocarse como elemento secundario de una clase derivada <xref:System.Windows.Controls.Primitives.MenuBase> como <xref:System.Windows.Controls.Menu>.</span><span class="sxs-lookup"><span data-stu-id="76a56-148">For example, a <xref:System.Windows.Controls.MenuItem> should typically only be placed as a child of a <xref:System.Windows.Controls.Primitives.MenuBase> derived class such as <xref:System.Windows.Controls.Menu>.</span></span> <span data-ttu-id="76a56-149">Los modelos de contenido para elementos específicos se documentan como parte de los comentarios en las páginas de clase de los controles y otras clases de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] que se pueden usar como elementos XAML.</span><span class="sxs-lookup"><span data-stu-id="76a56-149">Content models for specific elements are documented as part of the remarks on the class pages for controls and other [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] classes that can be used as XAML elements.</span></span>  
  
<a name="properties_of_object_elements"></a>   
## <a name="properties-of-object-elements"></a><span data-ttu-id="76a56-150">Propiedades de los elementos de objeto</span><span class="sxs-lookup"><span data-stu-id="76a56-150">Properties of Object Elements</span></span>  
 <span data-ttu-id="76a56-151">Las propiedades de XAML se establecen mediante una variedad de posibles sintaxis.</span><span class="sxs-lookup"><span data-stu-id="76a56-151">Properties in XAML are set by a variety of possible syntaxes.</span></span> <span data-ttu-id="76a56-152">La sintaxis que se puede usar para una propiedad determinada variará en función de las características del sistema de tipos subyacentes de la propiedad que se está estableciendo.</span><span class="sxs-lookup"><span data-stu-id="76a56-152">Which syntax can be used for a particular property will vary, based on the underlying type system characteristics of the property that you are setting.</span></span>  
  
 <span data-ttu-id="76a56-153">Al establecer valores de propiedades, se agregan características o características a los objetos tal como existen en el gráfico de objetos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="76a56-153">By setting values of properties, you add features or characteristics to objects as they exist in the run time object graph.</span></span> <span data-ttu-id="76a56-154">El estado inicial del objeto creado a partir de un elemento de objeto se basa en el comportamiento del constructor sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="76a56-154">The initial state of the created object from a object element is based on the parameterless constructor behavior.</span></span> <span data-ttu-id="76a56-155">Normalmente, la aplicación usará algo distinto de una instancia totalmente predeterminada de cualquier objeto dado.</span><span class="sxs-lookup"><span data-stu-id="76a56-155">Typically, your application will use something other than a completely default instance of any given object.</span></span>  
  
<a name="attribute_syntax_properties"></a>   
## <a name="attribute-syntax-properties"></a><span data-ttu-id="76a56-156">Sintaxis de atributos (propiedades)</span><span class="sxs-lookup"><span data-stu-id="76a56-156">Attribute Syntax (Properties)</span></span>  
 <span data-ttu-id="76a56-157">La sintaxis de atributo es la sintaxis de marcado XAML que establece un valor para una propiedad declarando un atributo en un elemento de objeto existente.</span><span class="sxs-lookup"><span data-stu-id="76a56-157">Attribute syntax is the XAML markup syntax that sets a value for a property by declaring an attribute on an existing object element.</span></span> <span data-ttu-id="76a56-158">El nombre del atributo debe coincidir con el nombre del miembro CLR de la propiedad de la clase que respalda el elemento de objeto pertinente.</span><span class="sxs-lookup"><span data-stu-id="76a56-158">The attribute name must match the CLR member name of the property of the class that backs the relevant object element.</span></span> <span data-ttu-id="76a56-159">El nombre del atributo va seguido de un operador de asignación (=).</span><span class="sxs-lookup"><span data-stu-id="76a56-159">The attribute name is followed by an assignment operator (=).</span></span> <span data-ttu-id="76a56-160">El valor de atributo debe ser una cadena entre comillas.</span><span class="sxs-lookup"><span data-stu-id="76a56-160">The attribute value must be a string enclosed within quotes.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="76a56-161">Puede usar comillas alternas para colocar una comilla literal dentro de un atributo.</span><span class="sxs-lookup"><span data-stu-id="76a56-161">You can use alternating quotes to place a literal quotation mark within an attribute.</span></span> <span data-ttu-id="76a56-162">Por ejemplo, puede usar comillas simples como medio para declarar una cadena que contenga un carácter de comilla doble dentro de ella.</span><span class="sxs-lookup"><span data-stu-id="76a56-162">For instance you can use single quotes as a means to declare a string that contains a double quote character within it.</span></span> <span data-ttu-id="76a56-163">Tanto si usa comillas simples como dobles, debe utilizar un par coincidente para abrir y cerrar la cadena de valor de atributo.</span><span class="sxs-lookup"><span data-stu-id="76a56-163">Whether you use single or double quotes, you should use a matching pair for opening and closing the attribute value string.</span></span> <span data-ttu-id="76a56-164">También hay secuencias de escape u otras técnicas disponibles para trabajar en torno a las restricciones de caracteres impuesta por cualquier sintaxis XAML determinada.</span><span class="sxs-lookup"><span data-stu-id="76a56-164">There are also escape sequences or other techniques available for working around character restrictions imposed by any particular XAML syntax.</span></span> <span data-ttu-id="76a56-165">Vea [entidades de caracteres XML y XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span><span class="sxs-lookup"><span data-stu-id="76a56-165">See [XML Character Entities and XAML](../../../desktop-wpf/xaml-services/xml-character-entities.md).</span></span>  
  
 <span data-ttu-id="76a56-166">Para establecerse mediante la sintaxis de atributo, una propiedad debe ser pública y debe poder escribirse.</span><span class="sxs-lookup"><span data-stu-id="76a56-166">In order to be set through attribute syntax, a property must be public and must be writeable.</span></span> <span data-ttu-id="76a56-167">El valor de la propiedad en el sistema de tipo de respaldo debe ser un tipo de valor, o debe ser un tipo de referencia al que se pueda crear una instancia o hacer referencia a él mediante un procesador XAML al tener acceso al tipo de respaldo pertinente.</span><span class="sxs-lookup"><span data-stu-id="76a56-167">The value of the property in the backing type system must be a value type, or must be a reference type that can be instantiated or referenced by a XAML processor when accessing the relevant backing type.</span></span>  
  
 <span data-ttu-id="76a56-168">En el caso de los eventos XAML de WPF, el evento al que se hace referencia como el nombre de atributo debe ser público y tener un delegado público.</span><span class="sxs-lookup"><span data-stu-id="76a56-168">For WPF XAML events, the event that is referenced as the attribute name must be public and have a public delegate.</span></span>  
  
 <span data-ttu-id="76a56-169">La propiedad o el evento debe ser un miembro de la clase o estructura de la que se crea una instancia mediante el elemento de objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="76a56-169">The property or event must be a member of the class or structure that is instantiated by the containing object element.</span></span>  
  
### <a name="processing-of-attribute-values"></a><span data-ttu-id="76a56-170">Procesamiento de valores de atributo</span><span class="sxs-lookup"><span data-stu-id="76a56-170">Processing of Attribute Values</span></span>  
 <span data-ttu-id="76a56-171">Un procesador XAML procesa el valor de cadena contenido en las comillas de apertura y cierre.</span><span class="sxs-lookup"><span data-stu-id="76a56-171">The string value contained within the opening and closing quotation marks is processed by a XAML processor.</span></span> <span data-ttu-id="76a56-172">En el caso de las propiedades, el comportamiento de procesamiento predeterminado viene determinado por el tipo de la propiedad CLR subyacente.</span><span class="sxs-lookup"><span data-stu-id="76a56-172">For properties, the default processing behavior is determined by the type of the underlying CLR property.</span></span>  
  
 <span data-ttu-id="76a56-173">El valor del atributo se rellena con uno de los siguientes elementos, mediante este orden de procesamiento:</span><span class="sxs-lookup"><span data-stu-id="76a56-173">The attribute value is filled by one of the following, using this processing order:</span></span>  
  
1. <span data-ttu-id="76a56-174">Si el procesador XAML encuentra una llave, o un elemento de objeto que se deriva de <xref:System.Windows.Markup.MarkupExtension>, la extensión de marcado a la que se hace referencia se evalúa primero en lugar de procesar el valor como una cadena, y el objeto devuelto por la extensión de marcado se utiliza como valor.</span><span class="sxs-lookup"><span data-stu-id="76a56-174">If the XAML processor encounters a curly brace, or an object element that derives from <xref:System.Windows.Markup.MarkupExtension>, then the referenced markup extension is evaluated first rather than processing the value as a string, and the object returned by the markup extension is used as the value.</span></span> <span data-ttu-id="76a56-175">En muchos casos, el objeto devuelto por una extensión de marcado es una referencia a un objeto existente, o una expresión que aplaza la evaluación hasta el tiempo de ejecución, y no es un objeto recién creado.</span><span class="sxs-lookup"><span data-stu-id="76a56-175">In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until run time, and is not a newly instantiated object.</span></span>  
  
2. <span data-ttu-id="76a56-176">Si la propiedad se declara con un <xref:System.ComponentModel.TypeConverter>con atributos, o el tipo de valor de esa propiedad se declara con un <xref:System.ComponentModel.TypeConverter>con atributos, el valor de cadena del atributo se envía al convertidor de tipos como una entrada de conversión y el convertidor devolverá una nueva instancia de objeto.</span><span class="sxs-lookup"><span data-stu-id="76a56-176">If the property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, or the value type of that property is declared with an attributed <xref:System.ComponentModel.TypeConverter>, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.</span></span>  
  
3. <span data-ttu-id="76a56-177">Si no hay ningún <xref:System.ComponentModel.TypeConverter>, se intenta realizar una conversión directa al tipo de propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-177">If there is no <xref:System.ComponentModel.TypeConverter>, a direct conversion to the property type is attempted.</span></span> <span data-ttu-id="76a56-178">Este último nivel es una conversión directa en el valor de analizador-nativo entre los tipos primitivos del lenguaje XAML o una comprobación de los nombres de las constantes con nombre en una enumeración (el analizador accede a los valores coincidentes).</span><span class="sxs-lookup"><span data-stu-id="76a56-178">This final level is a direct conversion at the parser-native value between XAML language primitive types, or a check for the names of named constants in an enumeration (the parser then accesses the matching values).</span></span>  
  
#### <a name="enumeration-attribute-values"></a><span data-ttu-id="76a56-179">Valores de atributo de enumeración</span><span class="sxs-lookup"><span data-stu-id="76a56-179">Enumeration Attribute Values</span></span>  
 <span data-ttu-id="76a56-180">Los analizadores XAML procesan de forma intrínseca las enumeraciones en XAML y los miembros de una enumeración se deben especificar especificando el nombre de cadena de una de las constantes con nombre de la enumeración.</span><span class="sxs-lookup"><span data-stu-id="76a56-180">Enumerations in XAML are processed intrinsically by XAML parsers, and the members of an enumeration should be specified by specifying the string name of one of the enumeration's named constants.</span></span>  
  
 <span data-ttu-id="76a56-181">En el caso de los valores de enumeración que no son de marcador, el comportamiento nativo es procesar la cadena de un valor de atributo y resolverlo en uno de los valores de enumeración.</span><span class="sxs-lookup"><span data-stu-id="76a56-181">For nonflag enumeration values, the native behavior is to process the string of an attribute value and resolve it to one of the enumeration values.</span></span> <span data-ttu-id="76a56-182">No se especifica la enumeración en la *enumeración*de formato. *Valor*, como se hace en el código.</span><span class="sxs-lookup"><span data-stu-id="76a56-182">You do not specify the enumeration in the format *Enumeration*.*Value*, as you do in code.</span></span> <span data-ttu-id="76a56-183">En su lugar, solo se especifica el *valor*y la *enumeración* se deduce por el tipo de la propiedad que se establece.</span><span class="sxs-lookup"><span data-stu-id="76a56-183">Instead, you specify only *Value*, and *Enumeration* is inferred by the type of the property you are setting.</span></span> <span data-ttu-id="76a56-184">Si especifica un atributo en la *enumeración*. Formato de *valor* , no se resolverá correctamente.</span><span class="sxs-lookup"><span data-stu-id="76a56-184">If you specify an attribute in the *Enumeration*.*Value* form, it will not resolve correctly.</span></span>  
  
 <span data-ttu-id="76a56-185">En el caso de las enumeraciones basadas en marcadores, el comportamiento se basa en el método <xref:System.Enum.Parse%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="76a56-185">For flagwise enumerations, the behavior is based on the <xref:System.Enum.Parse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="76a56-186">Puede especificar varios valores para una enumeración basada en marcadores separando cada valor con una coma.</span><span class="sxs-lookup"><span data-stu-id="76a56-186">You can specify multiple values for a flagwise enumeration by separating each value with a comma.</span></span> <span data-ttu-id="76a56-187">Sin embargo, no se pueden combinar valores de enumeración que no estén en marcadores.</span><span class="sxs-lookup"><span data-stu-id="76a56-187">However, you cannot combine enumeration values that are not flagwise.</span></span> <span data-ttu-id="76a56-188">Por ejemplo, no puede usar la sintaxis de coma para intentar crear un <xref:System.Windows.Trigger> que actúe en varias condiciones de una enumeración que no sea de marcador:</span><span class="sxs-lookup"><span data-stu-id="76a56-188">For instance, you cannot use the comma syntax to attempt to create a <xref:System.Windows.Trigger> that acts on multiple conditions of a nonflag enumeration:</span></span>  
  
```xaml  
<!--This will not compile, because Visibility is not a flagwise enumeration.-->  
...  
<Trigger Property="Visibility" Value="Collapsed,Hidden">  
  <Setter ... />  
</Trigger>  
...  
```  
  
 <span data-ttu-id="76a56-189">Las enumeraciones de marcas de marcado que admiten atributos que se pueden establecer en XAML son poco frecuentes en WPF.</span><span class="sxs-lookup"><span data-stu-id="76a56-189">Flagwise enumerations that support attributes that are settable in XAML are rare in WPF.</span></span> <span data-ttu-id="76a56-190">Sin embargo, una enumeración de este tipo es <xref:System.Windows.Media.StyleSimulations>.</span><span class="sxs-lookup"><span data-stu-id="76a56-190">However, one such enumeration is <xref:System.Windows.Media.StyleSimulations>.</span></span> <span data-ttu-id="76a56-191">Podría, por ejemplo, usar la sintaxis de atributo de marcas de tiempo delimitada por comas para modificar el ejemplo proporcionado en las notas de la clase <xref:System.Windows.Documents.Glyphs>; `StyleSimulations = "BoldSimulation"` podría ser `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span><span class="sxs-lookup"><span data-stu-id="76a56-191">You could, for instance, use the comma-delimited flagwise attribute syntax to modify the example provided in the Remarks for the <xref:System.Windows.Documents.Glyphs> class; `StyleSimulations = "BoldSimulation"` could become `StyleSimulations = "BoldSimulation,ItalicSimulation"`.</span></span> <span data-ttu-id="76a56-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> es otra propiedad en la que se puede especificar más de un valor de enumeración.</span><span class="sxs-lookup"><span data-stu-id="76a56-192"><xref:System.Windows.Input.KeyBinding.Modifiers%2A?displayProperty=nameWithType> is another property where more than one enumeration value can be specified.</span></span> <span data-ttu-id="76a56-193">Sin embargo, esta propiedad es un caso especial, porque la enumeración <xref:System.Windows.Input.ModifierKeys> admite su propio convertidor de tipos.</span><span class="sxs-lookup"><span data-stu-id="76a56-193">However, this property happens to be a special case, because the <xref:System.Windows.Input.ModifierKeys> enumeration supports its own type converter.</span></span> <span data-ttu-id="76a56-194">El convertidor de tipos para los modificadores usa un signo más (+) como delimitador en lugar de una coma (,).</span><span class="sxs-lookup"><span data-stu-id="76a56-194">The type converter for modifiers uses a plus sign (+) as a delimiter rather than a comma (,).</span></span> <span data-ttu-id="76a56-195">Esta conversión admite la sintaxis más tradicional para representar combinaciones de teclas en la programación de Microsoft Windows, como "Ctrl + Alt".</span><span class="sxs-lookup"><span data-stu-id="76a56-195">This conversion supports the more traditional syntax to represent key combinations in Microsoft Windows programming, such as "Ctrl+Alt".</span></span>  
  
### <a name="properties-and-event-member-name-references"></a><span data-ttu-id="76a56-196">Propiedades y referencias de nombres de miembros de eventos</span><span class="sxs-lookup"><span data-stu-id="76a56-196">Properties and Event Member Name References</span></span>  
 <span data-ttu-id="76a56-197">Al especificar un atributo, puede hacer referencia a cualquier propiedad o evento que exista como miembro del tipo CLR del que creó una instancia para el elemento de objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="76a56-197">When specifying an attribute, you can reference any property or event that exists as a member of the CLR type you instantiated for the containing object element.</span></span>  
  
 <span data-ttu-id="76a56-198">O bien, puede hacer referencia a una propiedad adjunta o a un evento adjunto, independientemente del elemento de objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="76a56-198">Or, you can reference an attached property or attached event, independent of the containing object element.</span></span> <span data-ttu-id="76a56-199">(Las propiedades adjuntas se describen en una próxima sección).</span><span class="sxs-lookup"><span data-stu-id="76a56-199">(Attached properties are discussed in an upcoming section.)</span></span>  
  
 <span data-ttu-id="76a56-200">También puede asignar un nombre a cualquier evento de cualquier objeto al que se pueda tener acceso a través del espacio de nombres predeterminado mediante un *TypeName*. nombre parcial del *evento* ; Esta sintaxis admite la Asociación de controladores para eventos enrutados donde el controlador está diseñado para controlar el enrutamiento de eventos de los elementos secundarios, pero el elemento primario no tiene también ese evento en su tabla de miembros.</span><span class="sxs-lookup"><span data-stu-id="76a56-200">You can also name any event from any object that is accessible through the default namespace by using a *typeName*.*event* partially qualified name; this syntax supports attaching handlers for routed events where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table.</span></span> <span data-ttu-id="76a56-201">Esta sintaxis es similar a la sintaxis de un evento adjunto, pero el evento aquí no es un evento adjunto verdadero.</span><span class="sxs-lookup"><span data-stu-id="76a56-201">This syntax resembles an attached event syntax, but the event here is not a true attached event.</span></span> <span data-ttu-id="76a56-202">En su lugar, hace referencia a un evento con un nombre completo.</span><span class="sxs-lookup"><span data-stu-id="76a56-202">Instead, you are referencing an event with a qualified name.</span></span> <span data-ttu-id="76a56-203">Para obtener más información, vea [información general sobre eventos enrutados](routed-events-overview.md).</span><span class="sxs-lookup"><span data-stu-id="76a56-203">For more information, see [Routed Events Overview](routed-events-overview.md).</span></span>  
  
 <span data-ttu-id="76a56-204">En algunos escenarios, a veces se proporcionan nombres de propiedad como el valor de un atributo, en lugar del nombre de atributo.</span><span class="sxs-lookup"><span data-stu-id="76a56-204">For some scenarios, property names are sometimes provided as the value of an attribute, rather than the attribute name.</span></span> <span data-ttu-id="76a56-205">Ese nombre de propiedad también puede incluir calificadores, como la propiedad especificada en el formato *ownerType*. *dependencyPropertyName*.</span><span class="sxs-lookup"><span data-stu-id="76a56-205">That property name can also include qualifiers, such as the property specified in the form *ownerType*.*dependencyPropertyName*.</span></span> <span data-ttu-id="76a56-206">Este escenario es común cuando se escriben estilos o plantillas en XAML.</span><span class="sxs-lookup"><span data-stu-id="76a56-206">This scenario is common when writing styles or templates in XAML.</span></span> <span data-ttu-id="76a56-207">Las reglas de procesamiento para los nombres de propiedad proporcionados como un valor de atributo son diferentes y se rigen por el tipo de la propiedad que se establece o por los comportamientos de subsistemas WPF concretos.</span><span class="sxs-lookup"><span data-stu-id="76a56-207">The processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set or by the behaviors of particular WPF subsystems.</span></span> <span data-ttu-id="76a56-208">Para obtener más información, consulte [aplicar estilos y plantillas](../controls/styling-and-templating.md).</span><span class="sxs-lookup"><span data-stu-id="76a56-208">For details, see [Styling and Templating](../controls/styling-and-templating.md).</span></span>  
  
 <span data-ttu-id="76a56-209">Otro uso de los nombres de propiedad es cuando un valor de atributo describe una relación propiedad-propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-209">Another usage for property names is when an attribute value describes a property-property relationship.</span></span> <span data-ttu-id="76a56-210">Esta característica se usa para el enlace de datos y para los destinos de guion gráfico, y está habilitada por la clase <xref:System.Windows.PropertyPath> y su convertidor de tipos.</span><span class="sxs-lookup"><span data-stu-id="76a56-210">This feature is used for data binding and for storyboard targets, and is enabled by the <xref:System.Windows.PropertyPath> class and its type converter.</span></span> <span data-ttu-id="76a56-211">Para obtener una descripción más completa de la semántica de búsqueda, consulte [sintaxis XAML de PropertyPath](propertypath-xaml-syntax.md).</span><span class="sxs-lookup"><span data-stu-id="76a56-211">For a more complete description of the lookup semantics, see [PropertyPath XAML Syntax](propertypath-xaml-syntax.md).</span></span>  
  
<a name="property_element_syntax"></a>   
## <a name="property-element-syntax"></a><span data-ttu-id="76a56-212">Sintaxis de elementos de propiedad</span><span class="sxs-lookup"><span data-stu-id="76a56-212">Property Element Syntax</span></span>  
 <span data-ttu-id="76a56-213">La *Sintaxis de elementos de propiedad* es una sintaxis que difiere ligeramente de las reglas de sintaxis XML básicas para los elementos.</span><span class="sxs-lookup"><span data-stu-id="76a56-213">*Property element syntax* is a syntax that diverges somewhat from the basic XML syntax rules for elements.</span></span> <span data-ttu-id="76a56-214">En XML, el valor de un atributo es una cadena de hecho, con la única variación posible en que se usa el formato de codificación de cadenas.</span><span class="sxs-lookup"><span data-stu-id="76a56-214">In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used.</span></span> <span data-ttu-id="76a56-215">En XAML, puede asignar otros elementos de objeto para que sea el valor de una propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-215">In XAML, you can assign other object elements to be the value of a property.</span></span> <span data-ttu-id="76a56-216">Esta funcionalidad está habilitada por la sintaxis del elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-216">This capability is enabled by the property element syntax.</span></span> <span data-ttu-id="76a56-217">En lugar de especificar la propiedad como un atributo dentro de la etiqueta de elemento, la propiedad se especifica mediante una etiqueta de elemento de apertura en *elementTypeName*. formulario *PropertyName* , el valor de la propiedad se especifica en y, a continuación, se cierra el elemento Property.</span><span class="sxs-lookup"><span data-stu-id="76a56-217">Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in *elementTypeName*.*propertyName* form, the value of the property is specified within, and then the property element is closed.</span></span>  
  
 <span data-ttu-id="76a56-218">En concreto, la sintaxis comienza con un corchete angular de apertura (\<), seguido inmediatamente del nombre de tipo de la clase o estructura en la que se encuentra la sintaxis del elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-218">Specifically, the syntax begins with a left angle bracket (\<), followed immediately by the type name of the class or structure that the property element syntax is contained within.</span></span> <span data-ttu-id="76a56-219">Va seguido inmediatamente de un punto (.), después por el nombre de una propiedad y, después, por un corchete angular de cierre (>).</span><span class="sxs-lookup"><span data-stu-id="76a56-219">This is followed immediately by a single dot (.), then by the name of a property, then by a right angle bracket (>).</span></span> <span data-ttu-id="76a56-220">Como con la sintaxis de atributo, esa propiedad debe existir dentro de los miembros públicos declarados del tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="76a56-220">As with attribute syntax, that property must exist within the declared public members of the specified type.</span></span> <span data-ttu-id="76a56-221">El valor que se va a asignar a la propiedad se encuentra dentro del elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-221">The value to be assigned to the property is contained within the property element.</span></span> <span data-ttu-id="76a56-222">Normalmente, el valor se proporciona como uno o varios elementos de objeto, porque la especificación de objetos como valores es el escenario que la sintaxis del elemento de propiedad está pensada para solucionar.</span><span class="sxs-lookup"><span data-stu-id="76a56-222">Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address.</span></span> <span data-ttu-id="76a56-223">Por último, una etiqueta de cierre equivalente que especifica el mismo *elementTypeName*. se debe proporcionar la combinación *PropertyName* , en el anidamiento y el equilibrio adecuados con otras etiquetas de elemento.</span><span class="sxs-lookup"><span data-stu-id="76a56-223">Finally, an equivalent closing tag specifying the same *elementTypeName*.*propertyName* combination must be provided, in proper nesting and balance with other element tags.</span></span>  
  
 <span data-ttu-id="76a56-224">Por ejemplo, la siguiente sintaxis de elementos de propiedad para la propiedad <xref:System.Windows.FrameworkElement.ContextMenu%2A> de una <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="76a56-224">For example, the following is property element syntax for the <xref:System.Windows.FrameworkElement.ContextMenu%2A> property of a <xref:System.Windows.Controls.Button>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#ContextMenu](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#contextmenu)]  
  
 <span data-ttu-id="76a56-225">También se puede proporcionar el valor de un elemento de propiedad como texto interno, en los casos en los que el tipo de propiedad que se especifica es un tipo de valor primitivo, como <xref:System.String>, o una enumeración en la que se especifica un nombre.</span><span class="sxs-lookup"><span data-stu-id="76a56-225">The value within a property element can also be given as inner text, in cases where the property type being specified is a primitive value type, such as <xref:System.String>, or an enumeration where a name is specified.</span></span> <span data-ttu-id="76a56-226">Estos dos usos son algo poco frecuentes, ya que cada uno de estos casos también podría usar una sintaxis de atributo más sencilla.</span><span class="sxs-lookup"><span data-stu-id="76a56-226">These two usages are somewhat uncommon, because each of these cases could also use a simpler attribute syntax.</span></span> <span data-ttu-id="76a56-227">Un escenario para rellenar un elemento de propiedad con una cadena es para las propiedades que no son la propiedad de contenido XAML pero que se usan para la representación del texto de la interfaz de usuario, y se requiere que los elementos de espacio en blanco, como los avances de tecla, aparezcan en ese texto de la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="76a56-227">One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular white-space elements such as linefeeds are required to appear in that UI text.</span></span> <span data-ttu-id="76a56-228">La sintaxis de atributo no puede conservar los saltos de tecla, pero la sintaxis de los elementos de propiedad puede, siempre que esté activa la preservación de espacio en blanco significativa (para obtener más información, vea [procesamiento de espacios en blanco en XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span><span class="sxs-lookup"><span data-stu-id="76a56-228">Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant white-space preservation is active (for details, see [White space processing in XAML](../../../desktop-wpf/xaml-services/white-space-processing.md)).</span></span> <span data-ttu-id="76a56-229">Otro escenario es para que la [Directiva x:UID](../../../desktop-wpf/xaml-services/xuid-directive.md) se pueda aplicar al elemento de propiedad y, por tanto, marque el valor de como un valor que debe localizarse en el BAML de salida de WPF o en otras técnicas.</span><span class="sxs-lookup"><span data-stu-id="76a56-229">Another scenario is so that [x:Uid Directive](../../../desktop-wpf/xaml-services/xuid-directive.md) can be applied to the property element and thus mark the value within as a value that should be localized in the WPF output BAML or by other techniques.</span></span>  
  
 <span data-ttu-id="76a56-230">Un elemento de propiedad no se representa en el árbol lógico de WPF.</span><span class="sxs-lookup"><span data-stu-id="76a56-230">A property element is not represented in the WPF logical tree.</span></span> <span data-ttu-id="76a56-231">Un elemento Property es simplemente una sintaxis determinada para establecer una propiedad, y no es un elemento que tiene una instancia o un objeto que realiza la copia de seguridad.</span><span class="sxs-lookup"><span data-stu-id="76a56-231">A property element is just a particular syntax for setting a property, and is not an element that has an instance or object backing it.</span></span> <span data-ttu-id="76a56-232">(Para obtener más información sobre el concepto de árbol lógico, consulte [árboles en WPF](trees-in-wpf.md)).</span><span class="sxs-lookup"><span data-stu-id="76a56-232">(For details on the logical tree concept, see [Trees in WPF](trees-in-wpf.md).)</span></span>  
  
 <span data-ttu-id="76a56-233">En el caso de las propiedades en las que se admiten la sintaxis de elementos de atributo y de propiedad, las dos sintaxis suelen tener el mismo resultado, aunque los matices como el control de los espacios en blanco pueden variar ligeramente entre las sintaxis.</span><span class="sxs-lookup"><span data-stu-id="76a56-233">For properties where both attribute and property element syntax are supported, the two syntaxes generally have the same result, although subtleties such as white-space handling can vary slightly between syntaxes.</span></span>  
  
<a name="collection_syntax"></a>   
## <a name="collection-syntax"></a><span data-ttu-id="76a56-234">Sintaxis de colecciones</span><span class="sxs-lookup"><span data-stu-id="76a56-234">Collection Syntax</span></span>  
 <span data-ttu-id="76a56-235">La especificación XAML requiere implementaciones de procesador XAML para identificar las propiedades en las que el tipo de valor es una colección.</span><span class="sxs-lookup"><span data-stu-id="76a56-235">The XAML specification requires XAML processor implementations to identify properties where the value type is a collection.</span></span> <span data-ttu-id="76a56-236">La implementación del procesador XAML general en .NET se basa en el código administrado y en el CLR, e identifica los tipos de colección mediante una de las siguientes acciones:</span><span class="sxs-lookup"><span data-stu-id="76a56-236">The general XAML processor implementation in .NET is based on managed code and the CLR, and it identifies collection types through one of the following:</span></span>  
  
- <span data-ttu-id="76a56-237">El tipo implementa <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="76a56-237">Type implements <xref:System.Collections.IList>.</span></span>  
  
- <span data-ttu-id="76a56-238">El tipo implementa <xref:System.Collections.IDictionary>.</span><span class="sxs-lookup"><span data-stu-id="76a56-238">Type implements <xref:System.Collections.IDictionary>.</span></span>  
  
- <span data-ttu-id="76a56-239">El tipo deriva de <xref:System.Array> (para obtener más información sobre las matrices en XAML, consulte [extensión de marcado x:Array](../../../desktop-wpf/xaml-services/xarray-markup-extension.md)).</span><span class="sxs-lookup"><span data-stu-id="76a56-239">Type derives from <xref:System.Array> (for more information about arrays in XAML, see [x:Array Markup Extension](../../../desktop-wpf/xaml-services/xarray-markup-extension.md).)</span></span>  
  
 <span data-ttu-id="76a56-240">Si el tipo de una propiedad es una colección, no es necesario especificar el tipo de colección deducido en el marcado como un elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="76a56-240">If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup as an object element.</span></span> <span data-ttu-id="76a56-241">En su lugar, los elementos que se van a convertir en elementos de la colección se especifican como uno o varios elementos secundarios del elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-241">Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the property element.</span></span> <span data-ttu-id="76a56-242">Cada elemento de este tipo se evalúa como un objeto durante la carga y se agrega a la colección llamando al método `Add` de la colección implícita.</span><span class="sxs-lookup"><span data-stu-id="76a56-242">Each such item is evaluated to an object during loading and added to the collection by calling the `Add` method of the implied collection.</span></span> <span data-ttu-id="76a56-243">Por ejemplo, la propiedad <xref:System.Windows.Style.Triggers%2A> de <xref:System.Windows.Style> toma el tipo de colección especializado <xref:System.Windows.TriggerCollection>, que implementa <xref:System.Collections.IList>.</span><span class="sxs-lookup"><span data-stu-id="76a56-243">For example, the <xref:System.Windows.Style.Triggers%2A> property of <xref:System.Windows.Style> takes the specialized collection type <xref:System.Windows.TriggerCollection>, which implements <xref:System.Collections.IList>.</span></span> <span data-ttu-id="76a56-244">No es necesario crear una instancia de un elemento de objeto <xref:System.Windows.TriggerCollection> en el marcado.</span><span class="sxs-lookup"><span data-stu-id="76a56-244">It is not necessary to instantiate a <xref:System.Windows.TriggerCollection> object element in the markup.</span></span> <span data-ttu-id="76a56-245">En su lugar, se especifican uno o varios elementos de <xref:System.Windows.Trigger> como elementos dentro del elemento de propiedad `Style.Triggers`, donde <xref:System.Windows.Trigger> (o una clase derivada) es el tipo esperado como el tipo de elemento para la <xref:System.Windows.TriggerCollection>fuertemente tipada e implícita.</span><span class="sxs-lookup"><span data-stu-id="76a56-245">Instead, you specify one or more <xref:System.Windows.Trigger> items as elements within the `Style.Triggers` property element, where <xref:System.Windows.Trigger> (or a derived class) is the type expected as the item type for the strongly typed and implicit <xref:System.Windows.TriggerCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxPECollection](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/Page1.xaml#syntaxpecollection)]  
  
 <span data-ttu-id="76a56-246">Una propiedad puede ser tanto un tipo de colección como la propiedad de contenido XAML para ese tipo y los tipos derivados, que se describe en la sección siguiente de este tema.</span><span class="sxs-lookup"><span data-stu-id="76a56-246">A property may be both a collection type and the XAML content property for that type and derived types, which is discussed in the next section of this topic.</span></span>  
  
 <span data-ttu-id="76a56-247">Un elemento de colección implícito crea un miembro en la representación del árbol lógico, aunque no aparece en el marcado como un elemento.</span><span class="sxs-lookup"><span data-stu-id="76a56-247">An implicit collection element creates a member in the logical tree representation, even though it does not appear in the markup as an element.</span></span> <span data-ttu-id="76a56-248">Normalmente, el constructor del tipo primario realiza la creación de instancias para la colección que es una de sus propiedades, y la colección inicialmente vacía se convierte en parte del árbol de objetos.</span><span class="sxs-lookup"><span data-stu-id="76a56-248">Usually the constructor of the parent type performs the instantiation for the collection that is one of its properties, and the initially empty collection becomes part of the object tree.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="76a56-249">La lista genérica y las interfaces de diccionario (<xref:System.Collections.Generic.IList%601> y <xref:System.Collections.Generic.IDictionary%602>) no se admiten para la detección de colecciones.</span><span class="sxs-lookup"><span data-stu-id="76a56-249">The generic list and dictionary interfaces (<xref:System.Collections.Generic.IList%601> and <xref:System.Collections.Generic.IDictionary%602>) are not supported for collection detection.</span></span> <span data-ttu-id="76a56-250">Sin embargo, puede usar la clase <xref:System.Collections.Generic.List%601> como una clase base, porque implementa <xref:System.Collections.IList> directamente o <xref:System.Collections.Generic.Dictionary%602> como una clase base, porque implementa <xref:System.Collections.IDictionary> directamente.</span><span class="sxs-lookup"><span data-stu-id="76a56-250">However, you can use the <xref:System.Collections.Generic.List%601> class as a base class, because it implements <xref:System.Collections.IList> directly, or <xref:System.Collections.Generic.Dictionary%602> as a base class, because it implements <xref:System.Collections.IDictionary> directly.</span></span>  
  
 <span data-ttu-id="76a56-251">En las páginas de referencia de .NET para los tipos de colección, en ocasiones se anota esta sintaxis con la omisión intencional del elemento de objeto de una colección en las secciones de sintaxis de XAML como sintaxis de colección implícita.</span><span class="sxs-lookup"><span data-stu-id="76a56-251">In the .NET Reference pages for collection types, this syntax with the deliberate omission of the object element for a collection is occasionally noted in the XAML syntax sections as Implicit Collection Syntax.</span></span>  
  
 <span data-ttu-id="76a56-252">A excepción del elemento raíz, cada elemento de objeto de un archivo XAML anidado como elemento secundario de otro elemento es realmente un elemento que es uno de los siguientes casos o ambos: un miembro de una propiedad de colección implícita de su elemento primario. , o un elemento que especifica el valor de la propiedad de contenido XAML para el elemento primario (las propiedades de contenido XAML se tratarán en una próxima sección).</span><span class="sxs-lookup"><span data-stu-id="76a56-252">With the exception of the root element, every object element in a XAML file that is nested as a child element of another element is really an element that is one or both of the following cases: a member of an implicit collection property of its parent element, or an element that specifies the value of the XAML content property for the parent element (XAML content properties will be discussed in an upcoming section).</span></span> <span data-ttu-id="76a56-253">En otras palabras, la relación de los elementos primarios y secundarios en una página de marcado es en realidad un objeto único en la raíz, y cada elemento de objeto situado debajo de la raíz es una sola instancia que proporciona un valor de propiedad del elemento primario, o uno de los elementos de una columna lection, que también es un valor de propiedad de tipo de colección del elemento primario.</span><span class="sxs-lookup"><span data-stu-id="76a56-253">In other words, the relationship of parent elements and child elements in a markup page is really a single object at the root, and every object element beneath the root is either a single instance that provides a property value of the parent, or one of the items within a collection that is also a collection-type property value of the parent.</span></span> <span data-ttu-id="76a56-254">Este concepto de raíz única es común con XML y a menudo se refuerza en el comportamiento de las API que cargan XAML como <xref:System.Windows.Markup.XamlReader.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="76a56-254">This single-root concept is common with XML, and is frequently reinforced in the behavior of APIs that load XAML such as <xref:System.Windows.Markup.XamlReader.Load%2A>.</span></span>  
  
 <span data-ttu-id="76a56-255">El ejemplo siguiente es una sintaxis con el elemento Object para una colección (<xref:System.Windows.Media.GradientStopCollection>) especificada explícitamente.</span><span class="sxs-lookup"><span data-stu-id="76a56-255">The following example is a syntax with the object element for a collection (<xref:System.Windows.Media.GradientStopCollection>) specified explicitly.</span></span>  
  
```xaml  
<LinearGradientBrush>  
  <LinearGradientBrush.GradientStops>  
    <GradientStopCollection>  
      <GradientStop Offset="0.0" Color="Red" />  
      <GradientStop Offset="1.0" Color="Blue" />  
    </GradientStopCollection>  
  </LinearGradientBrush.GradientStops>  
</LinearGradientBrush>  
```  
  
 <span data-ttu-id="76a56-256">Tenga en cuenta que no siempre es posible declarar explícitamente la colección.</span><span class="sxs-lookup"><span data-stu-id="76a56-256">Note that it is not always possible to explicitly declare the collection.</span></span> <span data-ttu-id="76a56-257">Por ejemplo, si se intenta declarar <xref:System.Windows.TriggerCollection> explícitamente en el <xref:System.Windows.Style.Triggers%2A> ejemplo anterior, se produciría un error.</span><span class="sxs-lookup"><span data-stu-id="76a56-257">For instance, attempting to declare <xref:System.Windows.TriggerCollection> explicitly in the previously shown <xref:System.Windows.Style.Triggers%2A> example would fail.</span></span> <span data-ttu-id="76a56-258">Declarar explícitamente la colección requiere que la clase de colección admita un constructor sin parámetros y <xref:System.Windows.TriggerCollection> no tenga un constructor sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="76a56-258">Explicitly declaring the collection requires that the collection class must support a parameterless constructor, and <xref:System.Windows.TriggerCollection> does not have a parameterless constructor.</span></span>  
  
<a name="xaml_content_properties"></a>   
## <a name="xaml-content-properties"></a><span data-ttu-id="76a56-259">Propiedades del contenido XAML</span><span class="sxs-lookup"><span data-stu-id="76a56-259">XAML Content Properties</span></span>  
 <span data-ttu-id="76a56-260">La sintaxis de contenido XAML es una sintaxis que solo está habilitada en las clases que especifican el <xref:System.Windows.Markup.ContentPropertyAttribute> como parte de su declaración de clase.</span><span class="sxs-lookup"><span data-stu-id="76a56-260">XAML content syntax is a syntax that is only enabled on classes that specify the <xref:System.Windows.Markup.ContentPropertyAttribute> as part of their class declaration.</span></span> <span data-ttu-id="76a56-261">El <xref:System.Windows.Markup.ContentPropertyAttribute> hace referencia al nombre de la propiedad que es la propiedad de contenido para ese tipo de elemento (incluidas las clases derivadas).</span><span class="sxs-lookup"><span data-stu-id="76a56-261">The <xref:System.Windows.Markup.ContentPropertyAttribute> references the property name that is the content property for that type of element (including derived classes).</span></span> <span data-ttu-id="76a56-262">Cuando lo procesa un procesador XAML, los elementos secundarios o el texto interno que se encuentre entre las etiquetas de apertura y cierre del elemento de objeto se asignarán para ser el valor de la propiedad de contenido XAML para ese objeto.</span><span class="sxs-lookup"><span data-stu-id="76a56-262">When processed by a XAML processor, any child elements or inner text that are found between the opening and closing tags of the object element will be assigned to be the value of the XAML content property for that object.</span></span> <span data-ttu-id="76a56-263">Se permite especificar elementos de propiedad explícitos para la propiedad de contenido, pero este uso no se muestra generalmente en las secciones de sintaxis XAML de la referencia de .NET.</span><span class="sxs-lookup"><span data-stu-id="76a56-263">You are permitted to specify explicit property elements for the content property, but this usage is not generally shown in the XAML syntax sections in the .NET reference.</span></span> <span data-ttu-id="76a56-264">La técnica explícita/verbose tiene un valor ocasional para la claridad de marcado o como una cuestión de estilo de marcado, pero normalmente la intención de una propiedad de contenido es simplificar el marcado para que los elementos que están relacionados de forma intuitiva como primario-secundario se puedan anidar directamente.</span><span class="sxs-lookup"><span data-stu-id="76a56-264">The explicit/verbose technique has occasional value for markup clarity or as a matter of markup style, but usually the intent of a content property is to streamline the markup so that elements that are intuitively related as parent-child can be nested directly.</span></span> <span data-ttu-id="76a56-265">Las etiquetas de elemento de propiedad de otras propiedades de un elemento no se asignan como "Content" por una definición de lenguaje XAML estricta; se procesan previamente en el orden de procesamiento del analizador de XAML y no se consideran "contenido".</span><span class="sxs-lookup"><span data-stu-id="76a56-265">Property element tags for other properties on an element are not assigned as "content" per a strict XAML language definition; they are processed previously in the XAML parser's processing order and are not considered to be "content".</span></span>  
  
### <a name="xaml-content-property-values-must-be-contiguous"></a><span data-ttu-id="76a56-266">Los valores de propiedad de contenido XAML deben ser contiguos</span><span class="sxs-lookup"><span data-stu-id="76a56-266">XAML Content Property Values Must Be Contiguous</span></span>  
 <span data-ttu-id="76a56-267">El valor de una propiedad de contenido XAML se debe proporcionar en su totalidad antes o por completo después de cualquier otro elemento de propiedad de ese elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="76a56-267">The value of a XAML content property must be given either entirely before or entirely after any other property elements on that object element.</span></span> <span data-ttu-id="76a56-268">Esto es así si el valor de una propiedad de contenido XAML se especifica como una cadena o como uno o más objetos.</span><span class="sxs-lookup"><span data-stu-id="76a56-268">This is true whether the value of a XAML content property is specified as a string, or as one or more objects.</span></span> <span data-ttu-id="76a56-269">Por ejemplo, el marcado siguiente no se analiza:</span><span class="sxs-lookup"><span data-stu-id="76a56-269">For example, the following markup does not parse:</span></span>  
  
```xaml  
<Button>I am a   
  <Button.Background>Blue</Button.Background>  
  blue button</Button>  
```  
  
 <span data-ttu-id="76a56-270">Esto no es válido básicamente porque si esta sintaxis se hizo explícita mediante la sintaxis de elementos de propiedad para la propiedad de contenido, la propiedad de contenido se establecería dos veces:</span><span class="sxs-lookup"><span data-stu-id="76a56-270">This is illegal essentially because if this syntax were made explicit by using property element syntax for the content property, then the content property would be set twice:</span></span>  
  
```xaml  
<Button>  
  <Button.Content>I am a </Button.Content>  
  <Button.Background>Blue</Button.Background>  
  <Button.Content> blue button</Button.Content>  
</Button>  
```  
  
 <span data-ttu-id="76a56-271">Un ejemplo no válido similar es si la propiedad de contenido es una colección y los elementos secundarios se intercalan con elementos de propiedad:</span><span class="sxs-lookup"><span data-stu-id="76a56-271">A similarly illegal example is if the content property is a collection, and child elements are interspersed with property elements:</span></span>  
  
```xaml  
<StackPanel>  
  <Button>This example</Button>  
  <StackPanel.Resources>  
    <SolidColorBrush x:Key="BlueBrush" Color="Blue"/>  
  </StackPanel.Resources>  
  <Button>... is illegal XAML</Button>  
</StackPanel>  
```  
  
<a name="content_properties_and_collection_syntax_combined"></a>   
## <a name="content-properties-and-collection-syntax-combined"></a><span data-ttu-id="76a56-272">Propiedades de contenido y sintaxis de colección combinadas</span><span class="sxs-lookup"><span data-stu-id="76a56-272">Content Properties and Collection Syntax Combined</span></span>  
 <span data-ttu-id="76a56-273">Para aceptar más de un elemento de objeto único como contenido, el tipo de la propiedad de contenido debe ser específicamente un tipo de colección.</span><span class="sxs-lookup"><span data-stu-id="76a56-273">In order to accept more than a single object element as content, the type of the content property must specifically be a collection type.</span></span> <span data-ttu-id="76a56-274">De forma similar a la sintaxis de elementos de propiedad para los tipos de colección, un procesador XAML debe identificar tipos que son tipos de colección.</span><span class="sxs-lookup"><span data-stu-id="76a56-274">Similar to property element syntax for collection types, a XAML processor must identify types that are collection types.</span></span> <span data-ttu-id="76a56-275">Si un elemento tiene una propiedad de contenido XAML y el tipo de la propiedad de contenido XAML es una colección, no es necesario especificar el tipo de colección implícito en el marcado como un elemento de objeto y no es necesario especificar la propiedad de contenido XAML como la propiedad ependen.</span><span class="sxs-lookup"><span data-stu-id="76a56-275">If an element has a XAML content property and the type of the XAML content property is a collection, then the implied collection type does not need to be specified in the markup as an object element and the XAML content property does not need to be specified as a property element.</span></span> <span data-ttu-id="76a56-276">Por lo tanto, el modelo de contenido aparente en el marcado ahora puede tener más de un elemento secundario asignado como contenido.</span><span class="sxs-lookup"><span data-stu-id="76a56-276">Therefore the apparent content model in the markup can now have more than one child element assigned as the content.</span></span> <span data-ttu-id="76a56-277">La siguiente es la sintaxis de contenido para una clase derivada de <xref:System.Windows.Controls.Panel>.</span><span class="sxs-lookup"><span data-stu-id="76a56-277">The following is content syntax for a <xref:System.Windows.Controls.Panel> derived class.</span></span> <span data-ttu-id="76a56-278">Todas las clases derivadas de <xref:System.Windows.Controls.Panel> establecen la propiedad de contenido XAML para que se <xref:System.Windows.Controls.Panel.Children%2A>, lo que requiere un valor de tipo <xref:System.Windows.Controls.UIElementCollection>.</span><span class="sxs-lookup"><span data-stu-id="76a56-278">All <xref:System.Windows.Controls.Panel> derived classes establish the XAML content property to be <xref:System.Windows.Controls.Panel.Children%2A>, which requires a value of type <xref:System.Windows.Controls.UIElementCollection>.</span></span>  
  
 [!code-xaml[XAMLOvwSupport#SyntaxContent](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page5.xaml#syntaxcontent)]  
  
 <span data-ttu-id="76a56-279">Tenga en cuenta que no se requiere ni el elemento de propiedad para <xref:System.Windows.Controls.Panel.Children%2A> ni el elemento del <xref:System.Windows.Controls.UIElementCollection> en el marcado.</span><span class="sxs-lookup"><span data-stu-id="76a56-279">Note that neither the property element for <xref:System.Windows.Controls.Panel.Children%2A> nor the element for the <xref:System.Windows.Controls.UIElementCollection> is required in the markup.</span></span> <span data-ttu-id="76a56-280">Se trata de una característica de diseño de XAML para que los elementos contenidos de forma recursiva que definen un [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] se representen de forma más intuitiva como un árbol de elementos anidados con relaciones de elementos primarios y secundarios inmediatas, sin intervenir de etiquetas de elementos de propiedad ni objetos de colección.</span><span class="sxs-lookup"><span data-stu-id="76a56-280">This is a design feature of XAML so that recursively contained elements that define a [!INCLUDE[TLA2#tla_ui](../../../../includes/tla2sharptla-ui-md.md)] are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without intervening property element tags or collection objects.</span></span> <span data-ttu-id="76a56-281">De hecho, no se puede especificar <xref:System.Windows.Controls.UIElementCollection> explícitamente en el marcado como un elemento de objeto, por diseño.</span><span class="sxs-lookup"><span data-stu-id="76a56-281">In fact, <xref:System.Windows.Controls.UIElementCollection> cannot be specified explicitly in markup as an object element, by design.</span></span> <span data-ttu-id="76a56-282">Dado que su único uso previsto es como una colección implícita, <xref:System.Windows.Controls.UIElementCollection> no expone un constructor sin parámetros público y, por tanto, no se pueden crear instancias como un elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="76a56-282">Because its only intended use is as an implicit collection, <xref:System.Windows.Controls.UIElementCollection> does not expose a public parameterless constructor and thus cannot be instantiated as an object element.</span></span>  
  
### <a name="mixing-property-elements-and-object-elements-in-an-object-with-a-content-property"></a><span data-ttu-id="76a56-283">Combinar elementos de propiedad y elementos de objeto en un objeto con una propiedad de contenido</span><span class="sxs-lookup"><span data-stu-id="76a56-283">Mixing Property Elements and Object Elements in an Object with a Content Property</span></span>  
 <span data-ttu-id="76a56-284">La especificación XAML declara que un procesador XAML puede exigir que los elementos de objeto que se usan para rellenar la propiedad de contenido XAML dentro de un elemento de objeto deben ser contiguos y no deben ser mixtos.</span><span class="sxs-lookup"><span data-stu-id="76a56-284">The XAML specification declares that a XAML processor can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed.</span></span> <span data-ttu-id="76a56-285">Esta restricción contra la combinación de elementos y contenido de propiedad se aplica mediante el [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] procesadores XAML.</span><span class="sxs-lookup"><span data-stu-id="76a56-285">This restriction against mixing property elements and content is enforced by the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] XAML processors.</span></span>  
  
 <span data-ttu-id="76a56-286">Puede tener un elemento de objeto secundario como el primer marcado inmediato dentro de un elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="76a56-286">You can have a child object element as the first immediate markup within an object element.</span></span> <span data-ttu-id="76a56-287">A continuación, puede introducir elementos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-287">Then you can introduce property elements.</span></span> <span data-ttu-id="76a56-288">O bien, puede especificar uno o varios elementos de propiedad, el contenido y, después, más elementos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-288">Or, you can specify one or more property elements, then content, then more property elements.</span></span> <span data-ttu-id="76a56-289">Pero una vez que un elemento de propiedad sigue contenido, no puede introducir más contenido, solo puede agregar elementos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-289">But once a property element follows content, you cannot introduce any further content, you can only add property elements.</span></span>  
  
 <span data-ttu-id="76a56-290">Este requisito de orden de elementos de contenido/propiedad no se aplica al texto interno que se usa como contenido.</span><span class="sxs-lookup"><span data-stu-id="76a56-290">This content / property element order requirement does not apply to inner text used as content.</span></span> <span data-ttu-id="76a56-291">Sin embargo, sigue siendo un buen estilo de marcado para mantener el texto interno contiguo, ya que el espacio en blanco significativo será difícil de detectar visualmente en el marcado si los elementos de propiedad se intercalan con texto interno.</span><span class="sxs-lookup"><span data-stu-id="76a56-291">However, it is still a good markup style to keep inner text contiguous, because significant white space will be difficult to detect visually in the markup if property elements are interspersed with inner text.</span></span>  
  
<a name="xaml_namespaces"></a>   
## <a name="xaml-namespaces"></a><span data-ttu-id="76a56-292">Espacios de nombres XAML</span><span class="sxs-lookup"><span data-stu-id="76a56-292">XAML Namespaces</span></span>  
 <span data-ttu-id="76a56-293">Ninguno de los ejemplos de sintaxis anteriores especificaba un espacio de nombres XAML distinto del espacio de nombres XAML predeterminado.</span><span class="sxs-lookup"><span data-stu-id="76a56-293">None of the preceding syntax examples specified a XAML namespace other than the default XAML namespace.</span></span> <span data-ttu-id="76a56-294">En las aplicaciones de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] típicas, se especifica que el espacio de nombres XAML predeterminado sea el espacio de nombres [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="76a56-294">In typical [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] applications, the default XAML namespace is specified to be the [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] namespace.</span></span> <span data-ttu-id="76a56-295">Puede especificar espacios de nombres XAML distintos del espacio de nombres XAML predeterminado y seguir usando una sintaxis similar.</span><span class="sxs-lookup"><span data-stu-id="76a56-295">You can specify XAML namespaces other than the default XAML namespace and still use similar syntax.</span></span> <span data-ttu-id="76a56-296">Pero después, en cualquier lugar donde se llame a una clase que no sea accesible dentro del espacio de nombres XAML predeterminado, ese nombre de clase debe ir precedido del prefijo del espacio de nombres XAML asignado al espacio de nombres CLR correspondiente.</span><span class="sxs-lookup"><span data-stu-id="76a56-296">But then, anywhere where a class is named that is not accessible within the default XAML namespace, that class name must be preceded with the prefix of the XAML namespace as mapped to the corresponding CLR namespace.</span></span> <span data-ttu-id="76a56-297">Por ejemplo, `<custom:Example/>` es la sintaxis del elemento de objeto para crear una instancia de la clase `Example`, donde el espacio de nombres CLR que contiene esa clase (y posiblemente la información de ensamblado externo que contiene tipos de respaldo) se asignó previamente al prefijo `custom`.</span><span class="sxs-lookup"><span data-stu-id="76a56-297">For example, `<custom:Example/>` is object element syntax to instantiate an instance of the `Example` class, where the CLR namespace containing that class (and possibly the external assembly information that contains backing types) was previously mapped to the `custom` prefix.</span></span>  
  
 <span data-ttu-id="76a56-298">Para obtener más información sobre los espacios de nombres XAML, vea [espacios de nombres y asignación de espacios de nombres XAML para WPF](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="76a56-298">For more information about XAML namespaces, see [XAML Namespaces and Namespace Mapping for WPF XAML](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).</span></span>  
  
<a name="markup_extensions"></a>   
## <a name="markup-extensions"></a><span data-ttu-id="76a56-299">Extensiones de marcado</span><span class="sxs-lookup"><span data-stu-id="76a56-299">Markup Extensions</span></span>  
 <span data-ttu-id="76a56-300">XAML define una entidad de programación de extensión de marcado que permite un escape desde el procesamiento normal del procesador XAML de los valores de atributo de cadena u objetos de objeto, y pospone el procesamiento a una clase de respaldo.</span><span class="sxs-lookup"><span data-stu-id="76a56-300">XAML defines a markup extension programming entity that enables an escape from the normal XAML processor handling of string attribute values or object elements, and defers the processing to a backing class.</span></span> <span data-ttu-id="76a56-301">El carácter que identifica una extensión de marcado para un procesador XAML cuando se usa la sintaxis de atributo es la llave de apertura ({), seguida de cualquier carácter que no sea una llave de cierre (}).</span><span class="sxs-lookup"><span data-stu-id="76a56-301">The character that identifies a markup extension to a XAML processor when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}).</span></span> <span data-ttu-id="76a56-302">La primera cadena que sigue a la llave de apertura debe hacer referencia a la clase que proporciona el comportamiento de la extensión concreta, donde la referencia puede omitir la subcadena "Extension" si esa subcadena forma parte del nombre de clase true.</span><span class="sxs-lookup"><span data-stu-id="76a56-302">The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name.</span></span> <span data-ttu-id="76a56-303">Después, puede aparecer un solo espacio y, a continuación, cada carácter correcto se usa como entrada en la implementación de la extensión, hasta que se encuentre la llave de cierre.</span><span class="sxs-lookup"><span data-stu-id="76a56-303">Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered.</span></span>  
  
 <span data-ttu-id="76a56-304">La implementación de XAML de .NET usa la clase abstracta <xref:System.Windows.Markup.MarkupExtension> como base para todas las extensiones de marcado admitidas por [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] así como otros marcos o tecnologías.</span><span class="sxs-lookup"><span data-stu-id="76a56-304">The .NET XAML implementation uses the <xref:System.Windows.Markup.MarkupExtension> abstract class as the basis for all of the markup extensions supported by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] as well as other frameworks or technologies.</span></span> <span data-ttu-id="76a56-305">Las extensiones de marcado que [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] implementa específicamente suelen estar diseñadas para proporcionar un medio para hacer referencia a otros objetos existentes o para realizar referencias diferidas a objetos que se evaluarán en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="76a56-305">The markup extensions that [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] specifically implements are often intended to provide a means to reference other existing objects, or to make deferred references to objects that will be evaluated at run time.</span></span> <span data-ttu-id="76a56-306">Por ejemplo, un enlace de datos de WPF simple se logra especificando la `{Binding}` extensión de marcado en lugar del valor que normalmente tardaría una propiedad determinada.</span><span class="sxs-lookup"><span data-stu-id="76a56-306">For example, a simple WPF data binding is accomplished by specifying the `{Binding}` markup extension in place of the value that a particular property would ordinarily take.</span></span> <span data-ttu-id="76a56-307">Muchas de las extensiones de marcado de WPF habilitan una sintaxis de atributo para las propiedades en las que, de lo contrario, no sería posible una sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="76a56-307">Many of the WPF markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible.</span></span> <span data-ttu-id="76a56-308">Por ejemplo, un objeto <xref:System.Windows.Style> es un tipo relativamente complejo que contiene una serie anidada de objetos y propiedades.</span><span class="sxs-lookup"><span data-stu-id="76a56-308">For example, a <xref:System.Windows.Style> object is a relatively complex type that contains a nested series of objects and properties.</span></span> <span data-ttu-id="76a56-309">Los estilos en WPF se definen normalmente como un recurso en un <xref:System.Windows.ResourceDictionary>y, a continuación, se hace referencia a ellos a través de una de las dos extensiones de marcado de WPF que solicitan un recurso.</span><span class="sxs-lookup"><span data-stu-id="76a56-309">Styles in WPF are typically defined as a resource in a <xref:System.Windows.ResourceDictionary>, and then referenced through one of the two WPF markup extensions that request a resource.</span></span> <span data-ttu-id="76a56-310">La extensión de marcado pospone la evaluación del valor de la propiedad a una búsqueda de recursos y permite proporcionar el valor de la propiedad <xref:System.Windows.FrameworkElement.Style%2A>, que toma el tipo <xref:System.Windows.Style>, en la sintaxis de atributo como en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="76a56-310">The markup extension defers the evaluation of the property value to a resource lookup and enables providing the value of the <xref:System.Windows.FrameworkElement.Style%2A> property, taking type <xref:System.Windows.Style>, in attribute syntax as in the following example:</span></span>  
  
 `<Button Style="{StaticResource MyStyle}">My button</Button>`  
  
 <span data-ttu-id="76a56-311">Aquí, `StaticResource` identifica la clase <xref:System.Windows.StaticResourceExtension> que proporciona la implementación de la extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="76a56-311">Here, `StaticResource` identifies the <xref:System.Windows.StaticResourceExtension> class providing the markup extension implementation.</span></span> <span data-ttu-id="76a56-312">La siguiente cadena `MyStyle` se usa como entrada para el constructor de <xref:System.Windows.StaticResourceExtension> no predeterminado, donde el parámetro tomado de la cadena de extensión declara la <xref:System.Windows.ResourceKey>solicitada.</span><span class="sxs-lookup"><span data-stu-id="76a56-312">The next string `MyStyle` is used as the input for the non-default <xref:System.Windows.StaticResourceExtension> constructor, where the parameter as taken from the extension string declares the requested <xref:System.Windows.ResourceKey>.</span></span> <span data-ttu-id="76a56-313">se espera que `MyStyle` sea el valor [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) de un <xref:System.Windows.Style> definido como recurso.</span><span class="sxs-lookup"><span data-stu-id="76a56-313">`MyStyle` is expected to be the [x:Key](../../../desktop-wpf/xaml-services/xkey-directive.md) value of a <xref:System.Windows.Style> defined as a resource.</span></span> <span data-ttu-id="76a56-314">El uso de la [extensión de marcado StaticResource](staticresource-markup-extension.md) solicita que el recurso se use para proporcionar el <xref:System.Windows.Style> valor de la propiedad a través de la lógica de búsqueda de recursos estáticos en tiempo de carga.</span><span class="sxs-lookup"><span data-stu-id="76a56-314">The [StaticResource Markup Extension](staticresource-markup-extension.md) usage requests that the resource be used to provide the <xref:System.Windows.Style> property value through static resource lookup logic at load time.</span></span>  
  
 <span data-ttu-id="76a56-315">Para más información sobre las extensiones de marcado, consulte [Extensiones de marcado y XAML de WPF](markup-extensions-and-wpf-xaml.md).</span><span class="sxs-lookup"><span data-stu-id="76a56-315">For more information about markup extensions, see [Markup Extensions and WPF XAML](markup-extensions-and-wpf-xaml.md).</span></span> <span data-ttu-id="76a56-316">Para obtener una referencia de las extensiones de marcado y otras características de programación XAML habilitadas en la implementación de XAML de .NET general, vea [espacio de nombres XAML (x:). Características del lenguaje](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="76a56-316">For a reference of markup extensions and other XAML programming features enabled in the general .NET XAML implementation, see [XAML Namespace (x:) Language Features](../../../desktop-wpf/xaml-services/namespace-language-features.md).</span></span> <span data-ttu-id="76a56-317">Para las extensiones de marcado específicas de WPF, vea [extensiones XAML de WPF](wpf-xaml-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="76a56-317">For WPF-specific markup extensions, see [WPF XAML Extensions](wpf-xaml-extensions.md).</span></span>  
  
<a name="attached_properties"></a>   
## <a name="attached-properties"></a><span data-ttu-id="76a56-318">Propiedades adjuntas</span><span class="sxs-lookup"><span data-stu-id="76a56-318">Attached Properties</span></span>  
 <span data-ttu-id="76a56-319">Las propiedades adjuntas son un concepto de programación introducido en XAML, en el que las propiedades pueden ser propiedad y definidas por un tipo determinado, pero se establecen como atributos o elementos de propiedad en cualquier elemento.</span><span class="sxs-lookup"><span data-stu-id="76a56-319">Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a particular type, but set as attributes or property elements on any element.</span></span> <span data-ttu-id="76a56-320">El escenario principal para el que se pretenden las propiedades adjuntas es permitir que los elementos secundarios de una estructura de marcado informen sobre la información a un elemento primario sin necesidad de un modelo de objetos compartidos exhaustivamente en todos los elementos.</span><span class="sxs-lookup"><span data-stu-id="76a56-320">The primary scenario that attached properties are intended for is to enable child elements in a markup structure to report information to a parent element without requiring an extensively shared object model across all elements.</span></span> <span data-ttu-id="76a56-321">Por el contrario, los elementos primarios pueden usar las propiedades adjuntas para notificar información a los elementos secundarios.</span><span class="sxs-lookup"><span data-stu-id="76a56-321">Conversely, attached properties can be used by parent elements to report information to child elements.</span></span> <span data-ttu-id="76a56-322">Para obtener más información sobre el propósito de las propiedades adjuntas y cómo crear sus propias propiedades adjuntas, vea [información general sobre las propiedades adjuntas](attached-properties-overview.md).</span><span class="sxs-lookup"><span data-stu-id="76a56-322">For more information on the purpose of attached properties and how to create your own attached properties, see [Attached Properties Overview](attached-properties-overview.md).</span></span>  
  
 <span data-ttu-id="76a56-323">Las propiedades adjuntas usan una sintaxis que se parece superficialmente a la sintaxis de los elementos de propiedad, en que también se especifica un *TypeName*. combinación *PropertyName* .</span><span class="sxs-lookup"><span data-stu-id="76a56-323">Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a *typeName*.*propertyName* combination.</span></span> <span data-ttu-id="76a56-324">Hay dos diferencias importantes:</span><span class="sxs-lookup"><span data-stu-id="76a56-324">There are two important differences:</span></span>  
  
- <span data-ttu-id="76a56-325">Puede usar *TypeName*. combinación *PropertyName* incluso cuando se establece una propiedad adjunta a través de la sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="76a56-325">You can use the *typeName*.*propertyName* combination even when setting an attached property through attribute syntax.</span></span> <span data-ttu-id="76a56-326">Las propiedades adjuntas son el único caso en el que calificar el nombre de la propiedad es un requisito en una sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="76a56-326">Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.</span></span>  
  
- <span data-ttu-id="76a56-327">También puede usar la sintaxis de elementos de propiedad para las propiedades adjuntas.</span><span class="sxs-lookup"><span data-stu-id="76a56-327">You can also use property element syntax for attached properties.</span></span> <span data-ttu-id="76a56-328">Sin embargo, para la sintaxis de elementos de propiedad típica, el *TypeName* que especifique es el elemento de objeto que contiene el elemento de propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-328">However, for typical property element syntax, the *typeName* you specify is the object element that contains the property element.</span></span> <span data-ttu-id="76a56-329">Si hace referencia a una propiedad adjunta, *TypeName* es la clase que define la propiedad adjunta, no el elemento de objeto contenedor.</span><span class="sxs-lookup"><span data-stu-id="76a56-329">If you are referring to an attached property, then the *typeName* is the class that defines the attached property, not the containing object element.</span></span>  
  
<a name="attached_events"></a>   
## <a name="attached-events"></a><span data-ttu-id="76a56-330">Eventos adjuntos</span><span class="sxs-lookup"><span data-stu-id="76a56-330">Attached Events</span></span>  
 <span data-ttu-id="76a56-331">Los eventos adjuntos son otro concepto de programación incluido en XAML donde los eventos se pueden definir mediante un tipo específico, pero los controladores se pueden adjuntar en cualquier elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="76a56-331">Attached events are another programming concept introduced in XAML where events can be defined by a specific type, but handlers may be attached on any object element.</span></span> <span data-ttu-id="76a56-332">En la implementación de WOF, a menudo el tipo que define un evento adjunto es un tipo estático que define un servicio y, a veces, los eventos adjuntos se exponen mediante un alias de evento enrutado en los tipos que exponen el servicio.</span><span class="sxs-lookup"><span data-stu-id="76a56-332">In the WOF implementation, often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service.</span></span> <span data-ttu-id="76a56-333">Los controladores de eventos adjuntos se especifican a través de la sintaxis de atributo.</span><span class="sxs-lookup"><span data-stu-id="76a56-333">Handlers for attached events are specified through attribute syntax.</span></span> <span data-ttu-id="76a56-334">Al igual que con los eventos adjuntos, la sintaxis de atributo se expande para los eventos adjuntos para permitir un *TypeName*. *eventName* Usage, donde *TypeName* es la clase que proporciona `Add` y `Remove` los descriptores de acceso del controlador de eventos para la infraestructura de eventos adjuntos y *eventName* es el nombre del evento.</span><span class="sxs-lookup"><span data-stu-id="76a56-334">As with attached events, the attribute syntax is expanded for attached events to allow a *typeName*.*eventName* usage, where *typeName* is the class that provides `Add` and `Remove` event handler accessors for the attached event infrastructure, and *eventName* is the event name.</span></span>  
  
<a name="anatomy_of_a_xaml_page_root_element"></a>   
## <a name="anatomy-of-a-xaml-root-element"></a><span data-ttu-id="76a56-335">Anatomía de un elemento raíz XAML</span><span class="sxs-lookup"><span data-stu-id="76a56-335">Anatomy of a XAML Root Element</span></span>  
 <span data-ttu-id="76a56-336">En la tabla siguiente se muestra un elemento raíz XAML típico dividido en el que se muestran los atributos específicos de un elemento raíz:</span><span class="sxs-lookup"><span data-stu-id="76a56-336">The following table shows a typical XAML root element broken down, showing the specific attributes of a root element:</span></span>  
  
|||  
|-|-|  
|`<Page`|<span data-ttu-id="76a56-337">Abrir el elemento de objeto del elemento raíz</span><span class="sxs-lookup"><span data-stu-id="76a56-337">Opening object element of the root element</span></span>|  
|`xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"`|<span data-ttu-id="76a56-338">Espacio de nombres XAML predeterminado ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)])</span><span class="sxs-lookup"><span data-stu-id="76a56-338">The default ([!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)]) XAML namespace</span></span>|  
|`xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"`|<span data-ttu-id="76a56-339">Espacio de nombres XAML del lenguaje XAML</span><span class="sxs-lookup"><span data-stu-id="76a56-339">The XAML language XAML namespace</span></span>|  
|`x:Class="ExampleNamespace.ExampleCode"`|<span data-ttu-id="76a56-340">Declaración de clase parcial que conecta el marcado con cualquier código subyacente definido para la clase parcial.</span><span class="sxs-lookup"><span data-stu-id="76a56-340">The partial class declaration that connects markup to any code-behind defined for the partial class</span></span>|  
|`>`|<span data-ttu-id="76a56-341">Fin del elemento de objeto para la raíz.</span><span class="sxs-lookup"><span data-stu-id="76a56-341">End of object element for the root.</span></span> <span data-ttu-id="76a56-342">El objeto no está cerrado todavía porque el elemento contiene elementos secundarios.</span><span class="sxs-lookup"><span data-stu-id="76a56-342">Object is not closed yet because the element contains child elements</span></span>|  
  
<a name="optional_and_nonrecommended_xaml_usages"></a>   
## <a name="optional-and-nonrecommended-xaml-usages"></a><span data-ttu-id="76a56-343">Usos de XAML opcionales y no recomendados</span><span class="sxs-lookup"><span data-stu-id="76a56-343">Optional and Nonrecommended XAML Usages</span></span>  
 <span data-ttu-id="76a56-344">En las secciones siguientes se describen los usos de XAML que técnicamente admiten los procesadores de XAML, pero que generan detalle u otros problemas estéticos que interfieren con los archivos XAML que quedan legibles para el usuario al desarrollar aplicaciones que contienen orígenes XAML.</span><span class="sxs-lookup"><span data-stu-id="76a56-344">The following sections describe XAML usages that are technically supported by XAML processors, but that produce verbosity or other aesthetic issues that interfere with XAML files remaining human-readable when you develop applications that contain XAML sources.</span></span>  
  
### <a name="optional-property-element-usages"></a><span data-ttu-id="76a56-345">Usos opcionales de los elementos de propiedad</span><span class="sxs-lookup"><span data-stu-id="76a56-345">Optional Property Element Usages</span></span>  
 <span data-ttu-id="76a56-346">Los usos opcionales de los elementos de propiedad incluyen la escritura explícita de las propiedades de contenido del elemento que el procesador XAML considera implícita.</span><span class="sxs-lookup"><span data-stu-id="76a56-346">Optional property element usages include explicitly writing out element content properties that the XAML processor considers implicit.</span></span> <span data-ttu-id="76a56-347">Por ejemplo, al declarar el contenido de un <xref:System.Windows.Controls.Menu>, puede elegir declarar explícitamente la colección <xref:System.Windows.Controls.ItemsControl.Items%2A> de la <xref:System.Windows.Controls.Menu> como una etiqueta de elemento de propiedad `<Menu.Items>`, y colocar cada <xref:System.Windows.Controls.MenuItem> en `<Menu.Items>`, en lugar de usar el comportamiento de procesador XAML implícito que todos los elementos secundarios de un <xref:System.Windows.Controls.Menu> deben ser <xref:System.Windows.Controls.MenuItem> y se colocan en la colección <xref:System.Windows.Controls.ItemsControl.Items%2A>.</span><span class="sxs-lookup"><span data-stu-id="76a56-347">For example, when you declare the contents of a <xref:System.Windows.Controls.Menu>, you could choose to explicitly declare the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection of the <xref:System.Windows.Controls.Menu> as a `<Menu.Items>` property element tag, and place each <xref:System.Windows.Controls.MenuItem> within `<Menu.Items>`, rather than using the implicit XAML processor behavior that all child elements of a <xref:System.Windows.Controls.Menu> must be a <xref:System.Windows.Controls.MenuItem> and are placed in the <xref:System.Windows.Controls.ItemsControl.Items%2A> collection.</span></span> <span data-ttu-id="76a56-348">A veces, los usos opcionales pueden ayudar a aclarar visualmente la estructura del objeto como se representa en el marcado.</span><span class="sxs-lookup"><span data-stu-id="76a56-348">Sometimes the optional usages can help to visually clarify the object structure as represented in the markup.</span></span> <span data-ttu-id="76a56-349">O, en ocasiones, el uso explícito de un elemento de propiedad puede evitar el marcado que es técnicamente funcional pero confuso visualmente, como las extensiones de marcado anidadas dentro de un valor de atributo.</span><span class="sxs-lookup"><span data-stu-id="76a56-349">Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.</span></span>  
  
### <a name="full-typenamemembername-qualified-attributes"></a><span data-ttu-id="76a56-350">Atributos completos de typeName. memberName completos</span><span class="sxs-lookup"><span data-stu-id="76a56-350">Full typeName.memberName Qualified Attributes</span></span>  
 <span data-ttu-id="76a56-351">*TypeName*. el formulario *memberName* para un atributo funciona realmente de forma más universal que el caso de los eventos enrutados.</span><span class="sxs-lookup"><span data-stu-id="76a56-351">The *typeName*.*memberName* form for an attribute actually works more universally than just the routed event case.</span></span> <span data-ttu-id="76a56-352">Pero en otras situaciones es superflua y debe evitarlo, si solo por motivos de estilo de marcado y legibilidad.</span><span class="sxs-lookup"><span data-stu-id="76a56-352">But in other situations that form is superfluous and you should avoid it, if only for reasons of markup style and readability.</span></span> <span data-ttu-id="76a56-353">En el siguiente ejemplo, cada una de las tres referencias al atributo <xref:System.Windows.Controls.Control.Background%2A> es totalmente equivalente:</span><span class="sxs-lookup"><span data-stu-id="76a56-353">In the following example, each of the three references to the <xref:System.Windows.Controls.Control.Background%2A> attribute are completely equivalent:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenameprop)]  
  
 <span data-ttu-id="76a56-354">`Button.Background` funciona porque la búsqueda calificada para esa propiedad en <xref:System.Windows.Controls.Button> es correcta (<xref:System.Windows.Controls.Control.Background%2A> se heredó del control) y <xref:System.Windows.Controls.Button> es la clase del elemento de objeto o una clase base.</span><span class="sxs-lookup"><span data-stu-id="76a56-354">`Button.Background` works because the qualified lookup for that property on <xref:System.Windows.Controls.Button> is successful (<xref:System.Windows.Controls.Control.Background%2A> was inherited from Control) and <xref:System.Windows.Controls.Button> is the class of the object element or a base class.</span></span> <span data-ttu-id="76a56-355">`Control.Background` funciona porque la clase <xref:System.Windows.Controls.Control> define realmente <xref:System.Windows.Controls.Control.Background%2A> y <xref:System.Windows.Controls.Control> es una clase base <xref:System.Windows.Controls.Button>.</span><span class="sxs-lookup"><span data-stu-id="76a56-355">`Control.Background` works because the <xref:System.Windows.Controls.Control> class actually defines <xref:System.Windows.Controls.Control.Background%2A> and <xref:System.Windows.Controls.Control> is a <xref:System.Windows.Controls.Button> base class.</span></span>  
  
 <span data-ttu-id="76a56-356">Sin embargo, el *TypeName*siguiente. el ejemplo del formulario *memberName* no funciona y, por tanto, se muestra comentado:</span><span class="sxs-lookup"><span data-stu-id="76a56-356">However, the following *typeName*.*memberName* form example does not work and is thus shown commented:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#TypeNameBadProp](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#typenamebadprop)]  
  
 <span data-ttu-id="76a56-357"><xref:System.Windows.Controls.Label> es otra clase derivada de <xref:System.Windows.Controls.Control>y, si ha especificado `Label.Background` dentro de un elemento de objeto <xref:System.Windows.Controls.Label>, este uso habría funcionado.</span><span class="sxs-lookup"><span data-stu-id="76a56-357"><xref:System.Windows.Controls.Label> is another derived class of <xref:System.Windows.Controls.Control>, and if you had specified `Label.Background` within a <xref:System.Windows.Controls.Label> object element, this usage would have worked.</span></span> <span data-ttu-id="76a56-358">Sin embargo, dado que <xref:System.Windows.Controls.Label> no es la clase o clase base de <xref:System.Windows.Controls.Button>, el comportamiento del procesador XAML especificado consiste en procesar `Label.Background` como una propiedad adjunta.</span><span class="sxs-lookup"><span data-stu-id="76a56-358">However, because <xref:System.Windows.Controls.Label> is not the class or base class of <xref:System.Windows.Controls.Button>, the specified XAML processor behavior is to then process `Label.Background` as an attached property.</span></span> <span data-ttu-id="76a56-359">`Label.Background` no es una propiedad adjunta disponible y se produce un error en este uso.</span><span class="sxs-lookup"><span data-stu-id="76a56-359">`Label.Background` is not an available attached property, and this usage fails.</span></span>  
  
### <a name="basetypenamemembername-property-elements"></a><span data-ttu-id="76a56-360">Elementos de la propiedad Nombredetipobase. memberName</span><span class="sxs-lookup"><span data-stu-id="76a56-360">baseTypeName.memberName Property Elements</span></span>  
 <span data-ttu-id="76a56-361">De forma análoga a como el *TypeName*. el formulario *memberName* funciona para la sintaxis de atributo, un *nombredetipobase*. la sintaxis *memberName* funciona para la sintaxis de elementos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="76a56-361">In an analogous way to how the *typeName*.*memberName* form works for attribute syntax, a *baseTypeName*.*memberName* syntax works for property element syntax.</span></span> <span data-ttu-id="76a56-362">Por ejemplo, la sintaxis siguiente funciona:</span><span class="sxs-lookup"><span data-stu-id="76a56-362">For instance, the following syntax works:</span></span>  
  
 [!code-xaml[XAMLOvwSupport#GoofyPE](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page8.xaml#goofype)]  
  
 <span data-ttu-id="76a56-363">Aquí, el elemento de propiedad se proporcionó como `Control.Background` aunque el elemento de propiedad estuviera contenido en `Button`.</span><span class="sxs-lookup"><span data-stu-id="76a56-363">Here, the property element was given as `Control.Background` even though the property element was contained in `Button`.</span></span>  
  
 <span data-ttu-id="76a56-364">Pero igual que *TypeName*. formulario *memberName* para atributos, *nombredetipobase*. *memberName* es un estilo pobre en el marcado y debe evitarlo.</span><span class="sxs-lookup"><span data-stu-id="76a56-364">But just like *typeName*.*memberName* form for attributes, *baseTypeName*.*memberName* is poor style in markup, and you should avoid it.</span></span>  
  
## <a name="see-also"></a><span data-ttu-id="76a56-365">Vea también</span><span class="sxs-lookup"><span data-stu-id="76a56-365">See also</span></span>

- [<span data-ttu-id="76a56-366">Información general sobre XAML (WPF)</span><span class="sxs-lookup"><span data-stu-id="76a56-366">XAML Overview (WPF)</span></span>](../../../desktop-wpf/fundamentals/xaml.md)
- [<span data-ttu-id="76a56-367">Características de lenguaje (x:) de espacios de nombres XAML</span><span class="sxs-lookup"><span data-stu-id="76a56-367">XAML Namespace (x:) Language Features</span></span>](../../../desktop-wpf/xaml-services/namespace-language-features.md)
- [<span data-ttu-id="76a56-368">Extensiones XAML de WPF</span><span class="sxs-lookup"><span data-stu-id="76a56-368">WPF XAML Extensions</span></span>](wpf-xaml-extensions.md)
- [<span data-ttu-id="76a56-369">Información general sobre las propiedades de dependencia</span><span class="sxs-lookup"><span data-stu-id="76a56-369">Dependency Properties Overview</span></span>](dependency-properties-overview.md)
- [<span data-ttu-id="76a56-370">Clases TypeConverter y XAML</span><span class="sxs-lookup"><span data-stu-id="76a56-370">TypeConverters and XAML</span></span>](typeconverters-and-xaml.md)
- [<span data-ttu-id="76a56-371">Clases XAML y personalizadas para WPF</span><span class="sxs-lookup"><span data-stu-id="76a56-371">XAML and Custom Classes for WPF</span></span>](xaml-and-custom-classes-for-wpf.md)
