---
title: Ámbitos de código XAML
ms.date: 03/30/2017
helpviewer_keywords:
- namescopes [WPF]
- styles [WPF], namescopes in
- templates [WPF], namescopes in
- APIs [WPF], name-related
- name-related APIs
- XAML [WPF], namescopes
- classes [WPF], FrameworkContentElement
ms.assetid: 52bbf4f2-15fc-40d4-837b-bb4c21ead7d4
ms.openlocfilehash: 4383492157191f61cf04a2fdd6ce27e9183bda8b
ms.sourcegitcommit: de17a7a0a37042f0d4406f5ae5393531caeb25ba
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 01/24/2020
ms.locfileid: "76744420"
---
# <a name="wpf-xaml-namescopes"></a><span data-ttu-id="588cc-102">Ámbitos de nombres XAML de WPF</span><span class="sxs-lookup"><span data-stu-id="588cc-102">WPF XAML Namescopes</span></span>
<span data-ttu-id="588cc-103">Los ámbitos de nombres XAML son un concepto que identifica objetos que se definen en XAML.</span><span class="sxs-lookup"><span data-stu-id="588cc-103">XAML namescopes are a concept that identifies objects that are defined in XAML.</span></span> <span data-ttu-id="588cc-104">Los nombres de un ámbito de nombres XAML se pueden usar para establecer relaciones entre los nombres de objetos definidos por XAML y sus equivalentes de instancia en un árbol de objetos.</span><span class="sxs-lookup"><span data-stu-id="588cc-104">The names in a XAML namescope can be used to establish relationships between the XAML-defined names of objects and their instance equivalents in an object tree.</span></span> <span data-ttu-id="588cc-105">Normalmente, los ámbitos de nombres XAML del código administrado de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] se crean al cargar las distintas raíces de página XAML de una aplicación XAML.</span><span class="sxs-lookup"><span data-stu-id="588cc-105">Typically, XAML namescopes in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] managed code are created when loading the individual XAML page roots for a XAML application.</span></span> <span data-ttu-id="588cc-106">Los ámbitos de código XAML como el objeto de programación se definen mediante la interfaz <xref:System.Windows.Markup.INameScope> y también se implementan mediante la clase práctica <xref:System.Windows.NameScope>.</span><span class="sxs-lookup"><span data-stu-id="588cc-106">XAML namescopes as the programming object are defined by the <xref:System.Windows.Markup.INameScope> interface and are also implemented by the practical class <xref:System.Windows.NameScope>.</span></span>  

<a name="Namescopes_in_Loaded_XAML_Applications"></a>   
## <a name="namescopes-in-loaded-xaml-applications"></a><span data-ttu-id="588cc-107">Ámbitos de nombres en las aplicaciones XAML cargadas</span><span class="sxs-lookup"><span data-stu-id="588cc-107">Namescopes in Loaded XAML Applications</span></span>  
 <span data-ttu-id="588cc-108">En un contexto de programación o de informática más amplio, los conceptos de programación suelen incluir el principio de un identificador o nombre único que se puede usar para obtener acceso a un objeto.</span><span class="sxs-lookup"><span data-stu-id="588cc-108">In a broader programming or computer science context, programming concepts often include the principle of a unique identifier or name that can be used to access an object.</span></span> <span data-ttu-id="588cc-109">Para los sistemas que usan identificadores o nombres, el ámbito de nombres define los límites en los que buscará un proceso o técnica si se solicita un objeto con ese nombre, o bien los límites en los que se aplica la unicidad de la identificación de nombres.</span><span class="sxs-lookup"><span data-stu-id="588cc-109">For systems that use identifiers or names, the namescope defines the boundaries within which a process or technique will search if an object of that name is requested, or the boundaries wherein uniqueness of identifying names is enforced.</span></span> <span data-ttu-id="588cc-110">En los ámbitos de nombres XAML se aplican los siguientes principios generales.</span><span class="sxs-lookup"><span data-stu-id="588cc-110">These general principles are true for XAML namescopes.</span></span> <span data-ttu-id="588cc-111">En WPF, los ámbitos de nombres XAML se crean en el elemento raíz de una página XAML cuando esta se carga.</span><span class="sxs-lookup"><span data-stu-id="588cc-111">In WPF, XAML namescopes are created on the root element for a XAML page when the page is loaded.</span></span> <span data-ttu-id="588cc-112">Todos los nombres especificados dentro de la página XAML a partir de la raíz de la página se agregan a un ámbito de nombres XAML pertinente.</span><span class="sxs-lookup"><span data-stu-id="588cc-112">Each name specified within the XAML page starting at the page root is added to a pertinent XAML namescope.</span></span>  
  
 <span data-ttu-id="588cc-113">En XAML de WPF, los elementos que son elementos raíz comunes (como <xref:System.Windows.Controls.Page>y <xref:System.Windows.Window>) siempre controlan un ámbito de nombres XAML.</span><span class="sxs-lookup"><span data-stu-id="588cc-113">In WPF XAML, elements that are common root elements (such as <xref:System.Windows.Controls.Page>, and <xref:System.Windows.Window>) always control a XAML namescope.</span></span> <span data-ttu-id="588cc-114">Si un elemento como <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement> es el elemento raíz de la página en el marcado, un procesador de [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] agrega una raíz <xref:System.Windows.Controls.Page> implícitamente para que el <xref:System.Windows.Controls.Page> pueda proporcionar un ámbito de nombres XAML funcional.</span><span class="sxs-lookup"><span data-stu-id="588cc-114">If an element such as <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> is the root element of the page in markup, a [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] processor adds a <xref:System.Windows.Controls.Page> root implicitly so that the <xref:System.Windows.Controls.Page> can provide a working XAML namescope.</span></span>  
  
> [!NOTE]
> <span data-ttu-id="588cc-115">Las acciones de compilación de WPF crean un ámbito de nombres XAML para la producción de XAML, aunque no haya ningún atributo `Name` o `x:Name` definido en ningún elemento del marcado de [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="588cc-115">WPF build actions create a XAML namescope for a XAML production even if no `Name` or `x:Name` attributes are defined on any elements in the [!INCLUDE[TLA2#tla_xaml](../../../../includes/tla2sharptla-xaml-md.md)] markup.</span></span>  
  
 <span data-ttu-id="588cc-116">Si intenta usar el mismo nombre dos veces en cualquier ámbito de nombres XAML, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="588cc-116">If you try to use the same name twice in any XAML namescope, an exception is raised.</span></span> <span data-ttu-id="588cc-117">Para el XAML de WPF que tiene código subyacente y forma parte de una aplicación compilada, la excepción se produce en tiempo de compilación mediante acciones de compilación de WPF, al crear la clase generada para la página durante la compilación inicial del marcado.</span><span class="sxs-lookup"><span data-stu-id="588cc-117">For WPF XAML that has code-behind and is part of a compiled application, the exception is raised at build time by WPF build actions, when creating the generated class for the page during the initial markup compile.</span></span> <span data-ttu-id="588cc-118">Para el XAML que no está compilado por el marcado mediante ninguna acción de compilación, las excepciones relacionadas con algún error de ámbito de nombres XAML podrían producirse al cargar el XAML.</span><span class="sxs-lookup"><span data-stu-id="588cc-118">For XAML that is not markup-compiled by any build action, exceptions related to XAML namescope issues might be raised when the XAML is loaded.</span></span> <span data-ttu-id="588cc-119">Los diseñadores de XAML también pueden prever los errores de ámbito de nombres XAML en tiempo de diseño.</span><span class="sxs-lookup"><span data-stu-id="588cc-119">XAML designers might also anticipate XAML namescope issues at design time.</span></span>  
  
### <a name="adding-objects-to-runtime-object-trees"></a><span data-ttu-id="588cc-120">Agregar objetos a los árboles de objetos en tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="588cc-120">Adding Objects to Runtime Object Trees</span></span>  
 <span data-ttu-id="588cc-121">El momento en que se analiza el XAML representa el momento en el que se crea y se define un ámbito de nombres XAML de WPF.</span><span class="sxs-lookup"><span data-stu-id="588cc-121">The moment that XAML is parsed represents the moment in time that a WPF XAML namescope is created and defined.</span></span> <span data-ttu-id="588cc-122">Si agrega un objeto a un árbol de objetos después de haber analizado el XAML que generó el árbol, los valores `Name` o `x:Name` del objeto nuevo no actualizarán automáticamente la información de un ámbito de nombres XAML.</span><span class="sxs-lookup"><span data-stu-id="588cc-122">If you add an object to an object tree at a point in time after the XAML that produced that tree was parsed, a `Name` or `x:Name` value on the new object does not automatically update the information in a XAML namescope.</span></span> <span data-ttu-id="588cc-123">Para agregar un nombre a un objeto en un ámbito de nombres XAML de WPF después de cargar XAML, debe llamar a la implementación adecuada de <xref:System.Windows.Markup.INameScope.RegisterName%2A> en el objeto que define el ámbito de nombres XAML, que suele ser la raíz de la página XAML.</span><span class="sxs-lookup"><span data-stu-id="588cc-123">To add a name for an object into a WPF XAML namescope after XAML is loaded, you must call the appropriate implementation of <xref:System.Windows.Markup.INameScope.RegisterName%2A> on the object that defines the XAML namescope, which is typically the XAML page root.</span></span> <span data-ttu-id="588cc-124">Si el nombre no está registrado, no se puede hacer referencia al objeto agregado por nombre a través de métodos como <xref:System.Windows.FrameworkElement.FindName%2A>, y no se puede usar ese nombre para el destino de la animación.</span><span class="sxs-lookup"><span data-stu-id="588cc-124">If the name is not registered, the added object cannot be referenced by name through methods such as <xref:System.Windows.FrameworkElement.FindName%2A>, and you cannot use that name for animation targeting.</span></span>  
  
 <span data-ttu-id="588cc-125">El escenario más común para los desarrolladores de aplicaciones es que usará <xref:System.Windows.FrameworkElement.RegisterName%2A> para registrar nombres en el ámbito de nombres XAML en la raíz actual de la página.</span><span class="sxs-lookup"><span data-stu-id="588cc-125">The most common scenario for application developers is that you will use <xref:System.Windows.FrameworkElement.RegisterName%2A> to register names into the XAML namescope on the current root of the page.</span></span> <span data-ttu-id="588cc-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> forma parte de un escenario importante para los guiones gráficos que tienen como destino objetos para animaciones.</span><span class="sxs-lookup"><span data-stu-id="588cc-126"><xref:System.Windows.FrameworkElement.RegisterName%2A> is part of an important scenario for storyboards that target objects for animations.</span></span> <span data-ttu-id="588cc-127">Para obtener más información, consulte [Información general sobre objetos Storyboard](../graphics-multimedia/storyboards-overview.md).</span><span class="sxs-lookup"><span data-stu-id="588cc-127">For more information, see [Storyboards Overview](../graphics-multimedia/storyboards-overview.md).</span></span>  
  
 <span data-ttu-id="588cc-128">Si llama a <xref:System.Windows.FrameworkElement.RegisterName%2A> en un objeto que no sea el objeto que define el ámbito de nombres XAML, el nombre todavía se registra en el ámbito de nombres XAML en el que se mantiene el objeto que realiza la llamada, como si hubiera llamado a <xref:System.Windows.FrameworkElement.RegisterName%2A> en el objeto de definición del ámbito de nombres XAML.</span><span class="sxs-lookup"><span data-stu-id="588cc-128">If you call <xref:System.Windows.FrameworkElement.RegisterName%2A> on an object other than the object that defines the XAML namescope, the name is still registered to the XAML namescope that the calling object is held within, as if you had called <xref:System.Windows.FrameworkElement.RegisterName%2A> on the XAML namescope defining object.</span></span>  
  
### <a name="xaml-namescopes-in-code"></a><span data-ttu-id="588cc-129">Ámbitos de nombres XAML en el código</span><span class="sxs-lookup"><span data-stu-id="588cc-129">XAML Namescopes in Code</span></span>  
 <span data-ttu-id="588cc-130">Puede crear y usar ámbitos de nombres XAML en el código.</span><span class="sxs-lookup"><span data-stu-id="588cc-130">You can create and then use XAML namescopes in code.</span></span> <span data-ttu-id="588cc-131">Las API y los conceptos implicados en la creación de ámbitos de nombres XAML son los mismos, incluso para un uso de código puro, ya que el procesador XAML de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] usa estas API y estos conceptos cuando procesa el XAML.</span><span class="sxs-lookup"><span data-stu-id="588cc-131">The APIs and the concepts involved in XAML namescope creation are the same even for a pure code usage, because the XAML processor for [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] uses these APIs and concepts when it processes XAML itself.</span></span> <span data-ttu-id="588cc-132">Los conceptos y las API existen principalmente para poder buscar objetos por nombre dentro de un árbol de objetos que se suele definir parcial o completamente en XAML.</span><span class="sxs-lookup"><span data-stu-id="588cc-132">The concepts and API exist mainly for the purpose of being able to find objects by name within an object tree that is typically defined partially or entirely in XAML.</span></span>  
  
 <span data-ttu-id="588cc-133">En el caso de las aplicaciones que se crean mediante programación, y no desde XAML cargado, el objeto que define un ámbito de nombres XAML debe implementar <xref:System.Windows.Markup.INameScope>, o ser una clase derivada <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>, para admitir la creación de un ámbito de nombres XAML en sus instancias.</span><span class="sxs-lookup"><span data-stu-id="588cc-133">For applications that are created programmatically, and not from loaded XAML, the object that defines a XAML namescope must implement <xref:System.Windows.Markup.INameScope>, or be a <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement> derived class, in order to support creation of a XAML namescope on its instances.</span></span>  
  
 <span data-ttu-id="588cc-134">Además, para cualquier elemento que no se haya cargado y procesado con un procesador XAML, el ámbito de nombres XAML del objeto no se crea ni se inicializa de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="588cc-134">Also, for any element that is not loaded and processed by a XAML processor, the XAML namescope for the object is not created or initialized by default.</span></span> <span data-ttu-id="588cc-135">Debe crear explícitamente un ámbito de nombres XAML para cualquier objeto en el que después vaya a registrar nombres.</span><span class="sxs-lookup"><span data-stu-id="588cc-135">You must explicitly create a new XAML namescope for any object that you intend to register names into subsequently.</span></span> <span data-ttu-id="588cc-136">Para crear un ámbito de nombres XAML, llame al método estático <xref:System.Windows.NameScope.SetNameScope%2A>.</span><span class="sxs-lookup"><span data-stu-id="588cc-136">To create a XAML namescope, you call the static <xref:System.Windows.NameScope.SetNameScope%2A> method.</span></span> <span data-ttu-id="588cc-137">Especifique el objeto que será el propietario como `dependencyObject` parámetro y una nueva llamada al constructor <xref:System.Windows.NameScope.%23ctor%2A> como el parámetro `value`.</span><span class="sxs-lookup"><span data-stu-id="588cc-137">Specify the object that will own it as the `dependencyObject` parameter, and a new <xref:System.Windows.NameScope.%23ctor%2A> constructor call as the `value` parameter.</span></span>  
  
 <span data-ttu-id="588cc-138">Si el objeto proporcionado como `dependencyObject` para <xref:System.Windows.NameScope.SetNameScope%2A> no es una implementación de <xref:System.Windows.Markup.INameScope>, <xref:System.Windows.FrameworkElement> o <xref:System.Windows.FrameworkContentElement>, llamar a <xref:System.Windows.FrameworkElement.RegisterName%2A> en cualquier elemento secundario no tendrá ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="588cc-138">If the object provided as `dependencyObject` for <xref:System.Windows.NameScope.SetNameScope%2A> is not a <xref:System.Windows.Markup.INameScope> implementation, <xref:System.Windows.FrameworkElement> or <xref:System.Windows.FrameworkContentElement>, calling <xref:System.Windows.FrameworkElement.RegisterName%2A> on any child elements will have no effect.</span></span> <span data-ttu-id="588cc-139">Si no se puede crear el nuevo ámbito de nombres XAML explícitamente, las llamadas a <xref:System.Windows.FrameworkElement.RegisterName%2A> producirán una excepción.</span><span class="sxs-lookup"><span data-stu-id="588cc-139">If you fail to create the new XAML namescope explicitly, then calls to <xref:System.Windows.FrameworkElement.RegisterName%2A> will raise an exception.</span></span>  
  
 <span data-ttu-id="588cc-140">Para ver un ejemplo de cómo usar las API de ámbito de nombres XAML en el código, consulte [Definir un ámbito de nombres](../graphics-multimedia/how-to-define-a-name-scope.md).</span><span class="sxs-lookup"><span data-stu-id="588cc-140">For an example of using XAML namescope APIs in code, see [Define a Name Scope](../graphics-multimedia/how-to-define-a-name-scope.md).</span></span>  
  
<a name="Namescopes_in_Styles_and_Templates"></a>   
## <a name="xaml-namescopes-in-styles-and-templates"></a><span data-ttu-id="588cc-141">Ámbitos de nombres XAML en estilos y plantillas</span><span class="sxs-lookup"><span data-stu-id="588cc-141">XAML Namescopes in Styles and Templates</span></span>  
 <span data-ttu-id="588cc-142">Los estilos y las plantillas de [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] ofrecen la posibilidad de reutilizar y volver a aplicar el contenido de una manera sencilla,</span><span class="sxs-lookup"><span data-stu-id="588cc-142">Styles and templates in [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] provide the ability to reuse and reapply content in a straightforward way.</span></span> <span data-ttu-id="588cc-143">aunque también pueden incluir elementos con nombres XAML definidos en el nivel de la plantilla.</span><span class="sxs-lookup"><span data-stu-id="588cc-143">However, styles and templates might also include elements with XAML names defined at the template level.</span></span> <span data-ttu-id="588cc-144">Esa misma plantilla se puede usar varias veces en una página.</span><span class="sxs-lookup"><span data-stu-id="588cc-144">That same template might be used multiple times in a page.</span></span> <span data-ttu-id="588cc-145">Por este motivo, tanto los estilos como las plantillas definen sus propios ámbitos de nombres XAML, independientemente de la ubicación en un árbol de objetos en la que se aplique el estilo o plantilla.</span><span class="sxs-lookup"><span data-stu-id="588cc-145">For this reason, styles and templates both define their own XAML namescopes, independent of whatever location in an object tree where the style or template is applied.</span></span>  
  
 <span data-ttu-id="588cc-146">Considere el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="588cc-146">Consider the following example:</span></span>  
  
 [!code-xaml[XamlOvwSupport#NameScopeTemplates](~/samples/snippets/csharp/VS_Snippets_Wpf/XAMLOvwSupport/CSharp/page6.xaml#namescopetemplates)]  
  
 <span data-ttu-id="588cc-147">En este caso, se aplica la misma plantilla a dos botones diferentes.</span><span class="sxs-lookup"><span data-stu-id="588cc-147">Here, the same template is applied to two different buttons.</span></span> <span data-ttu-id="588cc-148">Si las plantillas no tuvieran ámbitos de nombres XAML discretos, el nombre `TheBorder` usado en la plantilla provocaría un conflicto de nombres en el ámbito de nombres XAML.</span><span class="sxs-lookup"><span data-stu-id="588cc-148">If templates did not have discrete XAML namescopes, the `TheBorder` name used in the template would cause a name collision in the XAML namescope.</span></span> <span data-ttu-id="588cc-149">Todas las instancias de la plantilla tienen su propio ámbito de nombres XAML, por lo que, en este ejemplo, el ámbito de nombres XAML de todas las plantillas de instancia contendrían exactamente un nombre.</span><span class="sxs-lookup"><span data-stu-id="588cc-149">Each instantiation of the template has its own XAML namescope, so in this example each instantiated template's XAML namescope would contain exactly one name.</span></span>  
  
 <span data-ttu-id="588cc-150">Los estilos también definen su propio ámbito de nombres XAML, sobre todo para que las partes de los guiones gráficos puedan tener asignados nombres concretos.</span><span class="sxs-lookup"><span data-stu-id="588cc-150">Styles also define their own XAML namescope, mostly so that parts of storyboards can have particular names assigned.</span></span> <span data-ttu-id="588cc-151">Estos nombres permiten que haya comportamientos específicos de controles destinados a elementos con ese nombre, incluso si la plantilla se ha vuelto a definir como parte de la personalización de controles.</span><span class="sxs-lookup"><span data-stu-id="588cc-151">These names enable control specific behaviors that will target elements of that name, even if the template was re-defined as part of control customization.</span></span>  
  
 <span data-ttu-id="588cc-152">Debido a los ámbitos de nombres XAML independientes, resulta más difícil buscar elementos con nombre en una plantilla que buscar un elemento con nombre y sin plantilla en una página.</span><span class="sxs-lookup"><span data-stu-id="588cc-152">Because of the separate XAML namescopes, finding named elements in a template is more challenging than finding a non-templated named element in a page.</span></span> <span data-ttu-id="588cc-153">En primer lugar, debe determinar la plantilla aplicada, obteniendo el <xref:System.Windows.Controls.Control.Template%2A> valor de la propiedad del control al que se aplica la plantilla.</span><span class="sxs-lookup"><span data-stu-id="588cc-153">You first need to determine the applied template, by getting the <xref:System.Windows.Controls.Control.Template%2A> property value of the control where the template is applied.</span></span> <span data-ttu-id="588cc-154">A continuación, se llama a la versión de plantilla de <xref:System.Windows.FrameworkTemplate.FindName%2A>, pasando el control en el que se aplicó la plantilla como segundo parámetro.</span><span class="sxs-lookup"><span data-stu-id="588cc-154">Then, you call the template version of <xref:System.Windows.FrameworkTemplate.FindName%2A>, passing the control where the template was applied as the second parameter.</span></span>  
  
 <span data-ttu-id="588cc-155">Si es un autor de controles y está generando una Convención en la que un elemento con nombre determinado en una plantilla aplicada es el destino de un comportamiento definido por el propio control, puede usar el método <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> desde el código de implementación del control.</span><span class="sxs-lookup"><span data-stu-id="588cc-155">If you are a control author and you are generating a convention where a particular named element in an applied template is the target for a behavior that is defined by the control itself, you can use the <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method from your control implementation code.</span></span> <span data-ttu-id="588cc-156">El método <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> está protegido, por lo que solo el autor del control tiene acceso a él.</span><span class="sxs-lookup"><span data-stu-id="588cc-156">The <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> method is protected, so only the control author has access to it.</span></span>  
  
 <span data-ttu-id="588cc-157">Si está trabajando desde dentro de una plantilla, y necesita obtener acceso al ámbito de nombres XAML donde se aplica la plantilla, obtenga el valor de <xref:System.Windows.FrameworkElement.TemplatedParent%2A>y, a continuación, llame a <xref:System.Windows.FrameworkElement.FindName%2A> allí.</span><span class="sxs-lookup"><span data-stu-id="588cc-157">If you are working from within a template, and need to get to the XAML namescope where the template is applied, get the value of <xref:System.Windows.FrameworkElement.TemplatedParent%2A>, and then call <xref:System.Windows.FrameworkElement.FindName%2A> there.</span></span> <span data-ttu-id="588cc-158">Un ejemplo de trabajo dentro de la plantilla sería escribir la implementación del controlador de eventos donde se generará el evento desde un elemento de una plantilla aplicada.</span><span class="sxs-lookup"><span data-stu-id="588cc-158">An example of working within the template would be if you are writing the event handler implementation where the event will be raised from an element in an applied template.</span></span>  
  
<a name="Namescopes_and_Name_related_APIs"></a>   
## <a name="xaml-namescopes-and-name-related-apis"></a><span data-ttu-id="588cc-159">Ámbitos de nombres XAML y API relacionadas con nombres</span><span class="sxs-lookup"><span data-stu-id="588cc-159">XAML Namescopes and Name-related APIs</span></span>  
 <span data-ttu-id="588cc-160"><xref:System.Windows.FrameworkElement> tiene <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> y <xref:System.Windows.FrameworkElement.UnregisterName%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="588cc-160"><xref:System.Windows.FrameworkElement> has <xref:System.Windows.FrameworkElement.FindName%2A>, <xref:System.Windows.FrameworkElement.RegisterName%2A> and <xref:System.Windows.FrameworkElement.UnregisterName%2A> methods.</span></span> <span data-ttu-id="588cc-161">Si el objeto en el que llama a estos métodos tiene un ámbito de nombres XAML, los métodos llaman a los métodos del ámbito de nombres XAML relevante.</span><span class="sxs-lookup"><span data-stu-id="588cc-161">If the object you call these methods on owns a XAML namescope, the methods call into the methods of the relevant XAML namescope.</span></span> <span data-ttu-id="588cc-162">De lo contrario, se comprueba el elemento primario para ver si tiene un ámbito de nombres XAML. Este proceso continúa de forma recursiva hasta que se encuentra un ámbito de nombres XAML (debido al comportamiento del procesador XAML, se garantiza que haya un ámbito de nombres XAML en la raíz).</span><span class="sxs-lookup"><span data-stu-id="588cc-162">Otherwise, the parent element is checked to see if it owns a XAML namescope, and this process continues recursively until a XAML namescope is found (because of the XAML processor behavior, there is guaranteed to be a XAML namescope at the root).</span></span> <span data-ttu-id="588cc-163"><xref:System.Windows.FrameworkContentElement> tiene comportamientos análogos, con la excepción de que ningún <xref:System.Windows.FrameworkContentElement> nunca tendrá un ámbito de nombres XAML.</span><span class="sxs-lookup"><span data-stu-id="588cc-163"><xref:System.Windows.FrameworkContentElement> has analogous behaviors, with the exception that no <xref:System.Windows.FrameworkContentElement> will ever own a XAML namescope.</span></span> <span data-ttu-id="588cc-164">Los métodos existen en <xref:System.Windows.FrameworkContentElement> para que las llamadas se puedan reenviar finalmente a un elemento primario <xref:System.Windows.FrameworkElement>.</span><span class="sxs-lookup"><span data-stu-id="588cc-164">The methods exist on <xref:System.Windows.FrameworkContentElement> so that the calls can be forwarded eventually to a <xref:System.Windows.FrameworkElement> parent element.</span></span>  
  
 <span data-ttu-id="588cc-165"><xref:System.Windows.NameScope.SetNameScope%2A> se utiliza para asignar un nuevo ámbito de nombres XAML a un objeto existente.</span><span class="sxs-lookup"><span data-stu-id="588cc-165"><xref:System.Windows.NameScope.SetNameScope%2A> is used to map a new XAML namescope to an existing object.</span></span> <span data-ttu-id="588cc-166">Puede llamar a <xref:System.Windows.NameScope.SetNameScope%2A> más de una vez para restablecer o borrar el ámbito de nombres XAML, pero esto no es un uso común.</span><span class="sxs-lookup"><span data-stu-id="588cc-166">You can call <xref:System.Windows.NameScope.SetNameScope%2A> more than once in order to reset or clear the XAML namescope, but that is not a common usage.</span></span> <span data-ttu-id="588cc-167">Además, <xref:System.Windows.NameScope.GetNameScope%2A> no se suele usar desde el código.</span><span class="sxs-lookup"><span data-stu-id="588cc-167">Also, <xref:System.Windows.NameScope.GetNameScope%2A> is not typically used from code.</span></span>  
  
### <a name="xaml-namescope-implementations"></a><span data-ttu-id="588cc-168">Implementaciones de ámbito de nombres XAML</span><span class="sxs-lookup"><span data-stu-id="588cc-168">XAML Namescope Implementations</span></span>  
 <span data-ttu-id="588cc-169">Las clases siguientes implementan <xref:System.Windows.Markup.INameScope> directamente:</span><span class="sxs-lookup"><span data-stu-id="588cc-169">The following classes implement <xref:System.Windows.Markup.INameScope> directly:</span></span>  
  
- <xref:System.Windows.NameScope>  
  
- <xref:System.Windows.Style>  
  
- <xref:System.Windows.ResourceDictionary>  
  
- <xref:System.Windows.FrameworkTemplate>  
  
 <span data-ttu-id="588cc-170"><xref:System.Windows.ResourceDictionary> no utiliza nombres o ámbitos de nombres XAML. en su lugar, utiliza claves, ya que es una implementación de diccionario.</span><span class="sxs-lookup"><span data-stu-id="588cc-170"><xref:System.Windows.ResourceDictionary> does not use XAML names or namescopes ; it uses keys instead, because it is a dictionary implementation.</span></span> <span data-ttu-id="588cc-171">El único motivo por el que <xref:System.Windows.ResourceDictionary> implementa <xref:System.Windows.Markup.INameScope> es para que pueda generar excepciones al código de usuario que ayuden a clarificar la distinción entre un ámbito de nombres XAML verdadero y el modo en que un <xref:System.Windows.ResourceDictionary> controla las claves, y también para asegurarse de que los ámbitos de nombres XAML no se aplican a un <xref:System.Windows.ResourceDictionary> por elementos primarios.</span><span class="sxs-lookup"><span data-stu-id="588cc-171">The only reason that <xref:System.Windows.ResourceDictionary> implements <xref:System.Windows.Markup.INameScope> is so it can raise exceptions to user code that help clarify the distinction between a true XAML namescope and how a <xref:System.Windows.ResourceDictionary> handles keys, and also to assure that XAML namescopes are not applied to a <xref:System.Windows.ResourceDictionary> by parent elements.</span></span>  
  
 <span data-ttu-id="588cc-172"><xref:System.Windows.FrameworkTemplate> e <xref:System.Windows.Style> implementan <xref:System.Windows.Markup.INameScope> a través de definiciones de interfaz explícitas.</span><span class="sxs-lookup"><span data-stu-id="588cc-172"><xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> implement <xref:System.Windows.Markup.INameScope> through explicit interface definitions.</span></span> <span data-ttu-id="588cc-173">Las implementaciones explícitas permiten que estos ámbitos de código XAML se comporten de forma convencional cuando se accede a ellos a través de la interfaz de <xref:System.Windows.Markup.INameScope>, que es cómo se comunican los ámbitos de código XAML mediante [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] procesos internos.</span><span class="sxs-lookup"><span data-stu-id="588cc-173">The explicit implementations allow these XAML namescopes to behave conventionally when they are accessed through the <xref:System.Windows.Markup.INameScope> interface, which is how XAML namescopes are communicated by [!INCLUDE[TLA2#tla_winclient](../../../../includes/tla2sharptla-winclient-md.md)] internal processes.</span></span> <span data-ttu-id="588cc-174">Sin embargo, las definiciones de interfaz explícitas no forman parte de la superficie de la API convencional de <xref:System.Windows.FrameworkTemplate> y <xref:System.Windows.Style>, porque rara vez es necesario llamar a los métodos de <xref:System.Windows.Markup.INameScope> en <xref:System.Windows.FrameworkTemplate> y <xref:System.Windows.Style> directamente, y en su lugar usaría otra API como <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span><span class="sxs-lookup"><span data-stu-id="588cc-174">But the explicit interface definitions are not part of the conventional API surface of <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style>, because you seldom need to call the <xref:System.Windows.Markup.INameScope> methods on <xref:System.Windows.FrameworkTemplate> and <xref:System.Windows.Style> directly, and instead would use other API such as <xref:System.Windows.FrameworkElement.GetTemplateChild%2A>.</span></span>  
  
 <span data-ttu-id="588cc-175">Las siguientes clases definen su propio ámbito de nombres XAML, mediante el uso de la clase auxiliar <xref:System.Windows.NameScope?displayProperty=nameWithType> y la conexión a su implementación del ámbito de nombres XAML a través de la propiedad adjunta <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="588cc-175">The following classes define their own XAML namescope, by using the <xref:System.Windows.NameScope?displayProperty=nameWithType> helper class and connecting to its XAML namescope implementation through the <xref:System.Windows.NameScope.NameScope%2A?displayProperty=nameWithType> attached property:</span></span>  
  
- <xref:System.Windows.FrameworkElement>  
  
- <xref:System.Windows.FrameworkContentElement>  
  
## <a name="see-also"></a><span data-ttu-id="588cc-176">Vea también</span><span class="sxs-lookup"><span data-stu-id="588cc-176">See also</span></span>

- [<span data-ttu-id="588cc-177">Espacios de nombres y asignación de espacios de nombres XAML para WPF</span><span class="sxs-lookup"><span data-stu-id="588cc-177">XAML Namespaces and Namespace Mapping for WPF XAML</span></span>](xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)
- [<span data-ttu-id="588cc-178">x:Name (Directiva)</span><span class="sxs-lookup"><span data-stu-id="588cc-178">x:Name Directive</span></span>](../../../desktop-wpf/xaml-services/xname-directive.md)
