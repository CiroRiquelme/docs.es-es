---
title: Información general sobre las extensiones de marcado para el lenguaje XAML
ms.date: 03/30/2017
helpviewer_keywords:
- markup extensions [XAML Services], custom
- XAML [XAML Services], markup extensions
ms.assetid: 261b2b11-2dc0-462f-8c66-55b8c9c6e436
ms.openlocfilehash: c0ca8e7d0d68d4730173385540cbcec66c7bf03a
ms.sourcegitcommit: c2d9718996402993cf31541f11e95531bc68bad0
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 02/27/2020
ms.locfileid: "81432945"
---
# <a name="overview-of-markup-extensions-for-xaml"></a><span data-ttu-id="09274-102">Descripción general de las extensiones de marcado para XAML</span><span class="sxs-lookup"><span data-stu-id="09274-102">Overview of markup extensions for XAML</span></span>

<span data-ttu-id="09274-103">Las extensiones de marcado son una técnica XAML para obtener un valor que no es un tipo XAML primitivo o específico.</span><span class="sxs-lookup"><span data-stu-id="09274-103">Markup extensions are a XAML technique for obtaining a value that's not a primitive or a specific XAML type.</span></span> <span data-ttu-id="09274-104">Para el uso de atributos, las extensiones de marcado usan la secuencia de caracteres conocida de una llave de apertura `{` para entrar en el ámbito de la extensión de marcado y una llave de cierre `}` para salir.</span><span class="sxs-lookup"><span data-stu-id="09274-104">For attribute usage, markup extensions use the known character sequence of an opening curly brace `{` to enter the markup extension scope, and a closing curly brace `}` to exit.</span></span> <span data-ttu-id="09274-105">Al usar los servicios XAML de .NET, puede usar algunas de las extensiones de marcado de lenguaje XAML predefinidas del ensamblado System.Xaml.</span><span class="sxs-lookup"><span data-stu-id="09274-105">When using .NET XAML Services, you can use some of the predefined XAML language markup extensions from the System.Xaml assembly.</span></span> <span data-ttu-id="09274-106">También puede crear subclases de la clase <xref:System.Windows.Markup.MarkupExtension> , definida en System.Xaml, y definir sus propias extensiones de marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-106">You can also subclass from the <xref:System.Windows.Markup.MarkupExtension> class, defined in System.Xaml, and define your own markup extensions.</span></span> <span data-ttu-id="09274-107">O bien, puede usar extensiones de marcado definidas por un marco determinado si ya hace referencia a ese marco de trabajo.</span><span class="sxs-lookup"><span data-stu-id="09274-107">Or you can use markup extensions defined by a particular framework if you are already referencing that framework.</span></span>

<span data-ttu-id="09274-108">Cuando se accede al uso de una extensión de marcado, el escritor de objetos XAML puede proporcionar servicios a una clase <xref:System.Windows.Markup.MarkupExtension> personalizada a través de un punto de conexión de servicio en la invalidación <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="09274-108">When a markup extension usage is accessed, the XAML object writer can provide services to a custom <xref:System.Windows.Markup.MarkupExtension> class through a service connection point in the <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A?displayProperty=nameWithType> override.</span></span> <span data-ttu-id="09274-109">Los servicios pueden usarse para obtener contexto sobre el uso, las capacidades concretas del escritor de objetos, el contexto de esquema XAML, etcétera.</span><span class="sxs-lookup"><span data-stu-id="09274-109">The services can be used to obtain context about the usage, specific capabilities of the object writer, XAML schema context, and so on.</span></span>

## <a name="xaml-defined-markup-extensions"></a><span data-ttu-id="09274-110">Extensiones de marcado definidas por XAML</span><span class="sxs-lookup"><span data-stu-id="09274-110">XAML-defined markup extensions</span></span>

<span data-ttu-id="09274-111">Los Servicios XAML de .NET implementan varias extensiones de marcado para la compatibilidad con el lenguaje XAML.</span><span class="sxs-lookup"><span data-stu-id="09274-111">Several markup extensions are implemented by .NET XAML Services for XAML language support.</span></span> <span data-ttu-id="09274-112">Estas extensiones de marcado corresponden a las partes de la especificación de XAML como lenguaje.</span><span class="sxs-lookup"><span data-stu-id="09274-112">These markup extensions correspond to parts of the specification of XAML as a language.</span></span> <span data-ttu-id="09274-113">Suelen identificarse por el prefijo `x:` en la sintaxis, tal como se muestra en el uso común.</span><span class="sxs-lookup"><span data-stu-id="09274-113">These are typically identifiable by the `x:` prefix in the syntax as seen in common usage.</span></span> <span data-ttu-id="09274-114">Las implementaciones de servicios XAML de .NET <xref:System.Windows.Markup.MarkupExtension> para estos elementos de lenguaje XAML derivan de la clase base.</span><span class="sxs-lookup"><span data-stu-id="09274-114">.NET XAML Services implementations for these XAML language elements all derive from the  <xref:System.Windows.Markup.MarkupExtension> base class.</span></span>

> [!NOTE]
> <span data-ttu-id="09274-115">El prefijo `x:` se usa para la asignación de espacio de nombres típica de XAML para el espacio de nombres del lenguaje XAML, en el elemento raíz de una producción de XAML.</span><span class="sxs-lookup"><span data-stu-id="09274-115">The `x:` prefix is used for the typical XAML namespace mapping of the XAML language namespace, in the root element of a XAML production.</span></span> <span data-ttu-id="09274-116">Por ejemplo, las plantillas de proyecto y página de Visual `x:` Studio para varios marcos específicos inician un archivo XAML mediante esta asignación.</span><span class="sxs-lookup"><span data-stu-id="09274-116">For example, the Visual Studio project and page templates for various specific frameworks initiate a XAML file using this `x:` mapping.</span></span> <span data-ttu-id="09274-117">Puede elegir un token de prefijo diferente en su propia asignación de espacio de nombres XAML, pero en esta documentación se presupone la asignación `x:` predeterminada como manera de identificar las entidades que forman una parte definida del espacio de nombres XAML del lenguaje XAML, en lugar de un espacio de nombres XAML predeterminado de un marco concreto o de otros espacios de nombres XML o CLR arbitrarios.</span><span class="sxs-lookup"><span data-stu-id="09274-117">You could choose a different prefix token in your own XAML namespace mapping, but this documentation will assume the default `x:` mapping as a means of identifying those entities that are a defined part of the XAML language XAML namespace, as opposed to a specific framework's default XAML namespace or other arbitrary CLR or XML namespaces.</span></span>

### <a name="xtype"></a><span data-ttu-id="09274-118">x:Type</span><span class="sxs-lookup"><span data-stu-id="09274-118">x:Type</span></span>

<span data-ttu-id="09274-119">`x:Type` proporciona el objeto <xref:System.Type> para el tipo con nombre.</span><span class="sxs-lookup"><span data-stu-id="09274-119">`x:Type` supplies the <xref:System.Type> object for the named type.</span></span> <span data-ttu-id="09274-120">Esta funcionalidad se usa con más frecuencia en los mecanismos de aplazamiento que usan el tipo CLR subyacente y la derivación de tipos como identificador o moniker de agrupación.</span><span class="sxs-lookup"><span data-stu-id="09274-120">This functionality is used most frequently in deferral mechanisms that use underlying CLR type and type derivation as a grouping moniker or identifier.</span></span> <span data-ttu-id="09274-121">Los estilos y plantillas WPF y su uso de las propiedades `TargetType` son un ejemplo concreto.</span><span class="sxs-lookup"><span data-stu-id="09274-121">WPF styles and templates, and their usage of `TargetType` properties, are a specific example.</span></span> <span data-ttu-id="09274-122">Para obtener más información, consulta [x:Type Markup Extension](xtype-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="09274-122">For more information, see [x:Type Markup Extension](xtype-markup-extension.md).</span></span>

### <a name="xstatic"></a><span data-ttu-id="09274-123">x:Static</span><span class="sxs-lookup"><span data-stu-id="09274-123">x:Static</span></span>

<span data-ttu-id="09274-124">`x:Static` genera valores estáticos a partir de entidades de código de tipo de valor que no son directamente el tipo del valor de una propiedad, pero que se pueden evaluar como ese tipo.</span><span class="sxs-lookup"><span data-stu-id="09274-124">`x:Static` produces static values from value-type code entities that are not directly the type of a property's value, but can be evaluated to that type.</span></span> <span data-ttu-id="09274-125">Esto es útil para especificar valores que ya existen, como constantes conocidas en una definición de tipo.</span><span class="sxs-lookup"><span data-stu-id="09274-125">This is useful for specifying values that already exist as well-known constants in a type definition.</span></span> <span data-ttu-id="09274-126">Para obtener más información, consulta [x:Static Markup Extension](xstatic-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="09274-126">For more information, see [x:Static Markup Extension](xstatic-markup-extension.md).</span></span>

### <a name="xnull"></a><span data-ttu-id="09274-127">x:Null</span><span class="sxs-lookup"><span data-stu-id="09274-127">x:Null</span></span>

<span data-ttu-id="09274-128">`x:Null` especifica `null` como valor para un miembro XAML.</span><span class="sxs-lookup"><span data-stu-id="09274-128">`x:Null` specifies `null` as a value for a XAML member.</span></span> <span data-ttu-id="09274-129">En función del diseño de tipos específicos o de conceptos de marco más amplios, `null` no es siempre un valor predeterminado para una propiedad o el valor implícito de un atributo de cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="09274-129">Depending on the design of specific types or on larger framework concepts, `null` is not always a default value for a property, or the implied value of an empty string attribute.</span></span> <span data-ttu-id="09274-130">Para obtener más información, consulta [x:Null Markup Extension](xnull-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="09274-130">For more information, see [x:Null Markup Extension](xnull-markup-extension.md).</span></span>

### <a name="xarray"></a><span data-ttu-id="09274-131">x:Array</span><span class="sxs-lookup"><span data-stu-id="09274-131">x:Array</span></span>

<span data-ttu-id="09274-132">`x:Array` admite la creación de matrices generales en sintaxis XAML en los casos en que no se use deliberadamente el soporte de colección que proporcionan los elementos base y los modelos de control.</span><span class="sxs-lookup"><span data-stu-id="09274-132">`x:Array` supports creation of general arrays in XAML syntax in cases where the collection support that is provided by base elements and control models is deliberately not used.</span></span> <span data-ttu-id="09274-133">Para obtener más información, consulta [x:Array Markup Extension](xarray-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="09274-133">For more information, see [x:Array Markup Extension](xarray-markup-extension.md).</span></span> <span data-ttu-id="09274-134">En concreto en XAML 2009, se accede a las matrices como primitivas del lenguaje, en lugar de como una extensión.</span><span class="sxs-lookup"><span data-stu-id="09274-134">In XAML 2009 specifically, arrays are accessed as language primitives instead of as an extension.</span></span> <span data-ttu-id="09274-135">Para obtener más información, consulta [XAML 2009 Language Features](xaml-2009-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="09274-135">For more information, see [XAML 2009 Language Features](xaml-2009-language-features.md).</span></span>

### <a name="xreference"></a><span data-ttu-id="09274-136">x:Reference</span><span class="sxs-lookup"><span data-stu-id="09274-136">x:Reference</span></span>

<span data-ttu-id="09274-137">`x:Reference` forma parte de XAML 2009, una extensión del lenguaje original (2006).</span><span class="sxs-lookup"><span data-stu-id="09274-137">`x:Reference` is part of XAML 2009, an extension of the original (2006) language set.</span></span> <span data-ttu-id="09274-138">`x:Reference` representa una referencia a otro objeto existente en un gráfico de objetos.</span><span class="sxs-lookup"><span data-stu-id="09274-138">`x:Reference` represents a reference to another existing object in an object graph.</span></span> <span data-ttu-id="09274-139">Dicho objeto se identifica por su `x:Name`.</span><span class="sxs-lookup"><span data-stu-id="09274-139">That object is identified by its `x:Name`.</span></span> <span data-ttu-id="09274-140">Para obtener más información, consulta [x:Reference Markup Extension](xreference-markup-extension.md).</span><span class="sxs-lookup"><span data-stu-id="09274-140">For more information, see [x:Reference Markup Extension](xreference-markup-extension.md).</span></span>

### <a name="other-x-constructs"></a><span data-ttu-id="09274-141">Otras construcciones x:</span><span class="sxs-lookup"><span data-stu-id="09274-141">Other x: Constructs</span></span>

<span data-ttu-id="09274-142">Existen otras construcciones `x:` que admiten características del lenguaje XAML, pero no se implementan como extensiones de marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-142">Other `x:` constructs to support XAML language features exist, but these are not implemented as markup extensions.</span></span> <span data-ttu-id="09274-143">Para obtener más información, consulta [XAML Namespace (x:) Language Features](namespace-language-features.md).</span><span class="sxs-lookup"><span data-stu-id="09274-143">For more information, see [XAML Namespace (x:) Language Features](namespace-language-features.md).</span></span>

## <a name="the-markupextension-base-class"></a><span data-ttu-id="09274-144">Clase base MarkupExtension</span><span class="sxs-lookup"><span data-stu-id="09274-144">The MarkupExtension Base Class</span></span>

<span data-ttu-id="09274-145">Para definir una extensión de marcado personalizada que pueda interactuar con las implementaciones predeterminadas de los lectores y escritores XAML en System.Xaml, derive una clase de la clase abstracta <xref:System.Windows.Markup.MarkupExtension> .</span><span class="sxs-lookup"><span data-stu-id="09274-145">To define a custom markup extension that can interact with the default implementations of XAML readers and XAML writers in System.Xaml, you derive a class from the abstract <xref:System.Windows.Markup.MarkupExtension> class.</span></span> <span data-ttu-id="09274-146">Dicha la clase tiene que invalidar un método, <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>.</span><span class="sxs-lookup"><span data-stu-id="09274-146">That class has one method to override, which is <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>.</span></span> <span data-ttu-id="09274-147">Puede que también tenga que definir constructores adicionales para admitir los argumentos para el uso de la extensión de marcado, así como propiedades configurables coincidentes.</span><span class="sxs-lookup"><span data-stu-id="09274-147">You might also need to define additional constructors to support arguments to the markup extension usage, and matching settable properties.</span></span>

<span data-ttu-id="09274-148">A <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>través de , una extensión de marcado personalizada tiene acceso a un contexto de servicio que notifica el entorno donde un procesador XAML invoca la extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-148">Through <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, a custom markup extension has access to a service context that reports the environment where the markup extension is invoked by a XAML processor.</span></span> <span data-ttu-id="09274-149">En la ruta de carga, <xref:System.Xaml.XamlObjectWriter>esto suele ser un archivo .</span><span class="sxs-lookup"><span data-stu-id="09274-149">In the load path, this is typically a <xref:System.Xaml.XamlObjectWriter>.</span></span> <span data-ttu-id="09274-150">En la ruta de acceso de guardado, suele ser <xref:System.Xaml.XamlXmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="09274-150">In the save path this is typically a <xref:System.Xaml.XamlXmlWriter>.</span></span> <span data-ttu-id="09274-151">Cada una informa del contexto de servicio como una clase interna del contexto del proveedor de servicios XAML que implementa un patrón de proveedor de servicios.</span><span class="sxs-lookup"><span data-stu-id="09274-151">Each report the service context as an internal XAML service provider context class that implements a service provider pattern.</span></span> <span data-ttu-id="09274-152">Para más información sobre los servicios disponibles y lo que representan, vea [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="09274-152">For more information about the available services and what they represent, see [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

<span data-ttu-id="09274-153">La clase de extensión de marcado debe usar un nivel de acceso público; los procesadores XAML deben ser siempre capaces de crear una instancia de la clase de soporte de la extensión de marcado para usar sus servicios.</span><span class="sxs-lookup"><span data-stu-id="09274-153">Your markup extension class must use a public access level; XAML processors must always be able to instantiate the markup extension's support class in order to use its services.</span></span>

## <a name="defining-the-support-type-for-a-custom-markup-extension"></a><span data-ttu-id="09274-154">Definir el tipo de compatibilidad para una extensión de marcado personalizada</span><span class="sxs-lookup"><span data-stu-id="09274-154">Defining the Support Type for a Custom Markup Extension</span></span>

<span data-ttu-id="09274-155">Cuando usa sin fines de trabajo o servicios XAML de .NET que se basan en servicios XAML de .NET, tiene dos opciones para asignar un nombre al tipo de compatibilidad de extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-155">When you use .NET XAML Services or frameworks that build on .NET XAML Services, you have two choices for how to name the markup extension support type.</span></span> <span data-ttu-id="09274-156">El nombre del tipo es pertinente para la manera en que los escritores de objetos XAML intentan obtener acceso e invocar un tipo de compatibilidad de la extensión de marcado cuando encuentran un uso de la extensión de marcado en XAML.</span><span class="sxs-lookup"><span data-stu-id="09274-156">The type name is relevant to how XAML object writers attempt to access and invoke a markup extension support type when they encounter a markup extension usage in XAML.</span></span> <span data-ttu-id="09274-157">Use una de las siguientes estrategias de nomenclatura:</span><span class="sxs-lookup"><span data-stu-id="09274-157">Use one of the following naming strategies:</span></span>

- <span data-ttu-id="09274-158">Asigne al tipo un nombre que coincida exactamente con el token de uso del marcado XAML.</span><span class="sxs-lookup"><span data-stu-id="09274-158">Name the type name to be an exact match to the XAML markup usage token.</span></span> <span data-ttu-id="09274-159">Por ejemplo, para admitir el uso de la extensión `{Collate ...}` , asigne al tipo de compatibilidad el nombre `Collate`.</span><span class="sxs-lookup"><span data-stu-id="09274-159">For example, to support a `{Collate ...}` extension usage, name the support type `Collate`.</span></span>
- <span data-ttu-id="09274-160">Asigne al tipo un nombre que sea el token de la cadena de uso más el sufijo `Extension`.</span><span class="sxs-lookup"><span data-stu-id="09274-160">Name the type name to be the usage string token plus the suffix `Extension`.</span></span> <span data-ttu-id="09274-161">Por ejemplo, para admitir el uso de la extensión `{Collate ...}` , asigne al tipo de compatibilidad el nombre `CollateExtension`.</span><span class="sxs-lookup"><span data-stu-id="09274-161">For example, to support a `{Collate ...}` extension usage, name the support type `CollateExtension`.</span></span>

<span data-ttu-id="09274-162">Según el orden de búsqueda, primero se busca el nombre de clase con el sufijo `Extension`y, a continuación, se busca el nombre de clase sin el sufijo `Extension` .</span><span class="sxs-lookup"><span data-stu-id="09274-162">The order of lookup is to look for the `Extension`-suffixed class name first and then look for the class name without the `Extension` suffix.</span></span>

<span data-ttu-id="09274-163">Desde la perspectiva del uso del marcado, es válido incluir el sufijo `Extension` como parte del uso.</span><span class="sxs-lookup"><span data-stu-id="09274-163">From the markup usage perspective, including the `Extension` suffix as part of the usage is valid.</span></span> <span data-ttu-id="09274-164">Sin embargo, esto se comporta como si `Extension` realmente formase parte del nombre de clase, y los escritores de objetos XAML no podrían resolver una clase de compatibilidad de la extensión de marcado para ese uso si la clase de compatibilidad no tuviese el sufijo `Extension` .</span><span class="sxs-lookup"><span data-stu-id="09274-164">However, this behaves as if `Extension` is truly part of the class name, and XAML object writers would fail to resolve a markup extension support class for that usage if the support class did not have the `Extension` suffix.</span></span>

### <a name="the-parameterless-constructor"></a><span data-ttu-id="09274-165">El constructor sin parámetros</span><span class="sxs-lookup"><span data-stu-id="09274-165">The parameterless constructor</span></span>

<span data-ttu-id="09274-166">Para todos los tipos de compatibilidad de extensión de marcado, debe exponer un constructor público sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="09274-166">For all markup extension support types, you should expose a public parameterless constructor.</span></span> <span data-ttu-id="09274-167">Un constructor sin parámetros es necesario para cualquier caso en el que un escritor de objetos XAML crea una instancia de la extensión de marcado a partir de un uso de elemento de objeto.</span><span class="sxs-lookup"><span data-stu-id="09274-167">A parameterless constructor is required for any case where a XAML object writer instantiates the markup extension from an object element usage.</span></span> <span data-ttu-id="09274-168">La compatibilidad con el uso de elementos de objeto es una expectativa lógica para una extensión de marcado, en especial para la serialización.</span><span class="sxs-lookup"><span data-stu-id="09274-168">Supporting object element usage is a fair expectation for a markup extension, particularly for serialization.</span></span> <span data-ttu-id="09274-169">Sin embargo, puede implementar una extensión de marcado sin un constructor público si solo desea admitir usos de atributos de la extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-169">However, you can implement a markup extension without a public constructor if you only intend to support attribute usages of the markup extension.</span></span>

<span data-ttu-id="09274-170">Si el uso de la extensión de marcado no tiene argumentos, el constructor sin parámetros es necesario para admitir el uso.</span><span class="sxs-lookup"><span data-stu-id="09274-170">If your markup extension usage has no arguments, the parameterless constructor is required to support usage.</span></span>

## <a name="constructor-patterns-and-positional-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="09274-171">Patrones de constructor y argumentos posicionales para una extensión de marcado personalizada</span><span class="sxs-lookup"><span data-stu-id="09274-171">Constructor Patterns and Positional Arguments for a Custom Markup Extension</span></span>

<span data-ttu-id="09274-172">En una extensión de marcado con el uso previsto del argumento, los constructores públicos deben corresponderse con los modos del uso previsto.</span><span class="sxs-lookup"><span data-stu-id="09274-172">For a markup extension with intended argument usage, the public constructors must correspond to the modes of the intended usage.</span></span> <span data-ttu-id="09274-173">En otras palabras, si su extensión de marcado está diseñada para requerir un argumento posicional como uso válido, debe admitir un constructor público con un parámetro de entrada que tome el argumento posicional.</span><span class="sxs-lookup"><span data-stu-id="09274-173">In other words, if your markup extension is designed to require one positional argument as a valid usage, you should support a public constructor with one input parameter that takes the positional argument.</span></span>

<span data-ttu-id="09274-174">Por ejemplo, supongamos que la extensión de marcado `Collate` está pensada para admitir solo un modo en el que hay un argumento posicional que representa su modo, especificado como una constante de enumeración `CollationMode` .</span><span class="sxs-lookup"><span data-stu-id="09274-174">For example, suppose the `Collate` markup extension is intended to support only a mode where there is one positional argument that represents its mode, specified as a `CollationMode` enumeration constant.</span></span> <span data-ttu-id="09274-175">En este caso, debe haber un constructor con el formato siguiente:</span><span class="sxs-lookup"><span data-stu-id="09274-175">In this case, there should be a constructor with the following form:</span></span>

```csharp
public Collate(CollationMode collationMode) {...}
```

<span data-ttu-id="09274-176">En un nivel básico, los argumentos pasados a una extensión de marcado son una cadena, ya que se reenvían desde los valores de atributo del marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-176">At a basic level, the arguments passed to a markup extension are a string because they are being forwarded from the markup's attribute values.</span></span> <span data-ttu-id="09274-177">Puede hacer que todos los argumentos sean cadenas y trabajar con entradas en ese nivel.</span><span class="sxs-lookup"><span data-stu-id="09274-177">You can make all of your arguments strings and work with input at that level.</span></span> <span data-ttu-id="09274-178">Sin embargo, tiene acceso a cierto procesamiento que se produce antes de que los argumentos de extensión de marcado se pasan a la clase de compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="09274-178">However, you do have access to certain processing that occurs before the markup extension arguments are passed to the support class.</span></span>

<span data-ttu-id="09274-179">El procesamiento funciona conceptualmente como si la extensión de marcado fuera un objeto que se va a crear y, a continuación, se establecieran sus valores de miembro.</span><span class="sxs-lookup"><span data-stu-id="09274-179">The processing works conceptually as if the markup extension is an object to be created, and then its member values are set.</span></span> <span data-ttu-id="09274-180">Cada propiedad especificada que se va a establecer se evalúa de modo similar a la manera en que se puede establecer un miembro especificado en un objeto creado cuando se analiza XAML.</span><span class="sxs-lookup"><span data-stu-id="09274-180">Each specified property to set is evaluated similar to how a specified member can be set on a created object when XAML is parsed.</span></span> <span data-ttu-id="09274-181">Hay dos diferencias importantes:</span><span class="sxs-lookup"><span data-stu-id="09274-181">There are two important differences:</span></span>

- <span data-ttu-id="09274-182">Como se indicó anteriormente, un tipo de compatibilidad de extensión de marcado no necesita tener un constructor sin parámetros para que se cree una instancia en XAML.</span><span class="sxs-lookup"><span data-stu-id="09274-182">As noted previously, a markup extension support type does not need to have a parameterless constructor in order to be instantiated in XAML.</span></span> <span data-ttu-id="09274-183">La construcción de objetos se aplaza hasta que sus posibles argumentos en la sintaxis de texto se conviertan en tokens y se evalúen como argumentos con nombre o posicionales y se llame al constructor adecuado en ese momento.</span><span class="sxs-lookup"><span data-stu-id="09274-183">Its object construction is deferred until its possible arguments in the text syntax are tokenized and evaluated as either positional or named arguments, and the appropriate constructor is called at that time.</span></span>
- <span data-ttu-id="09274-184">Los usos de las extensiones de marcado se pueden anidar.</span><span class="sxs-lookup"><span data-stu-id="09274-184">Markup extensions usages can be nested.</span></span> <span data-ttu-id="09274-185">Primero se evalúa la extensión de marcado más interna.</span><span class="sxs-lookup"><span data-stu-id="09274-185">The innermost markup extension is evaluated first.</span></span> <span data-ttu-id="09274-186">Por lo tanto, puede suponer este tipo de uso y declarar uno de los parámetros de construcción de modo que sea un tipo que requiere que se genere un convertidor de valores (como una extensión de marcado).</span><span class="sxs-lookup"><span data-stu-id="09274-186">Therefore, you can assume such a usage and declare one of the construction parameters to be a type that requires a value converter (such as a markup extension) to produce.</span></span>

<span data-ttu-id="09274-187">En el ejemplo anterior se mostró una dependencia de este procesamiento.</span><span class="sxs-lookup"><span data-stu-id="09274-187">A reliance on such processing was shown in the previous example.</span></span> <span data-ttu-id="09274-188">El escritor de objetos XAML de servicios XAML de .NET procesa los nombres constantes de enumeración en valores enumerados en un nivel nativo.</span><span class="sxs-lookup"><span data-stu-id="09274-188">.NET XAML Services XAML object writer processes enumeration constant names into enumerated values at a native level.</span></span>

<span data-ttu-id="09274-189">El procesamiento de sintaxis de texto de un parámetro posicional de extensión de marcado también puede basarse en un convertidor de tipos que esté asociado al tipo que se encuentra en el argumento de construcción.</span><span class="sxs-lookup"><span data-stu-id="09274-189">Processing text syntax of a markup extension positional parameter can also rely on a type converter that is associated with the type that is in the construction argument.</span></span>

<span data-ttu-id="09274-190">Los argumentos se denominan posicionales porque el orden en que se encuentran los tokens en el uso corresponde al orden posicional del parámetro de constructor al que están asignados.</span><span class="sxs-lookup"><span data-stu-id="09274-190">The arguments are called positional arguments because the order in which the tokens in the usage is encountered corresponds to the positional order of the constructor parameter to which they are assigned.</span></span> <span data-ttu-id="09274-191">Por ejemplo, considere la siguiente firma de constructor:</span><span class="sxs-lookup"><span data-stu-id="09274-191">For example, consider the following constructor signature:</span></span>

```csharp
public Collate(CollationMode collationMode, object collateThis) {...}
```

<span data-ttu-id="09274-192">Un procesador XAML espera dos argumentos posicionales para esta extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-192">A XAML processor expects two positional arguments for this markup extension.</span></span> <span data-ttu-id="09274-193">Si hubo un uso `{Collate AlphaUp,{x:Reference circularFile}}`, el token `AlphaUp` se envía al primer parámetro y se evalúa como una enumeración denominada constante `CollationMode` .</span><span class="sxs-lookup"><span data-stu-id="09274-193">If there was a usage `{Collate AlphaUp,{x:Reference circularFile}}`, the `AlphaUp` token is sent to the first parameter and evaluated as a `CollationMode` enumeration named constant.</span></span> <span data-ttu-id="09274-194">El resultado de la `x:Reference` interna se envía al segundo parámetro y se evalúa como un objeto.</span><span class="sxs-lookup"><span data-stu-id="09274-194">The result of the inner `x:Reference` is sent to the second parameter and evaluated as an object.</span></span>

<span data-ttu-id="09274-195">En las reglas especificadas de XAML para la sintaxis y el procesamiento de la extensión de marcado, la coma es el delimitador entre los argumentos, tanto si son argumentos posicionales como argumentos con nombre.</span><span class="sxs-lookup"><span data-stu-id="09274-195">In the XAML specified rules for markup extension syntax and processing, the comma is the delimiter between arguments, whether those arguments are positional arguments or named arguments.</span></span>

### <a name="duplicate-arity-of-positional-arguments"></a><span data-ttu-id="09274-196">Aridad duplicada de argumentos posicionales</span><span class="sxs-lookup"><span data-stu-id="09274-196">Duplicate arity of positional arguments</span></span>

<span data-ttu-id="09274-197">Si un escritor de objetos XAML encuentra un uso de la extensión de marcado con argumentos posicionales y hay varios argumentos de constructor que toman ese número de argumentos (una aridad duplicada), no se trata necesariamente de un error.</span><span class="sxs-lookup"><span data-stu-id="09274-197">If a XAML object writer encounters a markup extension usage with positional arguments, and there are multiple constructor arguments that take that number of arguments (a duplicate arity), that is not necessarily an error.</span></span> <span data-ttu-id="09274-198">El comportamiento depende de un valor de contexto de esquema XAML personalizable, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>.</span><span class="sxs-lookup"><span data-stu-id="09274-198">The behavior depends on a customizable XAML schema context setting, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A>.</span></span> <span data-ttu-id="09274-199">Si <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> es `true`, un escritor de objetos XAML no debería iniciar una excepción solo por razones de aridad duplicada.</span><span class="sxs-lookup"><span data-stu-id="09274-199">If <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `true`, a XAML object writer should not throw an exception only for reasons of duplicate arity.</span></span> <span data-ttu-id="09274-200">El comportamiento a partir de ese punto no está definido estrictamente.</span><span class="sxs-lookup"><span data-stu-id="09274-200">Behavior beyond that point is not strictly defined.</span></span> <span data-ttu-id="09274-201">La hipótesis de diseño básica es que el contexto del esquema tiene información de tipo disponible para los parámetros específicos y puede intentar conversiones explícitas que coinciden con los candidatos duplicados para comprobar qué firma es la mejor coincidencia.</span><span class="sxs-lookup"><span data-stu-id="09274-201">The basic design assumption is that the schema context has type information available for the specific parameters and can attempt explicit casts that match the duplicate candidates to see which signature might be the best match.</span></span> <span data-ttu-id="09274-202">Podría iniciarse igualmente una excepción si ninguna firma supera las pruebas impuestas por el contexto de esquema concreto que se ejecuta en un escritor de objetos XAML.</span><span class="sxs-lookup"><span data-stu-id="09274-202">An exception might still be thrown if no signatures can pass the tests that are imposed by that particular schema context that is running on a XAML object writer.</span></span>

<span data-ttu-id="09274-203">De forma <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> `false` predeterminada, está <xref:System.Xaml.XamlSchemaContext> en el CLR basado para los servicios XAML de .NET.</span><span class="sxs-lookup"><span data-stu-id="09274-203">By default, <xref:System.Xaml.XamlSchemaContextSettings.SupportMarkupExtensionsWithDuplicateArity%2A> is `false` in the CLR-based <xref:System.Xaml.XamlSchemaContext> for .NET XAML Services.</span></span> <span data-ttu-id="09274-204">Por lo tanto, el <xref:System.Xaml.XamlObjectWriter> predeterminado genera una excepción si encuentra un uso de la extensión de marcado con aridad duplicada en los constructores del tipo de respaldo.</span><span class="sxs-lookup"><span data-stu-id="09274-204">Thus, the default <xref:System.Xaml.XamlObjectWriter> throws exceptions if it encounters a markup extension usage where there is duplicate arity in the backing type's constructors.</span></span>

## <a name="named-arguments-for-a-custom-markup-extension"></a><span data-ttu-id="09274-205">Argumentos con nombre para una extensión de marcado personalizada</span><span class="sxs-lookup"><span data-stu-id="09274-205">Named arguments for a custom markup extension</span></span>

<span data-ttu-id="09274-206">Las extensiones de marcado que especifica XAML también pueden usar un formulario de argumentos con nombre para el uso.</span><span class="sxs-lookup"><span data-stu-id="09274-206">Markup extensions as specified by XAML can also use a named arguments form for usage.</span></span> <span data-ttu-id="09274-207">En el primer nivel de tokenización, la sintaxis de texto se divide en argumentos.</span><span class="sxs-lookup"><span data-stu-id="09274-207">At the first level of tokenization, the text syntax is divided into arguments.</span></span> <span data-ttu-id="09274-208">La presencia de un signo igual (=) en un argumento lo identifica como argumento con nombre.</span><span class="sxs-lookup"><span data-stu-id="09274-208">The presence of an equals sign (=) within any argument identifies an argument as a named argument.</span></span> <span data-ttu-id="09274-209">Dicho argumento también se convierte en token en un par nombre-valor.</span><span class="sxs-lookup"><span data-stu-id="09274-209">Such an argument is also tokenized into a name/value pair.</span></span> <span data-ttu-id="09274-210">En este caso, el nombre designa una propiedad pública configurable del tipo de compatibilidad de la extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-210">The name in this case names a public settable property of the markup extension's support type.</span></span> <span data-ttu-id="09274-211">Si piensa admitir el uso de argumentos con nombre, debe proporcionar estas propiedades públicas configurables.</span><span class="sxs-lookup"><span data-stu-id="09274-211">If you intend to support named argument usage, you should provide these public settable properties.</span></span> <span data-ttu-id="09274-212">Las propiedades pueden ser heredadas, siempre y cuando sigan siendo públicas.</span><span class="sxs-lookup"><span data-stu-id="09274-212">The properties can be inherited properties as long as they remain public.</span></span>

## <a name="accessing-service-provider-context-from-a-markup-extension-implementation"></a><span data-ttu-id="09274-213">Acceder al contexto del proveedor de servicios desde una implementación de la extensión de marcado</span><span class="sxs-lookup"><span data-stu-id="09274-213">Accessing Service Provider Context from a Markup Extension Implementation</span></span>

<span data-ttu-id="09274-214">Los servicios disponibles son los mismos para todos los convertidores de valores.</span><span class="sxs-lookup"><span data-stu-id="09274-214">The services available are the same for any value converter.</span></span> <span data-ttu-id="09274-215">La diferencia radica en la manera en que cada convertidor de valores recibe el contexto de servicio.</span><span class="sxs-lookup"><span data-stu-id="09274-215">The difference is in how each value converter receives the service context.</span></span> <span data-ttu-id="09274-216">El acceso a los servicios y los servicios disponibles se documentan en el tema [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span><span class="sxs-lookup"><span data-stu-id="09274-216">Accessing services and the services available are documented in the topic [Type Converters and Markup Extensions for XAML](type-converters-and-markup-extensions.md).</span></span>

## <a name="property-element-usage-of-a-markup-extension"></a><span data-ttu-id="09274-217">Uso de elementos de propiedad de una extensión de marcado</span><span class="sxs-lookup"><span data-stu-id="09274-217">Property element usage of a markup extension</span></span>

<span data-ttu-id="09274-218">Los escenarios para los usos de la extensión de marcado suelen estar diseñados para emplear la extensión de marcado en el uso de atributos.</span><span class="sxs-lookup"><span data-stu-id="09274-218">The scenarios for markup extension usages are often designed around using the markup extension in attribute usage.</span></span> <span data-ttu-id="09274-219">Sin embargo, también es posible definir la clase de respaldo de modo que admita el uso de elementos de propiedad.</span><span class="sxs-lookup"><span data-stu-id="09274-219">However, it is also potentially possible to define the backing class to support property element usage.</span></span>

<span data-ttu-id="09274-220">Para admitir el uso de elementos de propiedad de la extensión de marcado, defina un constructor público sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="09274-220">To support property element usage of your markup extension, define a public parameterless constructor.</span></span> <span data-ttu-id="09274-221">Debe ser un constructor de instancia, no un constructor estático.</span><span class="sxs-lookup"><span data-stu-id="09274-221">This should be an instance constructor not a static constructor.</span></span> <span data-ttu-id="09274-222">Esto es necesario porque un procesador XAML normalmente debe invocar el constructor sin parámetros en cualquier elemento de objeto que procesa desde el marcado, y esto incluye clases de extensión de marcado como elementos de objeto.</span><span class="sxs-lookup"><span data-stu-id="09274-222">This is required because a XAML processor must generally invoke the parameterless constructor on any object element it processes from markup, and this includes markup extension classes as object elements.</span></span> <span data-ttu-id="09274-223">En el caso de escenarios avanzados, puede definir rutas de acceso de construcción no predeterminadas para las clases.</span><span class="sxs-lookup"><span data-stu-id="09274-223">For advanced scenarios, you can define non-default construction paths for classes.</span></span> <span data-ttu-id="09274-224">(Para obtener más información, consulte [x:FactoryMethod Directive](xfactorymethod-directive.md).) Sin embargo, no debe usar estos patrones con fines de extensión de marcado porque esto hace que la detección del patrón de uso sea mucho más difícil, tanto para los diseñadores como para los usuarios de marcado sin formato.</span><span class="sxs-lookup"><span data-stu-id="09274-224">(For more information, see [x:FactoryMethod Directive](xfactorymethod-directive.md).) However, you should not use these patterns for markup extension purposes because this makes discovery of the usage pattern much more difficult, both for designers and for users of raw markup.</span></span>

## <a name="attributing-for-a-custom-markup-extension"></a><span data-ttu-id="09274-225">Atribuir para una extensión de marcado personalizada</span><span class="sxs-lookup"><span data-stu-id="09274-225">Attributing for a custom markup extension</span></span>

<span data-ttu-id="09274-226">Para admitir entornos de diseño y ciertos escenarios del escritor de objetos XAML, debe atribuir varios atributos CLR a un tipo de compatibilidad de la extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-226">To support both design environments and certain XAML object writer scenarios, you should attribute a markup extension support type with several CLR attributes.</span></span> <span data-ttu-id="09274-227">Estos atributos notifican el uso previsto de la extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-227">These attributes report the intended markup extension usage.</span></span>

 <span data-ttu-id="09274-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> notifica información <xref:System.Type> del tipo de objeto que <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> devuelve.</span><span class="sxs-lookup"><span data-stu-id="09274-228"><xref:System.Windows.Markup.MarkupExtensionReturnTypeAttribute> reports the <xref:System.Type> information for the object type that <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns.</span></span> <span data-ttu-id="09274-229">Por su firma pura, <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> devuelve <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="09274-229">By its pure signature, <xref:System.Windows.Markup.ArrayExtension.ProvideValue%2A> returns <xref:System.Object>.</span></span> <span data-ttu-id="09274-230">Sin embargo, algunos consumidores podrían desear información más precisa sobre el tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="09274-230">But various consumers might want more precise return type information.</span></span> <span data-ttu-id="09274-231">Esto incluye:</span><span class="sxs-lookup"><span data-stu-id="09274-231">This includes:</span></span>

- <span data-ttu-id="09274-232">Diseñadores e IDE, que pueden proporcionar compatibilidad con reconocimiento del tipo para los usos de la extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-232">Designers and IDEs, who might be able to provide type-aware support for markup extension usages.</span></span>
- <span data-ttu-id="09274-233">Implementaciones avanzadas de controladores `SetMarkupExtension` en las clases de destino, que podrían basarse en la reflexión para determinar el tipo de valor devuelto de una extensión de marcado, en lugar de realizar una bifurcación en implementaciones <xref:System.Windows.Markup.MarkupExtension> conocidas específicas por nombre.</span><span class="sxs-lookup"><span data-stu-id="09274-233">Advanced implementations of `SetMarkupExtension` handlers on target classes, which might rely on reflection to determine a markup extension's return type instead of branching on specific known <xref:System.Windows.Markup.MarkupExtension> implementations by name.</span></span>

## <a name="serialization-of-markup-extension-usages"></a><span data-ttu-id="09274-234">Serialización de usos de extensión de marcado</span><span class="sxs-lookup"><span data-stu-id="09274-234">Serialization of markup extension usages</span></span>

<span data-ttu-id="09274-235">Cuando un escritor de objetos XAML procesa el uso de una extensión de marcado y llama a <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, el contexto de cuando era el uso de una extensión de marcado se conserva en el flujo de nodo XAML, pero no en el gráfico de objetos.</span><span class="sxs-lookup"><span data-stu-id="09274-235">When a XAML object writer processes a markup extension usage and calls <xref:System.Windows.Markup.MarkupExtension.ProvideValue%2A>, the context for it previously being a markup extension usage persists in the XAML node stream but not in the object graph.</span></span> <span data-ttu-id="09274-236">En el gráfico de objetos, solo se conserva el valor.</span><span class="sxs-lookup"><span data-stu-id="09274-236">In the object graph, only the value is preserved.</span></span> <span data-ttu-id="09274-237">Si tiene escenarios de diseño u otras razones para conservar el uso de la extensión de marcado original en el resultado serializado, debe diseñar su propia infraestructura para realizar el seguimiento de los usos de la extensión de marcado desde el flujo de nodo XAML de la ruta de acceso de carga.</span><span class="sxs-lookup"><span data-stu-id="09274-237">If you have design scenarios or other reasons for persisting the original markup extension usage into the serialized output, you must design your own infrastructure for tracking the markup extension usages from the load path XAML node stream.</span></span> <span data-ttu-id="09274-238">Puede implementar un comportamiento que vuelva a crear los elementos del flujo de nodo a partir de la ruta de acceso de carga y los reproduzca en escritores XAML para la serialización en la ruta de acceso de guardado, sustituyendo el valor en la posición adecuada del flujo de nodo.</span><span class="sxs-lookup"><span data-stu-id="09274-238">You can implement behavior to recreate the elements of the node stream from the load path and play them back to XAML writers for serialization in the save path, substituting for the value in the appropriate position of the node stream.</span></span>

## <a name="markup-extensions-in-the-xaml-node-stream"></a><span data-ttu-id="09274-239">Extensiones de marcado en el flujo de nodo XAML</span><span class="sxs-lookup"><span data-stu-id="09274-239">Markup extensions in the XAML node stream</span></span>

<span data-ttu-id="09274-240">Si está trabajando con un flujo de nodo XAML en la ruta de acceso de carga, el uso de una extensión de marcado aparece como objeto en el flujo de nodo.</span><span class="sxs-lookup"><span data-stu-id="09274-240">If you are working with a XAML node stream on the load path, a markup extension usage appears in the node stream as an object.</span></span>

<span data-ttu-id="09274-241">Si el uso de la extensión de marcado usa argumentos posicionales, se representa como un objeto de inicio con un valor de inicialización.</span><span class="sxs-lookup"><span data-stu-id="09274-241">If the markup extension usage uses positional arguments, it is represented as a start object with an initialization value.</span></span> <span data-ttu-id="09274-242">Como representación de texto aproximada, el flujo de nodo se parece a lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="09274-242">As a rough text representation, the node stream resembles the following:</span></span>

<span data-ttu-id="09274-243">`StartObject` (<xref:System.Xaml.XamlType> es el tipo de definición de la extensión de marcado, no el tipo de valor devuelto)</span><span class="sxs-lookup"><span data-stu-id="09274-243">`StartObject` (<xref:System.Xaml.XamlType> is the markup extension's definition type, not its return type)</span></span>

<span data-ttu-id="09274-244">`StartMember` (el nombre de <xref:System.Xaml.XamlMember> es `_InitializationText`)</span><span class="sxs-lookup"><span data-stu-id="09274-244">`StartMember` (name of the <xref:System.Xaml.XamlMember> is `_InitializationText`)</span></span>

<span data-ttu-id="09274-245">`Value` (el valor son los argumentos posicionales como cadena, incluidos los delimitadores que intervengan)</span><span class="sxs-lookup"><span data-stu-id="09274-245">`Value` (value is the positional arguments as a string including the intervening delimiters)</span></span>

`EndMember`

`EndObject`

<span data-ttu-id="09274-246">El uso de una extensión de marcado con argumentos con nombre se representa como un objeto con miembros de los nombres correspondientes, cada conjunto de ellos con valores de cadena de texto.</span><span class="sxs-lookup"><span data-stu-id="09274-246">A markup extension usage with named arguments is represented as an object with members of the relevant names, each set with text string values.</span></span>

<span data-ttu-id="09274-247">Para invocar realmente la implementación `ProvideValue` de una extensión de marcado se requiere el contexto de esquema XAML, ya que es necesaria la asignación de tipos y la creación de una instancia de tipo de compatibilidad de la extensión de marcado.</span><span class="sxs-lookup"><span data-stu-id="09274-247">Actually invoking the `ProvideValue` implementation of a markup extension requires the XAML schema context because that requires type-mapping and creating a markup extension support type instance.</span></span> <span data-ttu-id="09274-248">Esta es una razón por la que los usos de la extensión de marcado se conservan de esta manera en los flujos de nodo predeterminados de servicios XAML de .NET: la parte del lector de una ruta de acceso de carga a menudo no tiene el contexto de esquema XAML necesario disponible.</span><span class="sxs-lookup"><span data-stu-id="09274-248">This is one reason why markup extension usages are preserved this way in the default .NET XAML Services node streams -  the reader part of a load path often does not have the necessary XAML schema context available.</span></span>

<span data-ttu-id="09274-249">Si está trabajando con un flujo de nodo XAML en la ruta de acceso de guardado, no suele haber nada en una representación del gráfico de objetos que informe de que el objeto que se va a serializar se proporcionó originalmente mediante el uso de una extensión de marcado y un resultado `ProvideValue` .</span><span class="sxs-lookup"><span data-stu-id="09274-249">If you are working with a XAML node stream on the save path, there generally is nothing present in an object graph representation that can inform you that the object to serialize was originally provided by a markup extension usage and a `ProvideValue` result.</span></span> <span data-ttu-id="09274-250">Los escenarios que necesitan conservar los usos de la extensión de marcado para realizar un recorrido de ida y vuelta y, al mismo tiempo, capturar otros cambios en el gráfico de objetos deben diseñar sus propias técnicas para conservar el conocimiento del uso de una extensión de marcado a partir de la entrada XAML original.</span><span class="sxs-lookup"><span data-stu-id="09274-250">Scenarios that need to persist markup extension usages for round-tripping while also capturing other changes in the object graph must devise their own techniques for preserving the knowledge of a markup extension usage from the original XAML input.</span></span> <span data-ttu-id="09274-251">Por ejemplo, para restaurar los usos de la extensión de marcado, puede que necesite trabajar con el flujo de nodo en la ruta de acceso de guardado para restaurar los usos de la extensión de marcado, o bien realizar algún tipo de combinación entre el XAML original y el XAML de ida y vuelta.</span><span class="sxs-lookup"><span data-stu-id="09274-251">For example, to restore the markup extension usages, you may need to work with the node stream on the save path in order to restore markup extension usages, or perform some type of merge between the original XAML and the round-tripped XAML.</span></span> <span data-ttu-id="09274-252">Algunos marcos que implementan XAML, como WPF, usan tipos intermedios (expresiones) para ayudar a representar casos cuando los usos de la extensión de marcado proporcionaron los valores.</span><span class="sxs-lookup"><span data-stu-id="09274-252">Some XAML-implementing frameworks such as WPF use intermediate types (expressions) to help represent cases where markup extension usages provided the values.</span></span>

## <a name="see-also"></a><span data-ttu-id="09274-253">Consulte también</span><span class="sxs-lookup"><span data-stu-id="09274-253">See also</span></span>

- <xref:System.Windows.Markup.MarkupExtension>
- [<span data-ttu-id="09274-254">Convertidores de tipos y extensiones de marcado para XAML</span><span class="sxs-lookup"><span data-stu-id="09274-254">Type Converters and Markup Extensions for XAML</span></span>](type-converters-and-markup-extensions.md)
- [<span data-ttu-id="09274-255">Extensiones de marcado y XAML de WPF</span><span class="sxs-lookup"><span data-stu-id="09274-255">Markup Extensions and WPF XAML</span></span>](../../framework/wpf/advanced/markup-extensions-and-wpf-xaml.md)
